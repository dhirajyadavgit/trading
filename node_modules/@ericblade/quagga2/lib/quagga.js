(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 89);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(19);

var assertThisInitialized = __webpack_require__(1);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(224);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(62),
  create: __webpack_require__(63),
  clone: __webpack_require__(156),
  fromValues: __webpack_require__(157),
  copy: __webpack_require__(158),
  set: __webpack_require__(159),
  equals: __webpack_require__(160),
  exactEquals: __webpack_require__(161),
  add: __webpack_require__(162),
  subtract: __webpack_require__(64),
  sub: __webpack_require__(163),
  multiply: __webpack_require__(65),
  mul: __webpack_require__(164),
  divide: __webpack_require__(66),
  div: __webpack_require__(165),
  inverse: __webpack_require__(166),
  min: __webpack_require__(167),
  max: __webpack_require__(168),
  rotate: __webpack_require__(169),
  floor: __webpack_require__(170),
  ceil: __webpack_require__(171),
  round: __webpack_require__(172),
  scale: __webpack_require__(173),
  scaleAndAdd: __webpack_require__(174),
  distance: __webpack_require__(67),
  dist: __webpack_require__(175),
  squaredDistance: __webpack_require__(68),
  sqrDist: __webpack_require__(176),
  length: __webpack_require__(69),
  len: __webpack_require__(177),
  squaredLength: __webpack_require__(70),
  sqrLen: __webpack_require__(178),
  negate: __webpack_require__(179),
  normalize: __webpack_require__(180),
  dot: __webpack_require__(181),
  cross: __webpack_require__(182),
  lerp: __webpack_require__(183),
  random: __webpack_require__(184),
  transformMat2: __webpack_require__(185),
  transformMat2d: __webpack_require__(186),
  transformMat3: __webpack_require__(187),
  transformMat4: __webpack_require__(188),
  forEach: __webpack_require__(189),
  limit: __webpack_require__(190)
};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(arr, val) {
    // arr.fill(val);
    var l = arr.length;

    while (l--) {
      arr[l] = val;
    }
  },

  /**
   * Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    var i = arr.length - 1;

    for (i; i >= 0; i--) {
      var j = Math.floor(Math.random() * i);
      var x = arr[i];
      arr[i] = arr[j];
      arr[j] = x;
    }

    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },

  /**
   * returns the elements which's score is bigger than the threshold
   */
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }

      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }

    return max;
  },
  max: function max(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }

    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;

    while (length--) {
      sum += arr[length];
    }

    return sum;
  }
});

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);
/* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8);







var vec2 = {
  clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__["clone"]
};

function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}

var ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "data", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "size", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "indexMapping", void 0);

    if (!data) {
      this.data = new ArrayType(size.x * size.y);

      if (initialize) {
        _array_helper__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].init(this.data, 0);
      }
    } else {
      this.data = data;
    }

    this.size = size;
  } // tests if a position is within the image, extended out by a border on each side


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border); // TODO: code_128 starts failing miserably when i only allow imgRef to contain positive numbers.
      // TODO: this doesn't make much sense to me, why does it go negative?  Tests are not affected by
      // returning false, but the whole code_128 reader blows up when i throw on negative imgRef.
      // assertNumberPositive(imgRef.x);
      // assertNumberPositive(imgRef.y);

      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    } // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.

  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
          sizeX = _imageWrapper$size.x,
          sizeY = _imageWrapper$size.y;

      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }

      return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    } // Retrieve a grayscale value at the given pixel position of the image

  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    } // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)

  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };

        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }

        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }

      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    } // Sets a given pixel position in the image to the given grayscale value

  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    } // Sets the border of the image (1 pixel) to zero

  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
          width = _this$size.x,
          height = _this$size.y;

      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }

      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }

      delete this.indexMapping;
      return this;
    } // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.

  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;

      if (labelCount <= 0) {
        return result;
      }

      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }

      for (y = 0; y < height; y++) {
        ysq = y * y;

        for (x = 0; x < width; x++) {
          val = data[y * width + x];

          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }

      for (i = 0; i < labelCount; i++) {
        label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

          label.theta = (tmp * 180 / PI + 90) % 180 - 90;

          if (label.theta < 0) {
            label.theta += 180;
          }

          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }

      return result;
    } // return a Uint8ClampedArray containing this grayscale image converted to RGBA form

  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);

      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }

      return ret;
    } // Display this ImageWrapper in a given Canvas element at the specified scale

  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

      canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    } // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.

  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;

      while (length--) {
        hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_5__["hsv2rgb"])(hsv, rgb);
        var pos = length * 4;
        var _result = result;

        var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);

        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }

      ctx.putImageData(frame, from.x, from.y);
    }
  }]);

  return ImageWrapper;
}();

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "imageRef", function() { return /* binding */ imageRef; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage2", function() { return /* binding */ computeIntegralImage2; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage", function() { return /* binding */ computeIntegralImage; });
__webpack_require__.d(__webpack_exports__, "thresholdImage", function() { return /* binding */ thresholdImage; });
__webpack_require__.d(__webpack_exports__, "computeHistogram", function() { return /* binding */ computeHistogram; });
__webpack_require__.d(__webpack_exports__, "sharpenLine", function() { return /* binding */ sharpenLine; });
__webpack_require__.d(__webpack_exports__, "determineOtsuThreshold", function() { return /* binding */ determineOtsuThreshold; });
__webpack_require__.d(__webpack_exports__, "otsuThreshold", function() { return /* binding */ otsuThreshold; });
__webpack_require__.d(__webpack_exports__, "computeBinaryImage", function() { return /* binding */ computeBinaryImage; });
__webpack_require__.d(__webpack_exports__, "cluster", function() { return /* binding */ cv_utils_cluster; });
__webpack_require__.d(__webpack_exports__, "Tracer", function() { return /* binding */ Tracer; });
__webpack_require__.d(__webpack_exports__, "DILATE", function() { return /* binding */ DILATE; });
__webpack_require__.d(__webpack_exports__, "ERODE", function() { return /* binding */ ERODE; });
__webpack_require__.d(__webpack_exports__, "dilate", function() { return /* binding */ dilate; });
__webpack_require__.d(__webpack_exports__, "erode", function() { return /* binding */ erode; });
__webpack_require__.d(__webpack_exports__, "subtract", function() { return /* binding */ subtract; });
__webpack_require__.d(__webpack_exports__, "bitwiseOr", function() { return /* binding */ bitwiseOr; });
__webpack_require__.d(__webpack_exports__, "countNonZero", function() { return /* binding */ countNonZero; });
__webpack_require__.d(__webpack_exports__, "topGeneric", function() { return /* binding */ topGeneric; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromImage", function() { return /* binding */ grayArrayFromImage; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromContext", function() { return /* binding */ grayArrayFromContext; });
__webpack_require__.d(__webpack_exports__, "grayAndHalfSampleFromCanvasData", function() { return /* binding */ grayAndHalfSampleFromCanvasData; });
__webpack_require__.d(__webpack_exports__, "computeGray", function() { return /* binding */ computeGray; });
__webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return /* binding */ loadImageArray; });
__webpack_require__.d(__webpack_exports__, "halfSample", function() { return /* binding */ halfSample; });
__webpack_require__.d(__webpack_exports__, "hsv2rgb", function() { return /* binding */ hsv2rgb; });
__webpack_require__.d(__webpack_exports__, "_computeDivisors", function() { return /* binding */ _computeDivisors; });
__webpack_require__.d(__webpack_exports__, "calculatePatchSize", function() { return /* binding */ calculatePatchSize; });
__webpack_require__.d(__webpack_exports__, "_parseCSSDimensionValues", function() { return /* binding */ _parseCSSDimensionValues; });
__webpack_require__.d(__webpack_exports__, "_dimensionsConverters", function() { return /* binding */ _dimensionsConverters; });
__webpack_require__.d(__webpack_exports__, "computeImageArea", function() { return /* binding */ computeImageArea; });

// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/gl-vec3/index.js
var gl_vec3 = __webpack_require__(83);

// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)

var vec2 = {
  clone: gl_vec2["clone"],
  dot: gl_vec2["dot"]
};
/**
 * Creates a cluster for grouping similar orientations of datapoints
 */

/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2.clone([0, 0])
    };
    var pointMap = {};

    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }

    function updateCenter() {
      var i;
      var sum = 0;

      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }

      center.rad = sum / points.length;
      center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }

    function init() {
      _add(point);

      updateCenter();
    }

    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);

          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));

        if (similarity > threshold) {
          return true;
        }

        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(8);

// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */

/* eslint-disable no-bitwise */




var cv_utils_vec2 = {
  clone: gl_vec2["clone"]
};
var vec3 = {
  clone: gl_vec3["clone"]
};
/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */

function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return cv_utils_vec2.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}
/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */

function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y; // sum up first column

  posB = width;
  sum = 0;

  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }

  posA = 0;
  posB = 1;
  sum = 0;

  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }

  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;

    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0; // sum up first row

  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }

  for (var v = 1; v < height; v++) {
    sum = 0;

    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;

  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);

  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }

  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;

  for (i = 1; i < length - 1; i++) {
    right = line[i + 1]; //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign

    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }

  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;

  function px(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }

    return sum;
  }

  function mx(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }

    return sum;
  }

  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);

    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;

      if (p12 === 0) {
        p12 = 1;
      }

      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }

    return array_helper["a" /* default */].maxIndex(vet);
  }

  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
} // local thresholding

function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);

  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  } // clear out left & right border


  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }

  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];

  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }

  function addToCluster(newPoint) {
    var found = false;

    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];

      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }

    return found;
  } // iterate over each cloud


  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);

    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }

  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;

    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;

      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }

        return false;
      } // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met


      var from = points[idx];

      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }

      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx]; // eslint-disable-next-line no-cond-assign

      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }

      return found ? toIdx : null;
    }

    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length); // trace forward

      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }

      if (centerPos > 0) {
        currentPos = centerPos; // eslint-disable-next-line no-cond-assign

        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }

      if (top.length > result.length) {
        result = top;
      }
    }

    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;

  while (length--) {
    sum += data[length];
  }

  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;

  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }

  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);

    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;

      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }

  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;

  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;

  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[i] = imageData[i * 4 + 0];
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;

  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width; // eslint-disable-next-line no-param-reassign

    canvas.height = this.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);

    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
        data = _ctx$getImageData.data;

    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };

  img.src = src;
}
/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */

function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;

  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;

  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  } // eslint-disable-next-line no-param-reassign


  rgb[0] = (r + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[1] = (g + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  var largeDivisors = [];
  var divisors = [];

  for (var i = 1; i < Math.sqrt(n) + 1; i++) {
    if (n % i === 0) {
      divisors.push(i);

      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }

  return divisors.concat(largeDivisors);
}

function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];

  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }

  return result;
}

function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);

  var divisorsY = _computeDivisors(imgSize.y);

  var wideSide = Math.max(imgSize.x, imgSize.y);

  var common = _computeIntersection(divisorsX, divisorsY);

  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;

  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];

    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }

    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }

    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }

    return null;
  }

  optimalPatchSize = findPatchSizeForDivisors(common);

  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));

    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }

  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    var value = area[key];

    var parsed = _parseCSSDimensionValues(value);

    var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign


    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(229);

/***/ }),
/* 12 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
/* harmony default export */ __webpack_exports__["a"] = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);

    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }

    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;

    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }

    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }

    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(90),
    createAssigner = __webpack_require__(145);
/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */


var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
module.exports = merge;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(228);

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(45);
/** Detect free variable `self`. */


var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;

    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;

      for (i = 0; i < 7; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;

        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }

        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }

        current.dir = (current.dir + 1) % 8;
      }

      return false;
    }

    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }

    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };

      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;

        do {
          current.dir = (current.dir + 6) % 8;

          _trace(current, color, label, edgelabel);

          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }

          ldir = current.dir;
        } while (current.cx !== sx || current.cy !== sy);

        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }

      return Fv;
    }

    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Tracer);

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(27),
    getRawTag = __webpack_require__(103),
    objectToString = __webpack_require__(104);
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gl_mat2__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);
/* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(14);
/* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85);
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(21);
/* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(86);










var _config;

var _currentImageWrapper;

var _skelImageWrapper;

var _subImageWrapper;

var _labelImageWrapper;

var _patchGrid;

var _patchLabelGrid;

var _imageToPatchGrid;

var _binaryImageWrapper;

var _patchSize;

var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};

var _inputImageWrapper;

var _skeletonizer;

function initBuffers() {
  if (_config.halfSample) {
    _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }

  _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0; // eslint-disable-next-line no-bitwise

  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, undefined, Array, true);
  var skeletonImageData = new ArrayBuffer(64 * 1024);
  _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
  if (_config.useWorker || typeof document === 'undefined') {
    return;
  }

  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';

  if (false) {}

  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d');
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}
/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */


function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale; // draw all patches which are to be taken into consideration

  overAvg = 0;

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;

    if (false) {}
  }

  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;

  if (overAvg < 0) {
    overAvg += 180;
  }

  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["copy"](gl_mat2__WEBPACK_IMPORTED_MODULE_1__["create"](), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]); // iterate over patches and rotate by angle

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](patch.box[j], patch.box[j], transMat);
    }

    if (false) {}
  } // find bounding box


  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }

      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }

      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }

      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }

  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

  if (false) {}

  scale = _config.halfSample ? 2 : 1; // reverse rotation;

  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["invert"](transMat, transMat);

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](box[j], box[j], transMat);
  }

  if (false) {}

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["scale"](box[j], box[j], scale);
  }

  return box;
}
/**
 * Creates a binary image of the current image
 */


function binarizeImage() {
  Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["otsuThreshold"])(_currentImageWrapper, _binaryImageWrapper);

  _binaryImageWrapper.zeroBorder();

  if (false) {}
}
/**
 * Iterate over the entire image
 * extract patches
 */


function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;

  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j; // seperate parts

      skeletonize(x, y); // Rasterize, find individual bars

      _skelImageWrapper.zeroBorder();

      _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_labelImageWrapper.data, 0);
      rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);

      if (false) {} // calculate moments from the skeletonized patch


      moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }

  if (false) {}

  return patchesFound;
}
/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */


function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];

  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }

  sum = _patchLabelGrid.data.length;

  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }

  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  }); // extract top areas with at least 6 patches present

  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}
/**
 *
 */


function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;

    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }

    box = boxFromPatches(patches);

    if (box) {
      boxes.push(box); // draw patch-labels if requested

      if (false) {}
    }
  }

  return boxes;
}
/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */


function similarMoments(moments) {
  var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["cluster"])(moments, 0.90);
  var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["topGeneric"])(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];

  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();

    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }

  return result;
}

function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));

  _skeletonizer.skeletonize(); // Show skeleton if requested


  if (false) {}
}
/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */


function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);

  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    } // if at least 2 moments are found which have at least minComponentWeights covered


    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0; // determine the similarity of the moments

      for (k = 0; k < matchingMoments.length; k++) {
        avg += matchingMoments[k].rad;
      } // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set


      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }

  return patchesFound;
}
/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */


function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  function notYetProcessed() {
    var i;

    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }

    return _patchLabelGrid.length;
  }

  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;

    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

      _patchLabelGrid.data[currentIdx] = label;

      for (dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections.length; dir++) {
        y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][0];
        x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

          continue;
        }

        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(gl_vec2__WEBPACK_IMPORTED_MODULE_0__["dot"](_imageToPatchGrid.data[idx].vec, currentPatch.vec));

          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  } // prepare for finding the right patches


  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchLabelGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_imageToPatchGrid.data, null);

  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  } // rasterize the patches found to determine area


  _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign


  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  } // draw patch-labels if requested


  if (false) {}

  return label;
}

/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(inputImageWrapper, config) {
    _config = config;
    _inputImageWrapper = inputImageWrapper;
    initBuffers();
    initCanvas();
  },
  locate: function locate() {
    if (_config.halfSample) {
      Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["halfSample"])(_inputImageWrapper, _currentImageWrapper);
    }

    binarizeImage();
    var patchesFound = findPatches(); // return unless 5% or more patches are found

    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    } // rasterrize area by comparing angular similarity;


    var maxLabel = rasterizeAngularSimilarity(patchesFound);

    if (maxLabel < 1) {
      return null;
    } // search for area with the most patches (biggest connected area)


    var topLabels = findBiggestConnectedAreas(maxLabel);

    if (topLabels.length === 0) {
      return null;
    }

    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area; // calculate width and height based on area

    if (inputStream.getConfig().area) {
      area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["computeImageArea"])(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }

    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(config.patchSize, size);

    if (false) {}

    inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x));
    inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y));

    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }

    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(92),
    listCacheDelete = __webpack_require__(93),
    listCacheGet = __webpack_require__(94),
    listCacheHas = __webpack_require__(95),
    listCacheSet = __webpack_require__(96);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(26);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 26 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Built-in value references. */


var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(36);
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(117);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(132),
    isObjectLike = __webpack_require__(18);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(13),
    isKey = __webpack_require__(233),
    stringToPath = __webpack_require__(234),
    toString = __webpack_require__(237);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(153);

var iterableToArrayLimit = __webpack_require__(154);

var unsupportedIterableToArray = __webpack_require__(60);

var nonIterableRest = __webpack_require__(155);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(225);

var iterableToArray = __webpack_require__(226);

var unsupportedIterableToArray = __webpack_require__(60);

var nonIterableSpread = __webpack_require__(227);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  determinant: __webpack_require__(249),
  transpose: __webpack_require__(250),
  multiply: __webpack_require__(251),
  identity: __webpack_require__(252),
  adjoint: __webpack_require__(253),
  rotate: __webpack_require__(254),
  invert: __webpack_require__(255),
  create: __webpack_require__(256),
  scale: __webpack_require__(257),
  copy: __webpack_require__(258),
  frob: __webpack_require__(259),
  ldu: __webpack_require__(260)
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(102),
    getValue = __webpack_require__(108);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    isObject = __webpack_require__(12);
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(49);
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(37),
    isLength = __webpack_require__(41);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(42);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(36),
    root = __webpack_require__(17);
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)))

/***/ }),
/* 46 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(109),
    mapCacheDelete = __webpack_require__(116),
    mapCacheGet = __webpack_require__(118),
    mapCacheHas = __webpack_require__(119),
    mapCacheSet = __webpack_require__(120);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(38),
    eq = __webpack_require__(26);
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(36);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(131);
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),
/* 51 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(17),
    stubFalse = __webpack_require__(134);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(39)(module)))

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(136),
    baseUnary = __webpack_require__(137),
    nodeUtil = __webpack_require__(138);
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),
/* 54 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(38),
    eq = __webpack_require__(26);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(141),
    baseKeysIn = __webpack_require__(143),
    isArrayLike = __webpack_require__(40);
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(147);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(148),
    shortOut = __webpack_require__(150);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(61);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),
/* 61 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new Float32Array(2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new Float32Array(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new Float32Array(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }

  return out;
}

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(71),
  create: __webpack_require__(72),
  clone: __webpack_require__(191),
  angle: __webpack_require__(192),
  fromValues: __webpack_require__(73),
  copy: __webpack_require__(193),
  set: __webpack_require__(194),
  equals: __webpack_require__(195),
  exactEquals: __webpack_require__(196),
  add: __webpack_require__(197),
  subtract: __webpack_require__(76),
  sub: __webpack_require__(198),
  multiply: __webpack_require__(77),
  mul: __webpack_require__(199),
  divide: __webpack_require__(78),
  div: __webpack_require__(200),
  min: __webpack_require__(201),
  max: __webpack_require__(202),
  floor: __webpack_require__(203),
  ceil: __webpack_require__(204),
  round: __webpack_require__(205),
  scale: __webpack_require__(206),
  scaleAndAdd: __webpack_require__(207),
  distance: __webpack_require__(79),
  dist: __webpack_require__(208),
  squaredDistance: __webpack_require__(80),
  sqrDist: __webpack_require__(209),
  length: __webpack_require__(81),
  len: __webpack_require__(210),
  squaredLength: __webpack_require__(82),
  sqrLen: __webpack_require__(211),
  negate: __webpack_require__(212),
  inverse: __webpack_require__(213),
  normalize: __webpack_require__(74),
  dot: __webpack_require__(75),
  cross: __webpack_require__(214),
  lerp: __webpack_require__(215),
  random: __webpack_require__(216),
  transformMat4: __webpack_require__(217),
  transformMat3: __webpack_require__(218),
  transformQuat: __webpack_require__(219),
  rotateX: __webpack_require__(220),
  rotateY: __webpack_require__(221),
  rotateZ: __webpack_require__(222),
  forEach: __webpack_require__(223)
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(230),
    flatRest = __webpack_require__(244);
/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */


var pick = flatRest(function (object, paths) {
  return object == null ? {} : basePick(object, paths);
});
module.exports = pick;

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);

/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */

var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;

        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }

        colorMap[0] = imageData[0];
        cc = null;

        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];

          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;

            if (labelData[pos] === 0) {
              color = imageData[pos];

              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);

                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;

                    if (cc !== null) {
                      cc.prevpeer = p;
                    }

                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);

                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;

                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }

                    p.index = depthlabel;
                    sc = cc;

                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }

                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;

                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }

                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;

              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }

        sc = cc;

        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }

        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;

          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }

          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;

              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }

            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;

              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;

              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }

            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);

            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);

            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-param-reassign */

/* eslint-disable no-bitwise */

/* eslint-disable eqeqeq */

/* @preserve ASM BEGIN */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  function erode(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function countNonZero(imagePtr) {
    imagePtr |= 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }

    return sum | 0;
  }

  function init(imagePtr, value) {
    imagePtr |= 0;
    value |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  function dilate(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr |= 0;
    dstImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  function zeroBorder(imagePtr) {
    imagePtr |= 0;
    var x = 0;
    var y = 0;

    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }

    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  function skeletonize() {
    var subImagePtr = 0;
    var erodedImagePtr = 0;
    var tempImagePtr = 0;
    var skelImagePtr = 0;
    var sum = 0;
    var done = 0;
    erodedImagePtr = imul(size, size) | 0;
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // init skel-image

    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);

    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }

  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */


/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
/* eslint-enable eqeqeq */

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = require("get-pixels");

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

// NOTE FOR ANYONE IN HERE IN THE FUTURE: This module is used when the module is built for use in Node.
// Webpack.config.js explicitly REPLACES this module with the file called frame_grabber_browser when it is packing the Browser distribution.
var CVUtils = __webpack_require__(10);

var Ndarray = __webpack_require__(261);

var Interp2D = __webpack_require__(262).d2;

var FrameGrabber = {};

FrameGrabber.create = function (inputStream, canvas) {
  var _that = {};

  var _videoSize = CVUtils.imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = CVUtils.imageRef(inputStream.getWidth(), inputStream.getHeight());

  var _topRight = inputStream.getTopRight();

  var _data = new Uint8Array(_size.x * _size.y);

  var _grayData = new Uint8Array(_videoSize.x * _videoSize.y);

  var _canvasData = new Uint8Array(_canvasSize.x * _canvasSize.y);
  /* eslint-disable new-cap */


  var _grayImageArray = Ndarray(_grayData, [_videoSize.y, _videoSize.x]).transpose(1, 0);

  var _canvasImageArray = Ndarray(_canvasData, [_canvasSize.y, _canvasSize.x]).transpose(1, 0);

  var _targetImageArray = _canvasImageArray.hi(_topRight.x + _size.x, _topRight.y + _size.y).lo(_topRight.x, _topRight.y);

  var _stepSizeX = _videoSize.x / _canvasSize.x;

  var _stepSizeY = _videoSize.y / _canvasSize.y;

  if (false) {}
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var frame = inputStream.getFrame();

    if (frame) {
      this.scaleAndCrop(frame);
      return true;
    }

    return false;
  }; // eslint-disable-next-line


  _that.scaleAndCrop = function (frame) {
    // 1. compute full-sized gray image
    CVUtils.computeGray(frame.data, _grayData); // 2. interpolate

    for (var y = 0; y < _canvasSize.y; y++) {
      for (var x = 0; x < _canvasSize.x; x++) {
        // eslint-disable-next-line no-bitwise
        _canvasImageArray.set(x, y, Interp2D(_grayImageArray, x * _stepSizeX, y * _stepSizeY) | 0);
      }
    } // targetImageArray must be equal to targetSize


    if (_targetImageArray.shape[0] !== _size.x || _targetImageArray.shape[1] !== _size.y) {
      throw new Error('Shapes do not match!');
    } // 3. crop


    for (var _y = 0; _y < _size.y; _y++) {
      for (var _x = 0; _x < _size.x; _x++) {
        _data[_y * _size.x + _x] = _targetImageArray.get(_x, _y);
      }
    }
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

module.exports = FrameGrabber;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(263);


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(91),
    assignMergeValue = __webpack_require__(48),
    baseFor = __webpack_require__(121),
    baseMergeDeep = __webpack_require__(123),
    isObject = __webpack_require__(12),
    keysIn = __webpack_require__(56),
    safeGet = __webpack_require__(54);
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(24),
    stackClear = __webpack_require__(97),
    stackDelete = __webpack_require__(98),
    stackGet = __webpack_require__(99),
    stackHas = __webpack_require__(100),
    stackSet = __webpack_require__(101);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),
/* 92 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(25);
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(25);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(25);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(25);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(24);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 98 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 99 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 100 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(24),
    Map = __webpack_require__(44),
    MapCache = __webpack_require__(47);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(37),
    isMasked = __webpack_require__(105),
    isObject = __webpack_require__(12),
    toSource = __webpack_require__(107);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(27);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),
/* 104 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(106);
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),
/* 107 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(110),
    ListCache = __webpack_require__(24),
    Map = __webpack_require__(44);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(111),
    hashDelete = __webpack_require__(112),
    hashGet = __webpack_require__(113),
    hashHas = __webpack_require__(114),
    hashSet = __webpack_require__(115);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(28);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 112 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(28);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(28);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(28);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(29);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 117 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(29);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(29);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(29);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(122);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),
/* 122 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(48),
    cloneBuffer = __webpack_require__(124),
    cloneTypedArray = __webpack_require__(125),
    copyArray = __webpack_require__(128),
    initCloneObject = __webpack_require__(129),
    isArguments = __webpack_require__(30),
    isArray = __webpack_require__(13),
    isArrayLikeObject = __webpack_require__(133),
    isBuffer = __webpack_require__(52),
    isFunction = __webpack_require__(37),
    isObject = __webpack_require__(12),
    isPlainObject = __webpack_require__(135),
    isTypedArray = __webpack_require__(53),
    safeGet = __webpack_require__(54),
    toPlainObject = __webpack_require__(139);
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(17);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(39)(module)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(126);
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(127);
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),
/* 128 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(130),
    getPrototype = __webpack_require__(50),
    isPrototype = __webpack_require__(51);
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(12);
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),
/* 131 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(40),
    isObjectLike = __webpack_require__(18);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    getPrototype = __webpack_require__(50),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(22),
    isLength = __webpack_require__(41),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(45);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(39)(module)))

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(140),
    keysIn = __webpack_require__(56);
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */


function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(55),
    baseAssignValue = __webpack_require__(38);
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(142),
    isArguments = __webpack_require__(30),
    isArray = __webpack_require__(13),
    isBuffer = __webpack_require__(52),
    isIndex = __webpack_require__(31),
    isTypedArray = __webpack_require__(53);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 142 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(12),
    isPrototype = __webpack_require__(51),
    nativeKeysIn = __webpack_require__(144);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(146),
    isIterateeCall = __webpack_require__(151);
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */


function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

module.exports = createAssigner;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(57),
    overRest = __webpack_require__(58),
    setToString = __webpack_require__(59);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 147 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(149),
    defineProperty = __webpack_require__(49),
    identity = __webpack_require__(57);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),
/* 149 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(26),
    isArrayLike = __webpack_require__(40),
    isIndex = __webpack_require__(31),
    isObject = __webpack_require__(12);
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 152 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */
if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (
      /* function FrameRequestCallback */
      callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}

if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value

    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */

}

if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2
    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];

      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }

    return to;
  };
}

/***/ }),
/* 153 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 154 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 155 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),
/* 156 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new Float32Array(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new Float32Array(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 158 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(62);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var b0 = b[0];
  var b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/***/ }),
/* 161 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(64);

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(65);

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(66);

/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a vec2 by an angle
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to rotate
 * @param {Number} angle the angle of rotation (in radians)
 * @returns {vec2} out
 */

function rotate(out, a, angle) {
  var c = Math.cos(angle),
      s = Math.sin(angle);
  var x = a[0],
      y = a[1];
  out[0] = x * c - y * s;
  out[1] = x * s + y * c;
  return out;
}

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/***/ }),
/* 172 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/***/ }),
/* 173 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/***/ }),
/* 174 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(67);

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(68);

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(69);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(70);

/***/ }),
/* 179 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/***/ }),
/* 180 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }

  return out;
}

/***/ }),
/* 181 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/***/ }),
/* 182 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/***/ }),
/* 183 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/***/ }),
/* 185 */
/***/ (function(module, exports) {

module.exports = transformMat2;
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports = transformMat2d;
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/***/ }),
/* 187 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/***/ }),
/* 188 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(63)();
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 2;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
  }

  return a;
}

/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = limit;
/**
 * Limit the magnitude of this vector to the value used for the `max`
 * parameter.
 *
 * @param  {vec2} the vector to limit
 * @param  {Number} max the maximum magnitude for the vector
 * @returns {vec2} out
 */

function limit(out, a, max) {
  var mSq = a[0] * a[0] + a[1] * a[1];

  if (mSq > max * max) {
    var n = Math.sqrt(mSq);
    out[0] = a[0] / n * max;
    out[1] = a[1] / n * max;
  } else {
    out[0] = a[0];
    out[1] = a[1];
  }

  return out;
}

/***/ }),
/* 191 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new Float32Array(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = angle;

var fromValues = __webpack_require__(73);

var normalize = __webpack_require__(74);

var dot = __webpack_require__(75);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else {
    return Math.acos(cosine);
  }
}

/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 194 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(71);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var b0 = b[0];
  var b1 = b[1];
  var b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/***/ }),
/* 196 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/***/ }),
/* 197 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(76);

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(77);

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(78);

/***/ }),
/* 201 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/***/ }),
/* 202 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/***/ }),
/* 203 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/***/ }),
/* 204 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/***/ }),
/* 205 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/***/ }),
/* 206 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/***/ }),
/* 207 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(79);

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(80);

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(81);

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(82);

/***/ }),
/* 212 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/***/ }),
/* 213 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/***/ }),
/* 214 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/***/ }),
/* 215 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/***/ }),
/* 216 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  var z = Math.random() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/***/ }),
/* 217 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/***/ }),
/* 218 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = transformQuat;
/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
  var x = a[0],
      y = a[1],
      z = a[2],
      qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      // calculate quat * vec
  ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/***/ }),
/* 220 */
/***/ (function(module, exports) {

module.exports = rotateX;
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var by = b[1];
  var bz = b[2]; // Translate point to the origin

  var py = a[1] - by;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = a[0];
  out[1] = by + py * cc - pz * sc;
  out[2] = bz + py * sc + pz * cc;
  return out;
}

/***/ }),
/* 221 */
/***/ (function(module, exports) {

module.exports = rotateY;
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var bx = b[0];
  var bz = b[2]; // translate point to the origin

  var px = a[0] - bx;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + pz * sc + px * cc;
  out[1] = a[1];
  out[2] = bz + pz * cc - px * sc;
  return out;
}

/***/ }),
/* 222 */
/***/ (function(module, exports) {

module.exports = rotateZ;
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var bx = b[0];
  var by = b[1]; //Translate point to the origin

  var px = a[0] - bx;
  var py = a[1] - by;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + px * cc - py * sc;
  out[1] = by + px * sc + py * cc;
  out[2] = a[2];
  return out;
}

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(72)();
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 3;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    vec[2] = a[i + 2];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
    a[i + 2] = vec[2];
  }

  return a;
}

/***/ }),
/* 224 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(61);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 226 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 227 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(2);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(231),
    hasIn = __webpack_require__(241);
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */


function basePick(object, paths) {
  return basePickBy(object, paths, function (value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(232),
    baseSet = __webpack_require__(240),
    castPath = __webpack_require__(32);
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */


function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }

  return result;
}

module.exports = basePickBy;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(32),
    toKey = __webpack_require__(43);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(13),
    isSymbol = __webpack_require__(42);
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(235);
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(236);
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(47);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(238);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(27),
    arrayMap = __webpack_require__(239),
    isArray = __webpack_require__(13),
    isSymbol = __webpack_require__(42);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 239 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(55),
    castPath = __webpack_require__(32),
    isIndex = __webpack_require__(31),
    isObject = __webpack_require__(12),
    toKey = __webpack_require__(43);
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */


function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

module.exports = baseSet;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(242),
    hasPath = __webpack_require__(243);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 242 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(32),
    isArguments = __webpack_require__(30),
    isArray = __webpack_require__(13),
    isIndex = __webpack_require__(31),
    isLength = __webpack_require__(41),
    toKey = __webpack_require__(43);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(245),
    overRest = __webpack_require__(58),
    setToString = __webpack_require__(59);
/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */


function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(246);
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */


function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(247),
    isFlattenable = __webpack_require__(248);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 247 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(27),
    isArguments = __webpack_require__(30),
    isArray = __webpack_require__(13);
/** Built-in value references. */


var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 249 */
/***/ (function(module, exports) {

module.exports = determinant;
/**
 * Calculates the determinant of a mat2
 *
 * @alias mat2.determinant
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/***/ }),
/* 250 */
/***/ (function(module, exports) {

module.exports = transpose;
/**
 * Transpose the values of a mat2
 *
 * @alias mat2.transpose
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/***/ }),
/* 251 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two mat2's
 *
 * @alias mat2.multiply
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/***/ }),
/* 252 */
/***/ (function(module, exports) {

module.exports = identity;
/**
 * Set a mat2 to the identity matrix
 *
 * @alias mat2.identity
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 253 */
/***/ (function(module, exports) {

module.exports = adjoint;
/**
 * Calculates the adjugate of a mat2
 *
 * @alias mat2.adjoint
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/***/ }),
/* 254 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a mat2 by the given angle
 *
 * @alias mat2.rotate
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/***/ }),
/* 255 */
/***/ (function(module, exports) {

module.exports = invert;
/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var a3 = a[3];
  var det = a0 * a3 - a2 * a1;
  if (!det) return null;
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/***/ }),
/* 256 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new Float32Array(4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 257 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @alias mat2.scale
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/***/ }),
/* 258 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/***/ }),
/* 259 */
/***/ (function(module, exports) {

module.exports = frob;
/**
 * Returns Frobenius norm of a mat2
 *
 * @alias mat2.frob
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/***/ }),
/* 260 */
/***/ (function(module, exports) {

module.exports = ldu;
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 *
 * @alias mat2.ldu
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function ldu(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/***/ }),
/* 261 */
/***/ (function(module, exports) {

module.exports = require("ndarray");

/***/ }),
/* 262 */
/***/ (function(module, exports) {

module.exports = require("ndarray-linear-interpolate");

/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "BarcodeReader", function() { return /* reexport */ barcode_reader; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(19);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./node_modules/lodash/merge.js
var merge = __webpack_require__(15);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(152);

// EXTERNAL MODULE: ./src/common/image_wrapper.ts
var image_wrapper = __webpack_require__(9);

// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */

Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */

  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;

  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }

  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }

  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }

  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;

  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }

    error -= deltaY;

    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }

  return {
    line: line,
    min: min,
    max: max
  };
};
/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */


Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j; // 1. find extrema

  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });

  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];

    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }

    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }

  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });

  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  } // iterate over extrema and convert to binary based on avg between minmax


  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }

    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }

  return {
    line: line,
    threshold: threshold
  };
};
/**
 * Used for development only
 */


Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d'); // eslint-disable-next-line no-param-reassign

    canvas.width = line.length; // eslint-disable-next-line no-param-reassign

    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';

    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }

    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i; // eslint-disable-next-line no-param-reassign

    canvas.width = line.length;
    ctx.fillColor = 'black';

    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// EXTERNAL MODULE: ./src/common/image_debug.ts
var image_debug = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(3);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(4);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(1);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(6);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(5);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(2);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(8);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts




var BarcodeDirection;

(function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
})(BarcodeDirection || (BarcodeDirection = {}));

;
;
;
;
;
;
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);

    defineProperty_default()(this, "_row", []);

    defineProperty_default()(this, "config", {});

    defineProperty_default()(this, "supplements", []);

    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

    defineProperty_default()(this, "FORMAT", 'unknown');

    defineProperty_default()(this, "CONFIG_KEYS", {});

    this._row = [];
    this.config = config || {};

    if (supplements) {
      this.supplements = supplements;
    }

    return this;
  }

  createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code, maxSingleError) {
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }

      if (sum < modulo) {
        return Number.MAX_VALUE;
      }

      barWidth = sum / modulo;
      maxSingleError *= barWidth;

      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;

        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }

        error += singleError;
      }

      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;

      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

        if (tmp > 1) {
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

      var result = this._decode(); // console.warn('* first result=', result);


      if (result === null) {
        this._row.reverse();

        result = this._decode(); // console.warn('* reversed result=', result);

        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }

      if (result) {
        result.format = this.FORMAT;
      } // console.warn('* returning', result);


      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      var i;
      start = start < 0 ? 0 : start;

      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;

      for (var i = offset; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper["a" /* default */].init(counters, 0);

      for (var i = start; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;

          if (counterPos === numCounters) {
            break;
          } else {
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }

      return counters;
    }
  }], [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }
  }]);

  return BarcodeReader;
}();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code128Reader, _BarcodeReader);

  var _super = _createSuper(Code128Reader);

  function Code128Reader() {
    var _this;

    classCallCheck_default()(this, Code128Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_SHIFT", 98);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_C", 99);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_B", 100);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_A", 101);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_A", 103);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_B", 104);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_C", 105);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_CODE", 106);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.64);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_128');

    defineProperty_default()(assertThisInitialized_default()(_this), "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });

    return _this;
  }

  createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }

            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            bestMatch.end = i;

            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }

            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }

            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);

      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    value: // TODO: _findStart and decodeCode share similar code, can we re-use some?
    function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];

      var offset = this._nextSet(this._row);

      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var _this2 = this;

      var startInfo = this._findStart();

      if (startInfo === null) {
        return null;
      } // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;


      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;

      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;

          case _this2.START_CODE_B:
            return _this2.CODE_B;

          case _this2.START_CODE_C:
            return _this2.CODE_C;

          default:
            return null;
        }
      }(code.code);

      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);

        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }

          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }

          decodedCodes.push(code);

          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;
          }
        } else {
          done = true;
        }

        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }

      if (code === null) {
        return null;
      }

      code.end = this._nextUnset(this._row, code.end);

      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }

      checksum -= multiplier * rawResult[rawResult.length - 1];

      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }

      if (!result.length) {
        return null;
      } // remove last code from result (checksum)


      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }

      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
          trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
          sumNormalized = 0,
          sumExpected = 0;

      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }

      return sumExpected / sumNormalized;
    }
  }]);

  return Code128Reader;
}(barcode_reader);

/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// CONCATENATED MODULE: ./src/reader/ean_reader.ts








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ean_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


 // const CODE_L_START = 0;

var CODE_G_START = 10;

var START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

var AVG_CODE_ERROR = 0.48;

var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(EANReader, _BarcodeReader);

  var _super = ean_reader_createSuper(EANReader);

  // TODO: does this need to be in the class?
  function EANReader(config, supplements) {
    var _this;

    classCallCheck_default()(this, EANReader);

    _this = _super.call(this, merge_default()({
      supplements: []
    }, config), supplements);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_13');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.70);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1, 1, 1]);

    return _this;
  }

  createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

      var counterPos = 0;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);


            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      if (found) {// console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {// console.warn('* return null');
        }

      return found ? bestMatch : null;
    } // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?

  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = CODE_PATTERN.length; // console.warn('* decodeCode after length');
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, CODE_PATTERN[code]);

              bestMatch.end = i;

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            } // console.warn('* return bestMatch', JSON.stringify(bestMatch));


            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);

      var startInfo = null;

      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true); // console.warn('* startInfo=', JSON.stringify(startInfo));

        if (!startInfo) {
          return null;
        }

        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      } // console.warn('* returning null');


      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

        if (!outCode) {
          // console.warn('* return null');
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);


      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }

      result.unshift(firstDigit);

      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false); // console.warn('* findPattern=', JSON.stringify(middlePattern));


      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }

      decodedCodes.push(middlePattern);

      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }

        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      } // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);


      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);

      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;

      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }

      sum *= 3;

      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      } // console.warn('* end checksum', sum % 10 === 0);


      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);

      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);

      if (startInfo === null) {
        return null;
      } // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');


      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i]._decode(this._row, startInfo.end); // console.warn('* decode result=', result);


          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      } // console.warn('* end decodeExtensions');


      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);

      if (!code) {
        return null;
      }

      code = this._findEnd(code.end, false);

      if (!code) {
        return null;
      }

      decodedCodes.push(code); // Checksum

      if (!this._checksum(result)) {
        return null;
      } // console.warn('* this.supplements=', this.supplements);


      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);


        if (!supplement) {
          return null;
        }

        if (!supplement.decodedCodes) {
          return null;
        }

        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };

        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }

        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }

      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);

  return EANReader;
}(barcode_reader);

/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(34);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts









function code_39_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;

var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code39Reader, _BarcodeReader);

  var _super = code_39_reader_createSuper(Code39Reader);

  function Code39Reader() {
    var _this;

    classCallCheck_default()(this, Code39Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39');

    return _this;
  }

  createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }

            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;

      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;

        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }

        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;

              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }

          return pattern;
        }
      }

      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;

      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }

      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper["a" /* default */].sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }

      return false;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = this._nextSet(this._row, start.end);

      var decodedChar;
      var lastStart;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code39Reader;
}(barcode_reader);

/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(16);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts









function code_39_vin_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_vin_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};

var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code39VINReader, _Code39Reader);

  var _super = code_39_vin_reader_createSuper(Code39VINReader);

  function Code39VINReader() {
    var _this;

    classCallCheck_default()(this, Code39VINReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39_vin');

    return _this;
  }

  createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    value: // TODO (this was todo in original repo, no text was there. sorry.)
    function _checkChecksum(code) {
      return !!code;
    } // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java

  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(patterns.IOQ, '');

      if (!code.match(patterns.AZ09)) {
        if (false) {}

        return null;
      }

      if (!this._checkChecksum(code)) {
        return null;
      }

      result.code = code;
      return result;
    }
  }]);

  return Code39VINReader;
}(code_39_reader);

/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts








function codabar_reader_createSuper(Derived) { var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function codabar_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

 // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

var codabar_reader_ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var codabar_reader_CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;

var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(NewCodabarReader, _BarcodeReader);

  var _super = codabar_reader_createSuper(NewCodabarReader);

  function NewCodabarReader() {
    var _this;

    classCallCheck_default()(this, NewCodabarReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "_counters", []);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'codabar');

    return _this;
  }

  createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;

      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];

        if (counter > max) {
          max = counter;
        }

        if (counter < min) {
          min = counter;
        }
      }

      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;

      if (end > this._counters.length) {
        return -1;
      }

      var barThreshold = this._computeAlternatingThreshold(offset, end);

      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }

        bitmask >>= 1;
      }

      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;

      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);

      var end = start;

      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);

        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }

      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < codabar_reader_CHARACTER_ENCODINGS.length; i++) {
        if (codabar_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(codabar_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;

      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);

      for (var i = 0; i < codabar_reader_ALPHABET.length; i++) {
        if (codabar_reader_ALPHABET[i] === charCode) {
          return codabar_reader_CHARACTER_ENCODINGS[i];
        }
      }

      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }

        pos += 8;
      }

      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);

      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];

          if (size < cat.min || size > cat.max) {
            return false;
          }

          pattern >>= 1;
        }

        pos += 8;
      }

      return true;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = start.startCounter;
      var result = [];
      var pattern;

      do {
        pattern = this._toPattern(nextStart);

        if (pattern < 0) {
          return null;
        }

        var decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        nextStart += 8;

        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length); // verify end


      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      } // verify end white space


      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }

      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }

      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;

      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);

      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway

      };
    }
  }]);

  return NewCodabarReader;
}(barcode_reader);

/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts








function upc_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCReader, _EANReader);

  var _super = upc_reader_createSuper(UPCReader);

  function UPCReader() {
    var _this;

    classCallCheck_default()(this, UPCReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_a');

    return _this;
  }

  createClass_default()(UPCReader, [{
    key: "_decode",
    value: function _decode(row, start) {
      var result = ean_reader.prototype._decode.call(this);

      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }

      return null;
    }
  }]);

  return UPCReader;
}(ean_reader);

/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts








function ean_8_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_8_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN8Reader, _EANReader);

  var _super = ean_8_reader_createSuper(EAN8Reader);

  function EAN8Reader() {
    var _this;

    classCallCheck_default()(this, EAN8Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_8');

    return _this;
  }

  createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;

      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        result.push(code.code);
        decodedCodes.push(code);
      }

      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

      if (code === null) {
        return null;
      }

      decodedCodes.push(code);

      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code);
      }

      return code;
    }
  }]);

  return EAN8Reader;
}(ean_reader);

/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts








function ean_2_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_2_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN2Reader, _EANReader);

  var _super = ean_2_reader_createSuper(EAN2Reader);

  function EAN2Reader() {
    var _this;

    classCallCheck_default()(this, EAN2Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_2');

    return _this;
  }

  createClass_default()(EAN2Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;

      if (offset === undefined) {
        return null;
      }

      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }

        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN2Reader;
}(ean_reader);

;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts








function ean_5_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }

  return null;
}

function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;

  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }

  sum *= 3;

  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }

  sum *= 3;
  return sum % 10;
}

var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN5Reader, _EANReader);

  var _super = ean_5_reader_createSuper(EAN5Reader);

  function EAN5Reader() {
    var _this;

    classCallCheck_default()(this, EAN5Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_5');

    return _this;
  }

  createClass_default()(EAN5Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (start === undefined) {
        return null;
      }

      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];

      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }

        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 5) {
        return null;
      }

      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN5Reader;
}(ean_reader);

;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts









function upc_e_reader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function upc_e_reader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upc_e_reader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upc_e_reader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function upc_e_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_e_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCEReader, _EANReader);

  var _super = upc_e_reader_createSuper(UPCEReader);

  function UPCEReader() {
    var _this;

    classCallCheck_default()(this, UPCEReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_e');

    return _this;
  }

  createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);

        if (!outCode) {
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }

      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];

      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }

      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_checksum", this).call(this, this._convertToUPCA(result));
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_findEnd", this).call(this, offset, true);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }]);

  return UPCEReader;
}(ean_reader);

/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts








function i2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function i2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that


var N = 1;
var W = 3;

var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(I2of5Reader, _BarcodeReader);

  var _super = i2of5_reader_createSuper(I2of5Reader);

  function I2of5Reader(opts) {
    var _this;

    classCallCheck_default()(this, I2of5Reader);

    _this = _super.call(this, merge_default()({
      normalizeBarSpaceWidth: false
    }, opts));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.38);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_PATTERN", [N, N, N, N]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [N, N, W]);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "MAX_CORRECTION_FACTOR", 5);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'i2of5');

    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }

    _this.config = opts;
    return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));
  }

  createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;

        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }

        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;

        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }

      return barcode_reader.prototype._matchPattern.call(this, counter, code);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            var error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;

      var offset = this._nextSet(this._row);

      var startInfo = null;
      var narrowBarWidth = 1;

      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();

      var endInfo = this._findPattern(this.STOP_PATTERN);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];

      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);

        if (!code) {
          return null;
        }

        codes.push(code);
      }

      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }

        codes = this._decodePair(counterPair);

        if (!codes) {
          return null;
        }

        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }

      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      decodedCodes.push(startInfo);

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return I2of5Reader;
}(barcode_reader);

/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts








function _2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = _2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var _2of5_reader_N = 1;
var _2of5_reader_W = 3;
var _2of5_reader_START_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N];
var STOP_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W];
var _2of5_reader_CODE_PATTERN = [[_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N]];
var START_PATTERN_LENGTH = _2of5_reader_START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);

var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(TwoOfFiveReader, _BarcodeReader);

  var _super = _2of5_reader_createSuper(TwoOfFiveReader);

  function TwoOfFiveReader() {
    var _this;

    classCallCheck_default()(this, TwoOfFiveReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", '2of5');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    return _this;
  }

  createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }

      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;

            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }

            error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;

      var offset = this._nextSet(this._row);

      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;

      while (!startInfo) {
        startInfo = this._findPattern(_2of5_reader_START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();

      var offset = this._nextSet(this._row);

      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < _2of5_reader_CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, _2of5_reader_CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }

        code = this._decodeCode(counter);

        if (!code) {
          return null;
        }

        result.push("".concat(code.code));
        decodedCodes.push(code);
      }

      return code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length < 5) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return TwoOfFiveReader;
}(barcode_reader);

/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts









function code_93_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_93_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;

var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code93Reader, _BarcodeReader);

  var _super = code_93_reader_createSuper(Code93Reader);

  function Code93Reader() {
    var _this;

    classCallCheck_default()(this, Code93Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_93');

    return _this;
  }

  createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);

        if (normalized < 1 || normalized > 4) {
          return -1;
        }

        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }

      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }

      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];

      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];

        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }

          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;

          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }

              break;

            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }

              break;

            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }

              break;

            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }

              break;

            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }

          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }

      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      start = this._findStart();

      if (!start) {
        return null;
      }

      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];

      var nextStart = this._nextSet(this._row, start.end);

      var lastStart;
      var decodedChar;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }

      if (!this._verifyChecksums(result)) {
        return null;
      }

      result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code93Reader;
}(barcode_reader);

/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts









function code_32_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_32_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var code_32_reader_patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';

var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code32Reader, _Code39Reader);

  var _super = code_32_reader_createSuper(Code32Reader);

  function Code32Reader() {
    var _this;

    classCallCheck_default()(this, Code32Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_32_reader');

    return _this;
  }

  createClass_default()(Code32Reader, [{
    key: "_decodeCode32",
    value: function _decodeCode32(code) {
      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
        return null;
      }

      var res = 0;

      for (var i = 0; i < code.length; i++) {
        res = res * 32 + code32set.indexOf(code[i]);
      }

      var code32 = '' + res;

      if (code32.length < 9) {
        code32 = ('000000000' + code32).slice(-9);
      }

      return 'A' + code32;
    } // TODO (this was todo in original repo, no text was there. sorry.)

  }, {
    key: "_checkChecksum",
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(code_32_reader_patterns.AEIO, '');

      if (!this._checkChecksum(code)) {
        return null;
      }

      var code32 = this._decodeCode32(code);

      if (!code32) {
        return null;
      }

      result.code = code32;
      return result;
    }
  }]);

  return Code32Reader;
}(code_39_reader);

/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader
};
/* harmony default export */ var barcode_decoder = ({
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();

    function initCanvas() {
      if (false) { var $debug; }
    }

    function initReaders() {
      config.readers.forEach(function (readerConfig) {
        var reader;
        var configuration = {};
        var supplements = [];

        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }

        if (false) {}

        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }

        try {
          var readerObj = new READERS[reader](configuration, supplements);

          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });

      if (false) {}
    }

    function initConfig() {
      if (false) { var vis, i; }
    }
    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */


    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */

        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      } // check if inside image


      extendLine(ext);

      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }

      return line;
    }

    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);

      if (false) {}

      bresenham.toBinaryLine(barcodeLine);

      if (false) {}

      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
      }

      if (result === null) {
        return null;
      }

      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }
    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */


    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);

      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */

        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }

      return result;
    }

    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    function _decodeFromImage(imageWrapper) {
      var result = null;

      for (var i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodeImage ? _barcodeReaders[i].decodeImage(imageWrapper) : null;
      }

      return result;
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */


    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;

      if (false) {}

      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));

      if (line === null) {
        return null;
      }

      result = tryDecode(line);

      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }

      if (result === null) {
        return null;
      }

      if (false) {}

      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }

    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;

        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;

          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }

        if (multiple) {
          return {
            barcodes: barcodes
          };
        }
      },
      decodeFromImage: function decodeFromImage(inputImageWrapper) {
        var result = _decodeFromImage(inputImageWrapper);

        return result;
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }

        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};

  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }

    return events[eventName];
  }

  function clearEvents() {
    events = {};
  }

  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }

  function _subscribe(event, callback, async) {
    var subscription;

    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;

      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }

    getEvent(event).subscribers.push(subscription);
  }

  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers; // Publish one-time subscriptions

      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      }); // remove them from the subscriber

      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      }); // publish the rest

      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);

        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(11);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(20);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__(84);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// CONCATENATED MODULE: ./src/common/mediaDevices.ts
var ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    var error = new Error("enumerateDevices is not defined. ".concat(ERROR_DESC));
    error.code = -1;
    return Promise.reject(error);
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    var error = new Error("getUserMedia is not defined. ".concat(ERROR_DESC));
    error.code = -1;
    return Promise.reject(error);
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts




var streamRef;

function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;

    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (false) {}

          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Error('Unable to play video stream. Is webcam working?'));
      }

      attempts--;
    }

    checkVideo();
  });
}
/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */


function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}

function _initCamera() {
  _initCamera = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getUserMedia(constraints);

          case 2:
            stream = _context2.sent;
            streamRef = stream;

            if (!video) {
              _context2.next = 11;
              break;
            }

            video.setAttribute('autoplay', 'true');
            video.setAttribute('muted', 'true');
            video.setAttribute('playsinline', 'true'); // not listed on MDN...
            // eslint-disable-next-line no-param-reassign

            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
              video.play();
            });
            return _context2.abrupt("return", waitForVideo(video));

          case 11:
            return _context2.abrupt("return", Promise.resolve());

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _initCamera.apply(this, arguments);
}

function deprecatedConstraints(videoConstraints) {
  var normalized = pick_default()(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);

  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }

  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }

  return normalized;
} // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.


function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);

  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }

  return Promise.resolve({
    audio: false,
    video: video
  });
}

function enumerateVideoDevices() {
  return _enumerateVideoDevices.apply(this, arguments);
}

function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {
    var devices;
    return regenerator_default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return enumerateDevices();

          case 2:
            devices = _context3.sent;
            return _context3.abrupt("return", devices.filter(function (device) {
              return device.kind === 'videoinput';
            }));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}

function getActiveTrack() {
  if (!streamRef) {
    return null;
  }

  var tracks = streamRef.getVideoTracks();
  return tracks && tracks !== null && tracks !== void 0 && tracks.length ? tracks[0] : null;
}
/**
 * Used for accessing information about the active stream track and available video devices.
 */


var QuaggaJSCameraAccess = {
  requestedVideoElement: null,
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              QuaggaJSCameraAccess.requestedVideoElement = video;
              _context.next = 3;
              return pickConstraints(videoConstraints);

            case 3:
              newConstraints = _context.sent;
              return _context.abrupt("return", initCamera(video, newConstraints));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  release: function release() {
    var tracks = streamRef && streamRef.getVideoTracks();

    if (QuaggaJSCameraAccess.requestedVideoElement !== null) {
      QuaggaJSCameraAccess.requestedVideoElement.pause();
    }

    return new Promise(function (resolve) {
      setTimeout(function () {
        if (tracks && tracks.length) {
          tracks[0].stop();
        }

        streamRef = null;
        QuaggaJSCameraAccess.requestedVideoElement = null;
        resolve();
      }, 0);
    });
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts


function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}

function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}

/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;

    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }

    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;

          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug["a" /* default */].drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }

          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 4,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts


 // @ts-ignore // TODO: this produces a bizarre typescript error
// eslint-disable-next-line no-nested-ternary

var QuaggaConfig =  false ? undefined :  true ? config_node : undefined;
/* harmony default export */ var config_config = (QuaggaConfig);
// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// CONCATENATED MODULE: ./src/QuaggaContext.ts


var QuaggaContext_QuaggaContext = function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);

  defineProperty_default()(this, "config", void 0);

  defineProperty_default()(this, "inputStream", void 0);

  defineProperty_default()(this, "framegrabber", void 0);

  defineProperty_default()(this, "inputImageWrapper", void 0);

  defineProperty_default()(this, "stopped", false);

  defineProperty_default()(this, "boxSize", void 0);

  defineProperty_default()(this, "resultCollector", void 0);

  defineProperty_default()(this, "decoder", void 0);

  defineProperty_default()(this, "workerPool", []);

  defineProperty_default()(this, "onUIThread", true);

  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
};
var QuaggaContext_CanvasInfo = function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);

  defineProperty_default()(this, "image", void 0);

  defineProperty_default()(this, "overlay", void 0);
};
var QuaggaContext_CanvasContainer = function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);

  defineProperty_default()(this, "ctx", void 0);

  defineProperty_default()(this, "dom", void 0);

  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
};
// EXTERNAL MODULE: ./src/locator/barcode_locator.js
var barcode_locator = __webpack_require__(23);

// CONCATENATED MODULE: ./src/quagga/initBuffers.ts



// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var inputImageWrapper = imageWrapper || new image_wrapper["a" /* default */]({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });

  if (false) {}

  var boxSize = [Object(gl_vec2["clone"])([0, 0]), Object(gl_vec2["clone"])([0, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, 0])];
  barcode_locator["a" /* default */].init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  } // Check if target is already a DOM element


  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)


  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts


function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);

  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }

  return canvas;
}

function getCanvasAndContext(selector, className) {
  var canvas = findOrCreateCanvas(selector, className);
  var context = canvas.getContext('2d');
  return {
    canvas: canvas,
    context: context
  };
}

function initCanvases(canvasSize) {
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer');
    var overlay = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer');
    image.canvas.width = overlay.canvas.width = canvasSize.x;
    image.canvas.height = overlay.canvas.height = canvasSize.y;
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }

  return null;
}

function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu;

  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;
  var container = initCanvases(context.inputStream.getCanvasSize());
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;

  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }

      if (!viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }

  return container;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(33);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: external "get-pixels"
var external_get_pixels_ = __webpack_require__(87);
var external_get_pixels_default = /*#__PURE__*/__webpack_require__.n(external_get_pixels_);

// CONCATENATED MODULE: ./src/input/input_stream/input_stream.ts

// TODO: It's pretty likely that this shares code with the browser version, investigate that
// FOR ANYONE IN HERE IN THE FUTURE: This is the default input_stream module used for the Node bundle.
// webpack.config.js *replaces* this with input_stream_browser.ts when the bundle is being built for browser.

var inputStreamFactory = {
  createVideoStream: function createVideoStream() {
    throw new Error('createVideoStream not available');
  },
  createLiveStream: function createLiveStream() {
    throw new Error('createLiveStream not available');
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var loaded = false; // TODO: frame should be a type NdArray, but NdArray doesn't have ts definitions
    // TODO: there is a ts-ndarray that might work, though

    var frame = null;
    var baseUrl;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    /* eslint-disable no-unused-vars */
    // false eslint errors? weird.
    // @ts-ignore

    var size = 0; // @ts-ignore

    var frameIdx = 0; // @ts-ignore

    var paused = false;
    /* eslint-enable no-unused-vars */

    function loadImages() {
      var _config2;

      loaded = false;
      /* eslint-disable new-cap */

      external_get_pixels_default()(baseUrl, (_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.mime, function (err, pixels) {
        var _config3, _config4;

        if (err) {
          console.error('**** quagga loadImages error:', err);
          throw new Error('error decoding pixels in loadImages');
        }

        loaded = true;

        if (false) {} // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


        frame = pixels; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        var _pixels$shape = slicedToArray_default()(pixels.shape, 2);

        width = _pixels$shape[0];
        height = _pixels$shape[1];
        // eslint-disable-next-line no-nested-ternary
        calculatedWidth = (_config3 = _config) !== null && _config3 !== void 0 && _config3.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = (_config4 = _config) !== null && _config4 !== void 0 && _config4.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      });
    }

    function publishEvent(eventName, args) {
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (var j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args);
        }
      }
    } // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(w) {
        calculatedWidth = w;
      },
      setHeight: function setHeight(h) {
        calculatedHeight = h;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        var _config5;

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        baseUrl = (_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.src;
        size = 1;
        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(sz) {
        _canvasSize.x = sz.x;
        _canvasSize.y = sz.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        if (!loaded) {
          return null;
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream = (inputStreamFactory);
// EXTERNAL MODULE: ./src/input/frame_grabber.js
var frame_grabber = __webpack_require__(88);
var frame_grabber_default = /*#__PURE__*/__webpack_require__.n(frame_grabber);

// CONCATENATED MODULE: ./src/quagga/qworker.ts


function qworker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function qworker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { qworker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { qworker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */
// TODO: need a typescript interface for FrameGrabber
var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;

  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];

    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);

      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }

      return true;
    } else {
      return false;
    }
  }

  return null;
}

function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
} // @ts-ignore


function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];

    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  } // @ts-ignore


  var imageWrapper; // @ts-ignore

  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result // @ts-ignore

    }, [imageWrapper.data.buffer]);
  }

  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data // @ts-ignore

    }, [imageWrapper.data.buffer]);
  } // @ts-ignore


  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}

function generateWorkerBlob() {
  var blob, factorySource;
  /* jshint ignore:start */
  // @ts-ignore

  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */


  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}

function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };

  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);

      if (false) {}

      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false; // TODO: how to thread publishResult into here?
      // publishResult(e.data.result, workerThread.imageData);
    } else if (e.data.event === 'error') {
      if (false) {}
    }
  };

  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;

  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();

      if (false) {}
    });
    workerPool = workerPool.slice(0, increaseBy);

    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);

      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };

    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var InputStream = arguments.length > 2 ? arguments[2] : undefined;

  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: InputStream.createVideoStream(video)
        };
      }

    case 'ImageStream':
      return {
        inputStream: InputStream.createImageStream()
      };

    case 'LiveStream':
      {
        var _video = null;

        if (viewport) {
          _video = viewport.querySelector('video');

          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }

        return {
          video: _video,
          inputStream: InputStream.createLiveStream(_video)
        };
      }

    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */
function moveBox(box, xOffset, yOffset) {
  var corner = box.length;

  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts




















var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;

    classCallCheck_default()(this, Quagga);

    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());

    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;

      if (!_this.context.config) {
        return;
      }

      barcode_locator["a" /* default */].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);

      _this.initCanvas();

      _this.context.framegrabber = frame_grabber_default.a.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);

      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }

      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;

        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }

        _this.ready(callback);
      });
    });

    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);

        if (!workersUpdated) {
          var _this$context$inputIm;

          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);

          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;

        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);

        _this.context.framegrabber.grab();

        _this.locateAndDecode();
      }
    });
  }

  createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
          inputImageWrapper = _initBuffers2.inputImageWrapper,
          boxSize = _initBuffers2.boxSize;

      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }

      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);

      if (!container) {
        return;
      }

      var ctx = container.ctx,
          dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }

      var _this$context$config$ = this.context.config.inputStream,
          inputType = _this$context$config$.type,
          constraints = _this$context$config$.constraints;

      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), input_stream),
          video = _setupInputStream.video,
          inputStream = _setupInputStream.inputStream;

      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }

      inputStream.setAttribute('preload', 'auto');
      inputStream.setInputStream(this.context.config.inputStream);
      inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;

      return (_this$context$config3 = this.context.config) !== null && _this$context$config3 !== void 0 && _this$context$config3.locate ? barcode_locator["a" /* default */].locate() : [[Object(gl_vec2["clone"])(this.context.boxSize[0]), Object(gl_vec2["clone"])(this.context.boxSize[1]), Object(gl_vec2["clone"])(this.context.boxSize[2]), Object(gl_vec2["clone"])(this.context.boxSize[3])]];
    } // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;

      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;

      if (xOffset === 0 && yOffset === 0) {
        return;
      }

      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode);
        });
      }

      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }

      if (result.box) {
        moveBox(result.box, xOffset, yOffset);
      }

      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          moveBox(result.boxes[i], xOffset, yOffset);
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;

      if (!imageData || !this.context.resultCollector) {
        return;
      } // TODO: Figure out what data structure holds a "barcodes" result, if any...


      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "publishResult",
    value: function publishResult() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;

      if (result && this.context.onUIThread) {
        this.transformResult(result);
        this.addResult(result, imageData);
        resultToPublish = result.barcodes || result;
      }

      events.publish('processed', resultToPublish);

      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }
    }
  }, {
    key: "locateAndDecode",
    value: function locateAndDecode() {
      var boxes = this.getBoundingBoxes();

      if (boxes) {
        var _this$context$inputIm3;

        var decodeResult = this.context.decoder.decodeFromBoundingBoxes(boxes) || {};
        decodeResult.boxes = boxes;
        this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
      } else {
        var imageResult = this.context.decoder.decodeFromImage(this.context.inputImageWrapper);

        if (imageResult) {
          var _this$context$inputIm4;

          this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
        } else {
          this.publishResult();
        }
      }
    }
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
          _this4 = this;

      var next = null;
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;

      var newFrame = function newFrame(timestamp) {
        next = next || timestamp;

        if (!context.stopped) {
          if (timestamp >= next) {
            next += delay;

            _this4.update();
          }

          window.requestAnimationFrame(newFrame);
        }
      };

      newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;

      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function () {
      var _stop = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
        var _this$context$config7;

        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.context.stopped = true;
                adjustWorkerPool(0);

                if (!((_this$context$config7 = this.context.config) !== null && _this$context$config7 !== void 0 && _this$context$config7.inputStream && this.context.config.inputStream.type === 'LiveStream')) {
                  _context.next = 6;
                  break;
                }

                _context.next = 5;
                return camera_access.release();

              case 5:
                this.context.inputStream.clearEventHandlers();

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }

      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);

      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }

      qworker_registerReader(name, reader);
    }
  }]);

  return Quagga;
}();


// CONCATENATED MODULE: ./src/quagga.js


 // eslint-disable-line no-unused-vars










var instance = new quagga_Quagga();
var quagga_context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;

    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }

    quaggaInstance.context.config = merge_default()({}, config_config, config); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }

    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);

      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }

    return promise;
  },
  start: function start() {
    return instance.start();
  },
  stop: function stop() {
    return instance.stop();
  },
  pause: function pause() {
    quagga_context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }

    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }

    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }

    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }

    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }

    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      quagga_context.resultCollector = resultCollector;
    }
  },

  get canvas() {
    return quagga_context.canvasContainer;
  },

  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;

    var quaggaInstance = new quagga_Quagga();
    config = merge_default()({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  false ? undefined : 1,
      locator: {
        halfSample: false
      }
    }, config); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/

    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    } // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.


    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }

    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          events.once('processed', function (result) {
            quaggaInstance.stop();

            if (resultCallback) {
              resultCallback.call(null, result);
            }

            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },

  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },

  BarcodeReader: barcode_reader,
  CameraAccess: camera_access,
  ImageDebug: image_debug["a" /* default */],
  ImageWrapper: image_wrapper["a" /* default */],
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins



/***/ })
/******/ ])["default"]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9hcnJheV9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9pbWFnZV93cmFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vY2x1c3Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2N2X3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2ltYWdlX2RlYnVnLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3IvdHJhY2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2aWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9lcHNpbG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mcm9tVmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGl2aWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3IvcmFzdGVyaXplci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbG9jYXRvci9za2VsZXRvbml6ZXIuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZ2V0LXBpeGVsc1wiIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9mcmFtZV9ncmFiYmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL3R5cGVkZWZzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9mcm9tVmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2NvcHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9leGFjdEVxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9hZGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3ViLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL211bC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvaW52ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbWF4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9mbG9vci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jZWlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3JvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NjYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NjYWxlQW5kQWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3FyRGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3FyTGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZG90LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Nyb3NzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xlcnAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvcmFuZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0MmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0My5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGltaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvYW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvY29weS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZXF1YWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2V4YWN0RXF1YWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2FkZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zdWIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbXVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpdi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbWF4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Zsb29yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NlaWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc2NhbGVBbmRBZGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zcXJEaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2xlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zcXJMZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbmVnYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2ludmVyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvY3Jvc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVycC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtTWF0NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1NYXQzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybVF1YXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVZLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVouanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrQnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZsYXRSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9kZXRlcm1pbmFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi90cmFuc3Bvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvYWRqb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9yb3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW52ZXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9jb3B5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2Zyb2IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvbGR1LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5kYXJyYXlcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZVwiIiwid2VicGFjazovLy8uL3NyYy9kZWNvZGVyL2JyZXNlbmhhbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2JhcmNvZGVfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvY29kZV8xMjhfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuX3JlYWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMzlfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvY29kYWJhcl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci91cGNfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvdXBjX2VfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvaTJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvMm9mNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9jb2RlXzkzX3JlYWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMzJfcmVhZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2V2ZW50cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL21lZGlhRGV2aWNlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvY2FtZXJhX2FjY2Vzcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYW5hbHl0aWNzL3Jlc3VsdF9jb2xsZWN0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25maWcuZGV2LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLm5vZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25maWcucHJvZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvUXVhZ2dhQ29udGV4dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcXVhZ2dhL2luaXRCdWZmZXJzLnRzIiwid2VicGFjazovLy8uL3NyYy9xdWFnZ2EvZ2V0Vmlld1BvcnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS9pbml0Q2FudmFzLnRzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtLnRzIiwid2VicGFjazovLy8uL3NyYy9xdWFnZ2EvcXdvcmtlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcXVhZ2dhL3NldHVwSW5wdXRTdHJlYW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS90cmFuc2Zvcm0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS9xdWFnZ2EudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS5qcyJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfZ2V0UHJvdG90eXBlT2YiLCJvIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJfdHlwZW9mIiwicmVxdWlyZSIsImFzc2VydFRoaXNJbml0aWFsaXplZCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiY2FsbCIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiRVBTSUxPTiIsImNsb25lIiwiZnJvbVZhbHVlcyIsImNvcHkiLCJzZXQiLCJlcXVhbHMiLCJleGFjdEVxdWFscyIsImFkZCIsInN1YnRyYWN0Iiwic3ViIiwibXVsdGlwbHkiLCJtdWwiLCJkaXZpZGUiLCJkaXYiLCJpbnZlcnNlIiwibWluIiwibWF4Iiwicm90YXRlIiwiZmxvb3IiLCJjZWlsIiwicm91bmQiLCJzY2FsZSIsInNjYWxlQW5kQWRkIiwiZGlzdGFuY2UiLCJkaXN0Iiwic3F1YXJlZERpc3RhbmNlIiwic3FyRGlzdCIsImxlbiIsInNxdWFyZWRMZW5ndGgiLCJzcXJMZW4iLCJuZWdhdGUiLCJub3JtYWxpemUiLCJkb3QiLCJjcm9zcyIsImxlcnAiLCJyYW5kb20iLCJ0cmFuc2Zvcm1NYXQyIiwidHJhbnNmb3JtTWF0MmQiLCJ0cmFuc2Zvcm1NYXQzIiwidHJhbnNmb3JtTWF0NCIsImZvckVhY2giLCJsaW1pdCIsImluaXQiLCJhcnIiLCJ2YWwiLCJsIiwic2h1ZmZsZSIsImoiLCJNYXRoIiwieCIsInRvUG9pbnRMaXN0Iiwicm93cyIsInJlZHVjZSIsInAiLCJuIiwicm93Iiwiam9pbiIsInB1c2giLCJ0aHJlc2hvbGQiLCJzY29yZUZ1bmMiLCJxdWV1ZSIsInByZXYiLCJuZXh0IiwiYXBwbHkiLCJtYXhJbmRleCIsInN1bSIsInZlYzIiLCJhc3NlcnROdW1iZXJQb3NpdGl2ZSIsIkVycm9yIiwiSW1hZ2VXcmFwcGVyIiwic2l6ZSIsImRhdGEiLCJBcnJheVR5cGUiLCJVaW50OEFycmF5IiwiaW5pdGlhbGl6ZSIsInkiLCJBcnJheUhlbHBlciIsImltZ1JlZiIsImJvcmRlciIsImltYWdlV3JhcHBlciIsImZyb20iLCJzaXplWCIsInNpemVZIiwiaW5kZXhNYXBwaW5nIiwid2lkdGgiLCJoZWlnaHQiLCJsYWJlbENvdW50IiwieXNxIiwibGFiZWxTdW0iLCJsYWJlbCIsIm11MTEiLCJtdTAyIiwibXUyMCIsInhfIiwieV8iLCJ0bXAiLCJyZXN1bHQiLCJQSSIsIlBJXzQiLCJtMDAiLCJtMDEiLCJtMTAiLCJtMTEiLCJtMDIiLCJtMjAiLCJ0aGV0YSIsInJhZCIsImlzTmFOIiwiYXRhbiIsInZlYyIsImNvcyIsInNpbiIsInJldCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwicGl4ZWwiLCJjdXJyZW50IiwiZ2V0IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZyYW1lIiwiZ2V0SW1hZ2VEYXRhIiwiZ2V0QXNSR0JBIiwibmV3RnJhbWUiLCJJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJpblNjYWxlIiwiYWRqdXN0ZWRTY2FsZSIsImhzdiIsInJnYiIsIndoaXRlUmdiIiwiYmxhY2tSZ2IiLCJoc3YycmdiIiwicG9zIiwicG9pbnQiLCJwb2ludHMiLCJjZW50ZXIiLCJwb2ludE1hcCIsInBvaW50VG9BZGQiLCJpZCIsInVwZGF0ZUNlbnRlciIsImZpdHMiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImFicyIsImdldFBvaW50cyIsImdldENlbnRlciIsImNyZWF0ZVBvaW50IiwibmV3UG9pbnQiLCJwcm9wZXJ0eSIsInYyY2xvbmUiLCJ2ZWMzIiwidjNjbG9uZSIsImltYWdlUmVmIiwidGhhdCIsInRvVmVjMiIsInRvVmVjMyIsImNvbXB1dGVJbnRlZ3JhbEltYWdlMiIsImludGVncmFsV3JhcHBlciIsImltYWdlRGF0YSIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidiIsInUiLCJ0aHJlc2hvbGRJbWFnZSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiY29tcHV0ZUhpc3RvZ3JhbSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJzaGFycGVuTGluZSIsImxpbmUiLCJsZWZ0IiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIm90c3VUaHJlc2hvbGQiLCJjb21wdXRlQmluYXJ5SW1hZ2UiLCJrZXJuZWwiLCJBIiwiQiIsIkMiLCJEIiwiYXZnIiwiY2x1c3RlciIsInRoaXNDbHVzdGVyIiwiY2x1c3RlcnMiLCJhZGRUb0NsdXN0ZXIiLCJmb3VuZCIsIkNsdXN0ZXIyIiwiVHJhY2VyIiwidHJhY2UiLCJpdGVyYXRpb24iLCJtYXhJdGVyYXRpb25zIiwidG9wIiwiY2VudGVyUG9zIiwiY3VycmVudFBvcyIsImlkeCIsImZvcndhcmQiLCJ0byIsInRvSWR4IiwicHJlZGljdGVkUG9zIiwidGhyZXNob2xkWCIsInRocmVzaG9sZFkiLCJtYXRjaCIsInByZWRpY3RlZCIsIkRJTEFURSIsIkVST0RFIiwiZGlsYXRlIiwiaW5JbWFnZVdyYXBwZXIiLCJvdXRJbWFnZVdyYXBwZXIiLCJpbkltYWdlRGF0YSIsIm91dEltYWdlRGF0YSIsInlTdGFydDEiLCJ5U3RhcnQyIiwieFN0YXJ0MSIsInhTdGFydDIiLCJlcm9kZSIsImFJbWFnZVdyYXBwZXIiLCJiSW1hZ2VXcmFwcGVyIiwicmVzdWx0SW1hZ2VXcmFwcGVyIiwiYUltYWdlRGF0YSIsImJJbWFnZURhdGEiLCJjSW1hZ2VEYXRhIiwiYml0d2lzZU9yIiwiY291bnROb25aZXJvIiwidG9wR2VuZXJpYyIsImxpc3QiLCJtaW5JZHgiLCJzY29yZSIsImhpdCIsIml0ZW0iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwiY29tcHV0ZUdyYXkiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsIm9mZnNldCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJjb25maWciLCJzaW5nbGVDaGFubmVsIiwibG9hZEltYWdlQXJyYXkiLCJzcmMiLCJjYWxsYmFjayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImltZyIsIkltYWdlIiwib25sb2FkIiwiaGFsZlNhbXBsZSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImgiLCJzIiwiYyIsIm0iLCJyIiwiZyIsImIiLCJfY29tcHV0ZURpdmlzb3JzIiwibGFyZ2VEaXZpc29ycyIsImRpdmlzb3JzIiwic3FydCIsInVuc2hpZnQiLCJjb25jYXQiLCJfY29tcHV0ZUludGVyc2VjdGlvbiIsImFycjEiLCJhcnIyIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiZGltZW5zaW9uIiwicGFyc2VGbG9hdCIsInVuaXQiLCJpbmRleE9mIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29udGV4dCIsImJvdHRvbSIsImNvbXB1dGVJbWFnZUFyZWEiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJpc09iamVjdCIsInR5cGUiLCJpc0FycmF5IiwiQXJyYXkiLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwiYmFzZU1lcmdlIiwiY3JlYXRlQXNzaWduZXIiLCJtZXJnZSIsIm9iamVjdCIsInNvdXJjZSIsInNyY0luZGV4Iiwic3VwZXJQcm9wQmFzZSIsIl9nZXQiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJiYXNlIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJGdW5jdGlvbiIsImlzT2JqZWN0TGlrZSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93IiwiYXJnIiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsImFyZ3MiLCJhcmd1bWVudHMiLCJlcnIiLCJ1bmRlZmluZWQiLCJzZWFyY2hEaXJlY3Rpb25zIiwibGFiZWxXcmFwcGVyIiwibGFiZWxEYXRhIiwiZWRnZWxhYmVsIiwiY3kiLCJkaXIiLCJjeCIsInZlcnRleDJEIiwiY29udG91clRyYWNpbmciLCJGdiIsIkN2IiwiUCIsImxkaXIiLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyIsIl9jb25maWciLCJfY3VycmVudEltYWdlV3JhcHBlciIsIl9za2VsSW1hZ2VXcmFwcGVyIiwiX3N1YkltYWdlV3JhcHBlciIsIl9sYWJlbEltYWdlV3JhcHBlciIsIl9wYXRjaEdyaWQiLCJfcGF0Y2hMYWJlbEdyaWQiLCJfaW1hZ2VUb1BhdGNoR3JpZCIsIl9iaW5hcnlJbWFnZVdyYXBwZXIiLCJfcGF0Y2hTaXplIiwiX2NhbnZhc0NvbnRhaW5lciIsImJpbmFyeSIsImRvbSIsIl9udW1QYXRjaGVzIiwiX2lucHV0SW1hZ2VXcmFwcGVyIiwiX3NrZWxldG9uaXplciIsImluaXRCdWZmZXJzIiwic2tlbGV0b25JbWFnZURhdGEiLCJBcnJheUJ1ZmZlciIsInNrZWxldG9uaXplciIsIndpbmRvdyIsImdsb2JhbCIsImluaXRDYW52YXMiLCJ1c2VXb3JrZXIiLCJjbGFzc05hbWUiLCJFTlYiLCJib3hGcm9tUGF0Y2hlcyIsInBhdGNoZXMiLCJvdmVyQXZnIiwicGF0Y2giLCJ0cmFuc01hdCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJib3giLCJtYXQyIiwiYmluYXJpemVJbWFnZSIsInplcm9Cb3JkZXIiLCJmaW5kUGF0Y2hlcyIsIm1vbWVudHMiLCJwYXRjaGVzRm91bmQiLCJyYXN0ZXJpemVyIiwicmFzdGVyUmVzdWx0Iiwic2tlbGV0b25pemUiLCJSYXN0ZXJpemVyIiwicmFzdGVyaXplIiwiY291bnQiLCJkZXNjcmliZVBhdGNoIiwiZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyIsIm1heExhYmVsIiwibGFiZWxIaXN0IiwidG9wTGFiZWxzIiwibWFwIiwic29ydCIsImEiLCJmaWx0ZXIiLCJlbCIsImZpbmRCb3hlcyIsImJveGVzIiwic2ltaWxhck1vbWVudHMiLCJ0b3BDbHVzdGVyIiwiZSIsInN1YkltYWdlQXNDb3B5IiwicGF0Y2hQb3MiLCJlbGlnaWJsZU1vbWVudHMiLCJtYXRjaGluZ01vbWVudHMiLCJtaW5Db21wb25lbnRXZWlnaHQiLCJpbmRleCIsInJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5IiwiY3VycklkeCIsIm5vdFlldFByb2Nlc3NlZCIsImN1cnJlbnRJZHgiLCJjdXJyZW50UGF0Y2giLCJpbnB1dEltYWdlV3JhcHBlciIsImxvY2F0ZSIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsImlucHV0U3RyZWFtIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJ0aGlzSGFsZlNhbXBsZSIsImdldENvbmZpZyIsInNldFRvcFJpZ2h0Iiwic2V0Q2FudmFzU2l6ZSIsInNldFdpZHRoIiwic2V0SGVpZ2h0IiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsImhhcyIsImVxIiwiYXNzb2NJbmRleE9mIiwib3RoZXIiLCJnZXROYXRpdmUiLCJuYXRpdmVDcmVhdGUiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiX19kYXRhX18iLCJiYXNlSXNBcmd1bWVudHMiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZUlzVWludCIsImlzSW5kZXgiLCJ0ZXN0IiwiaXNLZXkiLCJzdHJpbmdUb1BhdGgiLCJ0b1N0cmluZyIsImNhc3RQYXRoIiwiYXJyYXlXaXRoSG9sZXMiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVSZXN0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnJheVdpdGhvdXRIb2xlcyIsIml0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlU3ByZWFkIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiZGV0ZXJtaW5hbnQiLCJ0cmFuc3Bvc2UiLCJpZGVudGl0eSIsImFkam9pbnQiLCJpbnZlcnQiLCJmcm9iIiwibGR1IiwiYmFzZUlzTmF0aXZlIiwiZ2V0VmFsdWUiLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJ0YWciLCJiYXNlQXNzaWduVmFsdWUiLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsImNoaWxkcmVuIiwiaXNMZW5ndGgiLCJpc0FycmF5TGlrZSIsInN5bWJvbFRhZyIsImlzU3ltYm9sIiwiSU5GSU5JVFkiLCJ0b0tleSIsIk1hcCIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImZ1bmMiLCJvdmVyQXJnIiwiZ2V0UHJvdG90eXBlIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwicHJvdG8iLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VVbmFyeSIsIm5vZGVVdGlsIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsInNhZmVHZXQiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzSW4iLCJrZXlzSW4iLCJuYXRpdmVNYXgiLCJvdmVyUmVzdCIsInN0YXJ0IiwidHJhbnNmb3JtIiwib3RoZXJBcmdzIiwiYmFzZVNldFRvU3RyaW5nIiwic2hvcnRPdXQiLCJzZXRUb1N0cmluZyIsImFycmF5TGlrZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJtaW5MZW4iLCJzbGljZSIsIm5hbWUiLCJfYXJyYXlMaWtlVG9BcnJheSIsIm91dCIsIkZsb2F0MzJBcnJheSIsInoiLCJhbmdsZSIsInRyYW5zZm9ybVF1YXQiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJiYXNlUGljayIsImZsYXRSZXN0IiwicGljayIsImNyZWF0ZUNvbnRvdXIyRCIsImZpcnN0VmVydGV4IiwiaW5zaWRlQ29udG91cnMiLCJuZXh0cGVlciIsInByZXZwZWVyIiwiQ09OVE9VUl9ESVIiLCJDV19ESVIiLCJDQ1dfRElSIiwiVU5LTk9XTl9ESVIiLCJESVIiLCJPVVRTSURFX0VER0UiLCJJTlNJREVfRURHRSIsInRyYWNlciIsImRlcHRobGFiZWwiLCJiYyIsImxjIiwibGFiZWxpbmRleCIsImNvbG9yTWFwIiwidmVydGV4IiwiY2MiLCJzYyIsImNvbm5lY3RlZENvdW50IiwiZGVidWciLCJkcmF3Q29udG91ciIsImZpcnN0Q29udG91ciIsInBxIiwiaXEiLCJxIiwiU2tlbGV0b25pemVyIiwic3RkbGliIiwiZm9yZWlnbiIsImJ1ZmZlciIsImltYWdlcyIsImltdWwiLCJpbkltYWdlUHRyIiwib3V0SW1hZ2VQdHIiLCJhSW1hZ2VQdHIiLCJiSW1hZ2VQdHIiLCJpbWFnZVB0ciIsIm1lbWNweSIsInNyY0ltYWdlUHRyIiwiZHN0SW1hZ2VQdHIiLCJzdWJJbWFnZVB0ciIsImVyb2RlZEltYWdlUHRyIiwidGVtcEltYWdlUHRyIiwic2tlbEltYWdlUHRyIiwiQ1ZVdGlscyIsIk5kYXJyYXkiLCJJbnRlcnAyRCIsImQyIiwiRnJhbWVHcmFiYmVyIiwiX3RoYXQiLCJfdmlkZW9TaXplIiwiZ2V0UmVhbFdpZHRoIiwiZ2V0UmVhbEhlaWdodCIsIl9jYW52YXNTaXplIiwiZ2V0Q2FudmFzU2l6ZSIsIl9zaXplIiwiX3RvcFJpZ2h0IiwiZ2V0VG9wUmlnaHQiLCJfZGF0YSIsIl9ncmF5RGF0YSIsIl9jYW52YXNEYXRhIiwiX2dyYXlJbWFnZUFycmF5IiwiX2NhbnZhc0ltYWdlQXJyYXkiLCJfdGFyZ2V0SW1hZ2VBcnJheSIsImhpIiwibG8iLCJfc3RlcFNpemVYIiwiX3N0ZXBTaXplWSIsImF0dGFjaERhdGEiLCJnZXREYXRhIiwiZ3JhYiIsImdldEZyYW1lIiwic2NhbGVBbmRDcm9wIiwic2hhcGUiLCJnZXRTaXplIiwiU3RhY2siLCJiYXNlRm9yIiwiYmFzZU1lcmdlRGVlcCIsImN1c3RvbWl6ZXIiLCJzdGFjayIsInNyY1ZhbHVlIiwibmV3VmFsdWUiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGFzdEluZGV4IiwicG9wIiwiTEFSR0VfQVJSQVlfU0laRSIsInBhaXJzIiwiaXNNYXNrZWQiLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJyZXBsYWNlIiwicGF0dGVybiIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ1bm1hc2tlZCIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsIklFX1BST1RPIiwiSGFzaCIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIQVNIX1VOREVGSU5FRCIsImNyZWF0ZUJhc2VGb3IiLCJmcm9tUmlnaHQiLCJpdGVyYXRlZSIsImtleXNGdW5jIiwiaXRlcmFibGUiLCJjbG9uZUJ1ZmZlciIsImNsb25lVHlwZWRBcnJheSIsImNvcHlBcnJheSIsImluaXRDbG9uZU9iamVjdCIsImlzQXJyYXlMaWtlT2JqZWN0IiwiaXNQbGFpbk9iamVjdCIsInRvUGxhaW5PYmplY3QiLCJtZXJnZUZ1bmMiLCJzdGFja2VkIiwiaXNDb21tb24iLCJpc0FyciIsImlzQnVmZiIsImlzVHlwZWQiLCJhbGxvY1Vuc2FmZSIsImlzRGVlcCIsImNsb25lQXJyYXlCdWZmZXIiLCJ0eXBlZEFycmF5IiwiYnl0ZU9mZnNldCIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImJhc2VDcmVhdGUiLCJvYmplY3RDcmVhdGUiLCJhcmdzVGFnIiwib2JqZWN0VGFnIiwib2JqZWN0Q3RvclN0cmluZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJ0eXBlcyIsImJpbmRpbmciLCJjb3B5T2JqZWN0IiwiaXNOZXciLCJiYXNlVGltZXMiLCJpbmhlcml0ZWQiLCJpc0FyZyIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiU3RyaW5nIiwibmF0aXZlS2V5c0luIiwiaXNQcm90byIsImJhc2VSZXN0IiwiaXNJdGVyYXRlZUNhbGwiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsInRoaXNBcmciLCJjb25zdGFudCIsInN0cmluZyIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiRGF0ZSIsIm5vdyIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJhaCIsImFsIiwiYmgiLCJibCIsImFzc2lnbiIsIm5leHRTb3VyY2UiLCJuZXh0S2V5IiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiX3MiLCJfbm9uSXRlcmFibGVSZXN0IiwiYTAiLCJhMSIsImIwIiwiYjEiLCJ0IiwiYXgiLCJheSIsInN0cmlkZSIsIm1TcSIsInRlbXBBIiwidGVtcEIiLCJjb3NpbmUiLCJhY29zIiwiYTIiLCJiMiIsImF6IiwiYngiLCJieSIsImJ6IiwielNjYWxlIiwidyIsInF4IiwicXkiLCJxeiIsInF3IiwiaXgiLCJpeSIsIml6IiwiaXciLCJweSIsInB6IiwiX3NldFByb3RvdHlwZU9mIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIml0ZXIiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJfc3VwZXJQcm9wQmFzZSIsInJ1bnRpbWUiLCJPcCIsImhhc093biIsIiRTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiQ29udGV4dCIsIl9pbnZva2UiLCJtYWtlSW52b2tlTWV0aG9kIiwidHJ5Q2F0Y2giLCJHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0IiwiR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCIsIkdlblN0YXRlRXhlY3V0aW5nIiwiR2VuU3RhdGVDb21wbGV0ZWQiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJOYXRpdmVJdGVyYXRvclByb3RvdHlwZSIsInZhbHVlcyIsIkdwIiwiZGlzcGxheU5hbWUiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJtZXRob2QiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiY3RvciIsIm1hcmsiLCJhd3JhcCIsIl9fYXdhaXQiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJpbnZva2UiLCJyZWNvcmQiLCJ1bndyYXBwZWQiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsInN0YXRlIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwicmV2ZXJzZSIsIml0ZXJhdG9yTWV0aG9kIiwic2tpcFRlbXBSZXNldCIsImNoYXJBdCIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiYmFzZVBpY2tCeSIsImhhc0luIiwiYmFzZUdldCIsImJhc2VTZXQiLCJwcmVkaWNhdGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwibWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJjaGFyQ29kZUF0IiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsImNhY2hlIiwiRlVOQ19FUlJPUl9URVhUIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwiYmFzZVRvU3RyaW5nIiwiYXJyYXlNYXAiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwibmVzdGVkIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJmbGF0dGVuIiwiYmFzZUZsYXR0ZW4iLCJhcnJheVB1c2giLCJpc0ZsYXR0ZW5hYmxlIiwiZGVwdGgiLCJpc1N0cmljdCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJhMyIsImIzIiwiZGV0IiwidjAiLCJ2MSIsInBvdyIsIkwiLCJVIiwiQnJlc2VuaGFtIiwiU2xvcGUiLCJVUCIsIkRPV04iLCJnZXRCYXJjb2RlTGluZSIsIngwIiwieTAiLCJ4MSIsInkxIiwic3RlZXAiLCJyZWFkIiwiZGVsdGFYIiwiZGVsdGFZIiwieVN0ZXAiLCJ0b0JpbmFyeUxpbmUiLCJzbG9wZSIsInNsb3BlMiIsImV4dHJlbWEiLCJjdXJyZW50RGlyIiwiclRocmVzaG9sZCIsInByaW50RnJlcXVlbmN5IiwicHJpbnRQYXR0ZXJuIiwiZmlsbENvbG9yIiwiZmlsbFJlY3QiLCJCYXJjb2RlRGlyZWN0aW9uIiwiQmFyY29kZVJlYWRlciIsInN1cHBsZW1lbnRzIiwiX3JvdyIsImNvdW50ZXIiLCJjb2RlIiwibWF4U2luZ2xlRXJyb3IiLCJzaW5nbGVFcnJvciIsIm1vZHVsbyIsImJhcldpZHRoIiwic2NhbGVkIiwiU0lOR0xFX0NPREVfRVJST1IiLCJjb3JyZWN0aW9uIiwiaW5kaWNlcyIsIl9kZWNvZGUiLCJkaXJlY3Rpb24iLCJSZXZlcnNlIiwiRm9yd2FyZCIsImZvcm1hdCIsIkZPUk1BVCIsIl9uZXh0VW5zZXQiLCJpc1doaXRlIiwiY291bnRlcnMiLCJjb3VudGVyUG9zIiwibnVtQ291bnRlcnMiLCJTdGFydE5vdEZvdW5kRXhjZXB0aW9uIiwiQ29kZU5vdEZvdW5kRXhjZXB0aW9uIiwiUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uIiwiQ29kZTEyOFJlYWRlciIsImJhciIsInNwYWNlIiwiYmVzdE1hdGNoIiwiX2NvcnJlY3QiLCJDT0RFX1BBVFRFUk4iLCJfbWF0Y2hQYXR0ZXJuIiwiQVZHX0NPREVfRVJST1IiLCJjYWxjdWxhdGVDb3JyZWN0aW9uIiwiTU9EVUxFX0lORElDRVMiLCJfY29ycmVjdEJhcnMiLCJfbmV4dFNldCIsIlNUQVJUX0NPREVfQSIsIlNUQVJUX0NPREVfQyIsInN0YXJ0SW5mbyIsIl9maW5kU3RhcnQiLCJkZWNvZGVkQ29kZXMiLCJjaGVja3N1bSIsImNvZGVzZXQiLCJDT0RFX0EiLCJTVEFSVF9DT0RFX0IiLCJDT0RFX0IiLCJDT0RFX0MiLCJzaGlmdE5leHQiLCJyZW1vdmVMYXN0Q2hhcmFjdGVyIiwibXVsdGlwbGllciIsInJhd1Jlc3VsdCIsIl9kZWNvZGVDb2RlIiwiU1RPUF9DT0RFIiwiZnJvbUNoYXJDb2RlIiwiQ09ERV9TSElGVCIsIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UiLCJlbmRJbmZvIiwidHJhaWxpbmdXaGl0ZXNwYWNlRW5kIiwiX21hdGNoUmFuZ2UiLCJleHBlY3RlZCIsIm5vcm1hbGl6ZWQiLCJzdW1Ob3JtYWxpemVkIiwic3VtRXhwZWN0ZWQiLCJDT0RFX0dfU1RBUlQiLCJTVEFSVF9QQVRURVJOIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsIkNPREVfRlJFUVVFTkNZIiwiRUFOUmVhZGVyIiwidHJ5SGFyZGVyIiwiZmlsbCIsImVwc2lsb24iLCJjb2RlcmFuZ2UiLCJfZmluZFBhdHRlcm4iLCJsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0IiwiY29kZUZyZXF1ZW5jeSIsImluQ29kZSIsIm91dENvZGUiLCJmaXJzdERpZ2l0IiwiX2NhbGN1bGF0ZUZpcnN0RGlnaXQiLCJtaWRkbGVQYXR0ZXJuIiwiU1RPUF9QQVRURVJOIiwiY29uc29sZSIsInJlc3VsdEluZm8iLCJfZGVjb2RlUGF5bG9hZCIsIl9maW5kRW5kIiwiX2NoZWNrc3VtIiwic3VwcGxlbWVudCIsIl9kZWNvZGVFeHRlbnNpb25zIiwibGFzdENvZGUiLCJBTFBIQUJFVEhfU1RSSU5HIiwiQUxQSEFCRVQiLCJVaW50MTZBcnJheSIsImNoYXIiLCJDSEFSQUNURVJfRU5DT0RJTkdTIiwiQVNURVJJU0siLCJDb2RlMzlSZWFkZXIiLCJwYXR0ZXJuU3RhcnQiLCJfdG9QYXR0ZXJuIiwid2hpdGVTcGFjZU11c3RTdGFydCIsIm1heE5hcnJvd1dpZHRoIiwibnVtV2lkZUJhcnMiLCJ3aWRlQmFyV2lkdGgiLCJfZmluZE5leHRXaWR0aCIsIm1pbldpZHRoIiwibGFzdFN0YXJ0IiwibmV4dFN0YXJ0IiwicGF0dGVyblNpemUiLCJkZWNvZGVkQ2hhciIsIl90b0NvdW50ZXJzIiwiX3BhdHRlcm5Ub0NoYXIiLCJwYXR0ZXJucyIsIklPUSIsIkFaMDkiLCJDb2RlMzlWSU5SZWFkZXIiLCJfY2hlY2tDaGVja3N1bSIsIlNUQVJUX0VORCIsIk1JTl9FTkNPREVEX0NIQVJTIiwiTUFYX0FDQ0VQVEFCTEUiLCJQQURESU5HIiwiTmV3Q29kYWJhclJlYWRlciIsIl9jb3VudGVycyIsImJhclRocmVzaG9sZCIsIl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQiLCJzcGFjZVRocmVzaG9sZCIsImJpdG1hc2siLCJfaXNTdGFydEVuZCIsIl9zdW1Db3VudGVycyIsInN0YXJ0Q291bnRlciIsImVuZENvdW50ZXIiLCJfY2FsY3VsYXRlUGF0dGVybkxlbmd0aCIsImNoYXJDb2RlIiwiY2F0ZWdvcml6YXRpb24iLCJuYXJyb3ciLCJjb3VudHMiLCJ3aWRlIiwiX2NoYXJUb1BhdHRlcm4iLCJraW5kIiwiY2F0IiwibmV3a2luZCIsInRocmVzaG9sZHMiLCJfdGhyZXNob2xkUmVzdWx0UGF0dGVybiIsIl9maWxsQ291bnRlcnMiLCJfdmVyaWZ5V2hpdGVzcGFjZSIsIl92YWxpZGF0ZVJlc3VsdCIsIlVQQ1JlYWRlciIsInN1YnN0cmluZyIsIkVBTjhSZWFkZXIiLCJFQU4yUmVhZGVyIiwicGFyc2VJbnQiLCJDSEVDS19ESUdJVF9FTkNPRElOR1MiLCJkZXRlcm1pbmVDaGVja0RpZ2l0IiwiZXh0ZW5zaW9uQ2hlY2tzdW0iLCJFQU41UmVhZGVyIiwiVVBDRVJlYWRlciIsIl9kZXRlcm1pbmVQYXJpdHkiLCJuclN5c3RlbSIsInVwY2EiLCJsYXN0RGlnaXQiLCJfY29udmVydFRvVVBDQSIsIk4iLCJXIiwiSTJvZjVSZWFkZXIiLCJvcHRzIiwibm9ybWFsaXplQmFyU3BhY2VXaWR0aCIsImNvdW50ZXJTdW0iLCJjb2RlU3VtIiwiY29ycmVjdGlvblJhdGlvIiwiTUFYX0NPUlJFQ1RJT05fRkFDVE9SIiwiY29ycmVjdGlvblJhdGlvSW52ZXJzZSIsImJhclNwYWNlUmF0aW8iLCJuYXJyb3dCYXJXaWR0aCIsImNvdW50ZXJQYWlyIiwiY29kZXMiLCJjb3VudGVyTGVuZ3RoIiwiX2RlY29kZVBhaXIiLCJfdmVyaWZ5Q291bnRlckxlbmd0aCIsIlNUQVJUX1BBVFRFUk5fTEVOR1RIIiwiVHdvT2ZGaXZlUmVhZGVyIiwiQ29kZTkzUmVhZGVyIiwiY2hhckFycmF5IiwibmV4dENoYXIiLCJuZXh0Q2hhckNvZGUiLCJ3YXJuIiwibWF4V2VpZ2h0IiwiYXJyYXlUb0NoZWNrIiwid2VpZ2h0ZWRTdW1zIiwid2VpZ2h0IiwiY2hlY2tDaGFyIiwiX21hdGNoQ2hlY2tDaGFyIiwiX3ZlcmlmeUVuZCIsIl92ZXJpZnlDaGVja3N1bXMiLCJfZGVjb2RlRXh0ZW5kZWQiLCJBRUlPIiwiY29kZTMyc2V0IiwiQ29kZTMyUmVhZGVyIiwicmVzIiwiY29kZTMyIiwiX2RlY29kZUNvZGUzMiIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInJlZ2lzdGVyUmVhZGVyIiwicmVhZGVyIiwiX2NhbnZhcyIsImZyZXF1ZW5jeSIsIm92ZXJsYXkiLCJfYmFyY29kZVJlYWRlcnMiLCJpbml0UmVhZGVycyIsImluaXRDb25maWciLCJyZWFkZXJzIiwicmVhZGVyQ29uZmlnIiwiY29uZmlndXJhdGlvbiIsInJlYWRlck9iaiIsImdldEV4dGVuZGVkTGluZSIsImV4dCIsImV4dGVuZExpbmUiLCJhbW91bnQiLCJleHRlbnNpb24iLCJpbkltYWdlV2l0aEJvcmRlciIsImdldExpbmUiLCJ0cnlEZWNvZGUiLCJiYXJjb2RlTGluZSIsImRlY29kZVBhdHRlcm4iLCJjb2RlUmVzdWx0IiwidHJ5RGVjb2RlQnJ1dGVGb3JjZSIsImxpbmVBbmdsZSIsInNpZGVMZW5ndGgiLCJzbGljZXMiLCJ4ZGlyIiwieWRpciIsImdldExpbmVMZW5ndGgiLCJkZWNvZGVGcm9tSW1hZ2UiLCJkZWNvZGVJbWFnZSIsImRlY29kZUZyb21Cb3VuZGluZ0JveCIsImxpbmVMZW5ndGgiLCJhdGFuMiIsImRlY29kZUZyb21Cb3VuZGluZ0JveGVzIiwiYmFyY29kZXMiLCJtdWx0aXBsZSIsInNldFJlYWRlcnMiLCJFdmVudEludGVyZmFjZSIsImV2ZW50cyIsImdldEV2ZW50IiwiZXZlbnROYW1lIiwic3Vic2NyaWJlcnMiLCJjbGVhckV2ZW50cyIsInB1Ymxpc2hTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJfc3Vic2NyaWJlIiwiZXZlbnQiLCJzdWJzY3JpYmUiLCJwdWJsaXNoIiwic3Vic2NyaWJlciIsIm9uY2UiLCJ1bnN1YnNjcmliZSIsIkVSUk9SX0RFU0MiLCJlbnVtZXJhdGVEZXZpY2VzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiY29uc3RyYWludHMiLCJzdHJlYW1SZWYiLCJ3YWl0Rm9yVmlkZW8iLCJ2aWRlbyIsImF0dGVtcHRzIiwiY2hlY2tWaWRlbyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImluaXRDYW1lcmEiLCJzdHJlYW0iLCJzZXRBdHRyaWJ1dGUiLCJzcmNPYmplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwicGxheSIsImRlcHJlY2F0ZWRDb25zdHJhaW50cyIsInZpZGVvQ29uc3RyYWludHMiLCJtaW5Bc3BlY3RSYXRpbyIsImFzcGVjdFJhdGlvIiwibG9nIiwiZmFjaW5nIiwiZmFjaW5nTW9kZSIsInBpY2tDb25zdHJhaW50cyIsImRldmljZUlkIiwiYXVkaW8iLCJlbnVtZXJhdGVWaWRlb0RldmljZXMiLCJkZXZpY2VzIiwiZGV2aWNlIiwiZ2V0QWN0aXZlVHJhY2siLCJ0cmFja3MiLCJnZXRWaWRlb1RyYWNrcyIsIlF1YWdnYUpTQ2FtZXJhQWNjZXNzIiwicmVxdWVzdGVkVmlkZW9FbGVtZW50IiwicmVxdWVzdCIsIm5ld0NvbnN0cmFpbnRzIiwicmVsZWFzZSIsInBhdXNlIiwiZ2V0QWN0aXZlU3RyZWFtTGFiZWwiLCJ0cmFjayIsImNvbnRhaW5zIiwic29tZSIsImV2ZXJ5IiwicGFzc2VzRmlsdGVyIiwicmVzdWx0cyIsImNhcGFjaXR5IiwiY2FwdHVyZSIsIm1hdGNoZXNDb25zdHJhaW50cyIsImJsYWNrbGlzdCIsImFkZFJlc3VsdCIsImltYWdlU2l6ZSIsIkltYWdlRGVidWciLCJ0b0RhdGFVUkwiLCJnZXRSZXN1bHRzIiwiRGV2Q29uZmlnIiwibnVtT2ZXb3JrZXJzIiwiZGVjb2RlciIsImRyYXdCb3VuZGluZ0JveCIsInNob3dGcmVxdWVuY3kiLCJkcmF3U2NhbmxpbmUiLCJzaG93UGF0dGVybiIsImxvY2F0b3IiLCJzaG93Q2FudmFzIiwic2hvd1BhdGNoZXMiLCJzaG93Rm91bmRQYXRjaGVzIiwic2hvd1NrZWxldG9uIiwic2hvd0xhYmVscyIsInNob3dQYXRjaExhYmVscyIsInNob3dSZW1haW5pbmdQYXRjaExhYmVscyIsInNob3dUcmFuc2Zvcm1lZCIsInNob3dUcmFuc2Zvcm1lZEJveCIsInNob3dCQiIsIk5vZGVDb25maWciLCJzZXF1ZW5jZSIsIlByb2RDb25maWciLCJRdWFnZ2FDb25maWciLCJRdWFnZ2FDb250ZXh0IiwiQ2FudmFzQ29udGFpbmVyIiwiQ2FudmFzSW5mbyIsImJveFNpemUiLCJCYXJjb2RlTG9jYXRvciIsImdldFZpZXdQb3J0IiwiSFRNTEVsZW1lbnQiLCJub2RlTmFtZSIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsImZpbmRPckNyZWF0ZUNhbnZhcyIsImdldENhbnZhc0FuZENvbnRleHQiLCJpbml0Q2FudmFzZXMiLCJjYW52YXNTaXplIiwiaW1hZ2UiLCJ2aWV3cG9ydCIsImNvbnRhaW5lciIsImFwcGVuZENoaWxkIiwiaW5wdXRTdHJlYW1GYWN0b3J5IiwiY3JlYXRlVmlkZW9TdHJlYW0iLCJjcmVhdGVMaXZlU3RyZWFtIiwiY3JlYXRlSW1hZ2VTdHJlYW0iLCJsb2FkZWQiLCJiYXNlVXJsIiwiZW5kZWQiLCJjYWxjdWxhdGVkV2lkdGgiLCJjYWxjdWxhdGVkSGVpZ2h0IiwiX2V2ZW50TmFtZXMiLCJfZXZlbnRIYW5kbGVycyIsImZyYW1lSWR4IiwicGF1c2VkIiwibG9hZEltYWdlcyIsIkdldFBpeGVscyIsIm1pbWUiLCJwaXhlbHMiLCJwdWJsaXNoRXZlbnQiLCJoYW5kbGVycyIsInRyaWdnZXIiLCJzZXRJbnB1dFN0cmVhbSIsInNldEN1cnJlbnRUaW1lIiwidGltZSIsImYiLCJjbGVhckV2ZW50SGFuZGxlcnMiLCJpbmQiLCJ0b3BSaWdodCIsInN6Iiwid29ya2VyUG9vbCIsInVwZGF0ZVdvcmtlcnMiLCJmcmFtZUdyYWJiZXIiLCJhdmFpbGFibGVXb3JrZXIiLCJ3b3JrZXJUaHJlYWQiLCJidXN5Iiwid29ya2VyIiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwibWVzc2FnZSIsIm9uUHJvY2Vzc2VkIiwid29ya2VySW50ZXJmYWNlUmVhZHkiLCJvbm1lc3NhZ2UiLCJnZW5lcmF0ZVdvcmtlckJsb2IiLCJibG9iIiwiZmFjdG9yeVNvdXJjZSIsIl9fZmFjdG9yeVNvdXJjZV9fIiwiQmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImluaXRXb3JrZXIiLCJjYiIsImJsb2JVUkwiLCJXb3JrZXIiLCJyZXZva2VPYmplY3RVUkwiLCJhZGp1c3RXb3JrZXJQb29sIiwiaW5jcmVhc2VCeSIsIndvcmtlcnNUb1Rlcm1pbmF0ZSIsInRlcm1pbmF0ZSIsIndvcmtlckluaXRpYWxpemVkIiwic2V0dXBJbnB1dFN0cmVhbSIsIklucHV0U3RyZWFtIiwibW92ZUJveCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyIiwibW92ZUxpbmUiLCJmcmFtZWdyYWJiZXIiLCJjYW52YXNDb250YWluZXIiLCJRV29ya2VycyIsImluaXRpYWxpemVEYXRhIiwicmVhZHkiLCJvblVJVGhyZWFkIiwid29ya2Vyc1VwZGF0ZWQiLCJsb2NhdGVBbmREZWNvZGUiLCJfaW5pdEJ1ZmZlcnMiLCJCYXJjb2RlRGVjb2RlciIsIl9nZXRWaWV3UG9ydCIsIl9pbml0Q2FudmFzIiwiaW5wdXRUeXBlIiwiQ2FtZXJhQWNjZXNzIiwiY2FuUmVjb3JkIiwiYmluZCIsImJhcmNvZGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJyZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJoYXNDb2RlUmVzdWx0IiwiZ2V0Qm91bmRpbmdCb3hlcyIsImRlY29kZVJlc3VsdCIsInB1Ymxpc2hSZXN1bHQiLCJpbWFnZVJlc3VsdCIsImRlbGF5Iiwic3RvcHBlZCIsInRpbWVzdGFtcCIsInVwZGF0ZSIsInBlcmZvcm1hbmNlIiwic3RhcnRDb250aW51b3VzVXBkYXRlIiwiX2NvbnRleHQiLCJRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSIsInF1YWdnYUluc3RhbmNlIiwicHJvbWlzZSIsIkNvbmZpZyIsImluaXRJbnB1dFN0cmVhbSIsIm9uRGV0ZWN0ZWQiLCJvZmZEZXRlY3RlZCIsIm9mZlByb2Nlc3NlZCIsInJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yIiwiZGVjb2RlU2luZ2xlIiwicmVzdWx0Q2FsbGJhY2siLCJkZWZhdWx0IiwiUmVzdWx0Q29sbGVjdG9yIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtR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LHVCQUFQO0FBQ0gsR0E3SDJCOztBQThINUJ0ZCxlQUFhLEVBQWJBLGNBOUg0QjtBQStINUJrYyxjQUFZLEVBQVpBLGFBL0g0QjtBQWdJNUI3SCxZQUFVLEVBQVZBLDhCQWhJNEI7QUFpSTVCenhDLGNBQVksRUFBWkEsZ0NBakk0QjtBQWtJNUJzN0MsaUJBQWUsRUFBZkEsZ0JBQWVBO0FBbElhLENBQWhDO0FBcUllWixtR0FBZixFLENBQ0EiLCJmaWxlIjoicXVhZ2dhLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA4OSk7XG4iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBFUFNJTE9OOiByZXF1aXJlKCcuL2Vwc2lsb24nKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJylcbiAgLCBmcm9tVmFsdWVzOiByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgc2V0OiByZXF1aXJlKCcuL3NldCcpXG4gICwgZXF1YWxzOiByZXF1aXJlKCcuL2VxdWFscycpXG4gICwgZXhhY3RFcXVhbHM6IHJlcXVpcmUoJy4vZXhhY3RFcXVhbHMnKVxuICAsIGFkZDogcmVxdWlyZSgnLi9hZGQnKVxuICAsIHN1YnRyYWN0OiByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiAgLCBzdWI6IHJlcXVpcmUoJy4vc3ViJylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgbXVsOiByZXF1aXJlKCcuL211bCcpXG4gICwgZGl2aWRlOiByZXF1aXJlKCcuL2RpdmlkZScpXG4gICwgZGl2OiByZXF1aXJlKCcuL2RpdicpXG4gICwgaW52ZXJzZTogcmVxdWlyZSgnLi9pbnZlcnNlJylcbiAgLCBtaW46IHJlcXVpcmUoJy4vbWluJylcbiAgLCBtYXg6IHJlcXVpcmUoJy4vbWF4JylcbiAgLCByb3RhdGU6IHJlcXVpcmUoJy4vcm90YXRlJylcbiAgLCBmbG9vcjogcmVxdWlyZSgnLi9mbG9vcicpXG4gICwgY2VpbDogcmVxdWlyZSgnLi9jZWlsJylcbiAgLCByb3VuZDogcmVxdWlyZSgnLi9yb3VuZCcpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHNjYWxlQW5kQWRkOiByZXF1aXJlKCcuL3NjYWxlQW5kQWRkJylcbiAgLCBkaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4gICwgZGlzdDogcmVxdWlyZSgnLi9kaXN0JylcbiAgLCBzcXVhcmVkRGlzdGFuY2U6IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiAgLCBzcXJEaXN0OiByZXF1aXJlKCcuL3NxckRpc3QnKVxuICAsIGxlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGgnKVxuICAsIGxlbjogcmVxdWlyZSgnLi9sZW4nKVxuICAsIHNxdWFyZWRMZW5ndGg6IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4gICwgc3FyTGVuOiByZXF1aXJlKCcuL3NxckxlbicpXG4gICwgbmVnYXRlOiByZXF1aXJlKCcuL25lZ2F0ZScpXG4gICwgbm9ybWFsaXplOiByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG4gICwgZG90OiByZXF1aXJlKCcuL2RvdCcpXG4gICwgY3Jvc3M6IHJlcXVpcmUoJy4vY3Jvc3MnKVxuICAsIGxlcnA6IHJlcXVpcmUoJy4vbGVycCcpXG4gICwgcmFuZG9tOiByZXF1aXJlKCcuL3JhbmRvbScpXG4gICwgdHJhbnNmb3JtTWF0MjogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQyJylcbiAgLCB0cmFuc2Zvcm1NYXQyZDogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQyZCcpXG4gICwgdHJhbnNmb3JtTWF0MzogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQzJylcbiAgLCB0cmFuc2Zvcm1NYXQ0OiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDQnKVxuICAsIGZvckVhY2g6IHJlcXVpcmUoJy4vZm9yRWFjaCcpXG4gICwgbGltaXQ6IHJlcXVpcmUoJy4vbGltaXQnKVxufVxuIiwiaW1wb3J0IHsgVHlwZWRBcnJheSB9IGZyb20gXCIuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgaW5pdDogZnVuY3Rpb24oYXJyOiBUeXBlZEFycmF5IHwgQXJyYXk8YW55PiwgdmFsOiBhbnkpIHtcclxuICAgICAgICAvLyBhcnIuZmlsbCh2YWwpO1xyXG4gICAgICAgIGxldCBsID0gYXJyLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIGFycltsXSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2h1ZmZsZXMgdGhlIGNvbnRlbnQgb2YgYW4gYXJyYXlcclxuICAgICAqL1xyXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24oYXJyOiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgbGV0IGkgPSBhcnIubGVuZ3RoIC0gMTtcclxuICAgICAgICBmb3IgKGk7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKTtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGFycltpXTtcclxuICAgICAgICAgICAgYXJyW2ldID0gYXJyW2pdO1xyXG4gICAgICAgICAgICBhcnJbal0gPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b1BvaW50TGlzdDogZnVuY3Rpb24oYXJyOiBBcnJheTxBcnJheTxudW1iZXI+Pikge1xyXG4gICAgICAgIGNvbnN0IHJvd3MgPSBhcnIucmVkdWNlKChwLCBuKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGBbJHtuLmpvaW4oJywnKX1dYDtcclxuICAgICAgICAgICAgcC5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH0sIFtdIGFzIEFycmF5PHN0cmluZz4pO1xyXG4gICAgICAgIHJldHVybiBgWyR7cm93cy5qb2luKCcsXFxyXFxuJyl9XWA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgZWxlbWVudHMgd2hpY2gncyBzY29yZSBpcyBiaWdnZXIgdGhhbiB0aGUgdGhyZXNob2xkXHJcbiAgICAgKi9cclxuICAgIHRocmVzaG9sZDogZnVuY3Rpb24oYXJyOiBBcnJheTxudW1iZXI+LCB0aHJlc2hvbGQ6IG51bWJlciwgc2NvcmVGdW5jOiAoKHNjb3JlOiBudW1iZXIpID0+IG51bWJlcikpIHtcclxuICAgICAgICBjb25zdCBxdWV1ZSA9IGFyci5yZWR1Y2UoKHByZXY6IEFycmF5PG51bWJlcj4sIG5leHQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNjb3JlRnVuYy5hcHBseShhcnIsIFtuZXh0XSkgPj0gdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2LnB1c2gobmV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIHJldHVybiBxdWV1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgbWF4SW5kZXg6IGZ1bmN0aW9uKGFycjogQXJyYXk8YW55Pikge1xyXG4gICAgICAgIGxldCBtYXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfSxcclxuXHJcbiAgICBtYXg6IGZ1bmN0aW9uKGFycjogQXJyYXk8YW55Pikge1xyXG4gICAgICAgIGxldCBtYXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IGFycltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfSxcclxuXHJcbiAgICBzdW06IGZ1bmN0aW9uKGFycjogQXJyYXk8YW55PiB8IFR5cGVkQXJyYXkpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBsZW5ndGggPSBhcnIubGVuZ3RoO1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICAgICAgc3VtICs9IGFycltsZW5ndGhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcclxuaW1wb3J0IHsgaHN2MnJnYiB9IGZyb20gJy4vY3ZfdXRpbHMnO1xyXG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xyXG5pbXBvcnQge1xyXG4gICAgWFlTaXplLFxyXG4gICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxyXG4gICAgVHlwZWRBcnJheSxcclxuICAgIFdyYXBwZXJJbmRleE1hcHBpbmcsXHJcbiAgICBNb21lbnQsXHJcbiAgICBTcGFyc2VJbWFnZVdyYXBwZXIsXHJcbn0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcblxyXG5jb25zdCB2ZWMyID0geyBjbG9uZSB9O1xyXG5cclxudHlwZSBQb3NpdGl2ZU51bWJlciA9IG51bWJlcjtcclxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyUG9zaXRpdmUodmFsOiBudW1iZXIpOiBhc3NlcnRzIHZhbCBpcyBQb3NpdGl2ZU51bWJlciB7XHJcbiAgICBpZiAodmFsIDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgcG9zaXRpdmUgbnVtYmVyLCByZWNlaXZlZCAke3ZhbH1gKTtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgSW1hZ2VXcmFwcGVyIGltcGxlbWVudHMgU3BhcnNlSW1hZ2VXcmFwcGVyIHtcclxuICAgIGRhdGE6IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+O1xyXG5cclxuICAgIHNpemU6IFhZU2l6ZTtcclxuXHJcbiAgICBpbmRleE1hcHBpbmc/OiBXcmFwcGVySW5kZXhNYXBwaW5nO1xyXG5cclxuICAgIC8vIFJlcHJlc2VudHMgYSBiYXNpYyBpbWFnZSBjb21iaW5pbmcgdGhlIGRhdGEgYW5kIHNpemUuIEluIGFkZGl0aW9uLCBzb21lIG1ldGhvZHMgZm9yXHJcbiAgICAvLyBtYW5pcHVsYXRpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4uXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBzaXplOiBYWVNpemUsXHJcbiAgICAgICAgZGF0YT86IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+LFxyXG4gICAgICAgIEFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3RvciA9IFVpbnQ4QXJyYXksXHJcbiAgICAgICAgaW5pdGlhbGl6ZT86IGJvb2xlYW4sXHJcbiAgICApIHtcclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IChBcnJheVR5cGUpKHNpemUueCAqIHNpemUueSk7XHJcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRlc3RzIGlmIGEgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBpbWFnZSwgZXh0ZW5kZWQgb3V0IGJ5IGEgYm9yZGVyIG9uIGVhY2ggc2lkZVxyXG4gICAgaW5JbWFnZVdpdGhCb3JkZXIoaW1nUmVmOiBYWVNpemUsIGJvcmRlcjogUG9zaXRpdmVOdW1iZXIgPSAwKTogYm9vbGVhbiB7XHJcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoYm9yZGVyKTtcclxuICAgICAgICAvLyBUT0RPOiBjb2RlXzEyOCBzdGFydHMgZmFpbGluZyBtaXNlcmFibHkgd2hlbiBpIG9ubHkgYWxsb3cgaW1nUmVmIHRvIGNvbnRhaW4gcG9zaXRpdmUgbnVtYmVycy5cclxuICAgICAgICAvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIG1lLCB3aHkgZG9lcyBpdCBnbyBuZWdhdGl2ZT8gIFRlc3RzIGFyZSBub3QgYWZmZWN0ZWQgYnlcclxuICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UsIGJ1dCB0aGUgd2hvbGUgY29kZV8xMjggcmVhZGVyIGJsb3dzIHVwIHdoZW4gaSB0aHJvdyBvbiBuZWdhdGl2ZSBpbWdSZWYuXHJcbiAgICAgICAgLy8gYXNzZXJ0TnVtYmVyUG9zaXRpdmUoaW1nUmVmLngpO1xyXG4gICAgICAgIC8vIGFzc2VydE51bWJlclBvc2l0aXZlKGltZ1JlZi55KTtcclxuICAgICAgICByZXR1cm4gKGltZ1JlZi54ID49IDApXHJcbiAgICAgICAgICAgICYmIChpbWdSZWYueSA+PSAwKVxyXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnggPCAodGhpcy5zaXplLnggKyAoYm9yZGVyICogMikpKVxyXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnkgPCAodGhpcy5zaXplLnkgKyAoYm9yZGVyICogMikpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb3B5IGZyb20gVEhJUyBJbWFnZVdyYXBwZXIgdG8gdGhlIG5ldyBpbWFnZVdyYXBwZXIgcGFyYW1ldGVyLCBzdGFydGluZyBhdCBmcm9tLCBzdG9wcGluZyBhdFxyXG4gICAgLy8gZW5kIG9mIG5ldyBpbWFnZVdyYXBwZXIgc2l6ZS5cclxuICAgIHN1YkltYWdlQXNDb3B5KGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyLCBmcm9tOiBYWVNpemUpOiBJbWFnZVdyYXBwZXIge1xyXG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueCk7XHJcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoZnJvbS55KTtcclxuICAgICAgICBjb25zdCB7IHg6IHNpemVYLCB5OiBzaXplWSB9ID0gaW1hZ2VXcmFwcGVyLnNpemU7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplWDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZVk7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YVt5ICogc2l6ZVggKyB4XSA9IHRoaXMuZGF0YVsoZnJvbS55ICsgeSkgKiB0aGlzLnNpemUueCArIGZyb20ueCArIHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbWFnZVdyYXBwZXI7XHJcbiAgICAgICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiByZWFsbHkgcHJvYmFibHkgc2hvdWxkIGNhbGwgaW50byBJbWFnZVdyYXBwZXIgc29tZXdoZXJlIHRvIG1ha2VcclxuICAgICAgICAvLyBzdXJlIHRoYXQgYWxsIG9mIGl0J3MgcGFyYW1ldGVycyBhcmUgc2V0IHByb3Blcmx5LCBzb21ldGhpbmcgbGlrZVxyXG4gICAgICAgIC8vIEltYWdlV3JhcHBlci5VcGRhdGVGcm9tKClcclxuICAgICAgICAvLyB0aGF0IG1pZ2h0IHRha2UgYSBwcm92aWRlZCBkYXRhIGFuZCBzaXplLCBhbmQgbWFrZSBzdXJlIHRoZXJlJ3Mgbm8gaW52YWxpZCBpbmRleE1hcHBpbmdcclxuICAgICAgICAvLyBoYW5naW5nIGFyb3VuZCwgYW5kIHN1Y2guXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZVxyXG4gICAgZ2V0KHg6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2UgKHNhZmUsIHdoYXRldmVyIHRoYXRcclxuICAgIC8vIG1lYW5zKVxyXG4gICAgZ2V0U2FmZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgLy8gY2FjaGUgaW5kZXhNYXBwaW5nIGJlY2F1c2UgaWYgd2UncmUgdXNpbmcgaXQgb25jZSwgd2UnbGwgcHJvYmFibHkgbmVlZCBpdCBhIGJ1bmNoIG1vcmVcclxuICAgICAgICAvLyB0b29cclxuICAgICAgICBpZiAoIXRoaXMuaW5kZXhNYXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nID0ge1xyXG4gICAgICAgICAgICAgICAgeDogW10sXHJcbiAgICAgICAgICAgICAgICB5OiBbXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2ldID0gaTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaSArIHRoaXMuc2l6ZS54XSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2ldID0gaTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaSArIHRoaXMuc2l6ZS55XSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsodGhpcy5pbmRleE1hcHBpbmcueVt5ICsgdGhpcy5zaXplLnldKSAqIHRoaXMuc2l6ZS54ICsgdGhpcy5pbmRleE1hcHBpbmcueFt4ICsgdGhpcy5zaXplLnhdXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXRzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gaW4gdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBncmF5c2NhbGUgdmFsdWVcclxuICAgIHNldCh4OiBudW1iZXIsIHk6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IEltYWdlV3JhcHBlciB7XHJcbiAgICAgICAgdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdID0gdmFsdWU7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldHMgdGhlIGJvcmRlciBvZiB0aGUgaW1hZ2UgKDEgcGl4ZWwpIHRvIHplcm9cclxuICAgIHplcm9Cb3JkZXIoKTogSW1hZ2VXcmFwcGVyIHtcclxuICAgICAgICBjb25zdCB7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSA9IHRoaXMuc2l6ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSB0aGlzLmRhdGFbKGhlaWdodCAtIDEpICogd2lkdGggKyBpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cclxuICAgICAgICAgICAgdGhpcy5kYXRhW2kgKiB3aWR0aF0gPSB0aGlzLmRhdGFbaSAqIHdpZHRoICsgKHdpZHRoIC0gMSldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gaXMgZW50aXJlbHkgdG9vIGxhcmdlIGZvciBtZSB0byByZWFzb24gb3V0IHJpZ2h0IGF0IHRoaXMgbW9tZW50IHRoYXQgaSdtIGhhbmRsaW5nXHJcbiAgICAvLyBhbGwgdGhlIHJlc3Qgb2YgaXQsIHNvIHRoaXMgaXMgYSB2ZXJiYXRpbSBjb3B5IG9mIHRoZSBqYXZhc2NyaXB0IHNvdXJjZSwgd2l0aCBvbmx5IHR3ZWFrc1xyXG4gICAgLy8gbmVjZXNzYXJ5IHRvIGdldCBpdCB0byBydW4sIG5vIHRob3VnaHQgcHV0IGludG8gaXQgeWV0LlxyXG4gICAgbW9tZW50cyhsYWJlbENvdW50OiBudW1iZXIpOiBBcnJheTxNb21lbnQ+IHtcclxuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IHg7XHJcbiAgICAgICAgbGV0IHk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5zaXplLnk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemUueDtcclxuICAgICAgICBsZXQgdmFsO1xyXG4gICAgICAgIGxldCB5c3E7XHJcbiAgICAgICAgY29uc3QgbGFiZWxTdW06IEFycmF5PE1vbWVudD4gPSBbXTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBsZXQgbGFiZWw7XHJcbiAgICAgICAgbGV0IG11MTE7XHJcbiAgICAgICAgbGV0IG11MDI7XHJcbiAgICAgICAgbGV0IG11MjA7XHJcbiAgICAgICAgbGV0IHhfO1xyXG4gICAgICAgIGxldCB5XztcclxuICAgICAgICBsZXQgdG1wO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8TW9tZW50PiA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHsgUEkgfSA9IE1hdGg7XHJcbiAgICAgICAgY29uc3QgUElfNCA9IFBJIC8gNDtcclxuXHJcbiAgICAgICAgaWYgKGxhYmVsQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsYWJlbFN1bVtpXSA9IHtcclxuICAgICAgICAgICAgICAgIG0wMDogMCxcclxuICAgICAgICAgICAgICAgIG0wMTogMCxcclxuICAgICAgICAgICAgICAgIG0xMDogMCxcclxuICAgICAgICAgICAgICAgIG0xMTogMCxcclxuICAgICAgICAgICAgICAgIG0wMjogMCxcclxuICAgICAgICAgICAgICAgIG0yMDogMCxcclxuICAgICAgICAgICAgICAgIHRoZXRhOiAwLFxyXG4gICAgICAgICAgICAgICAgcmFkOiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHlzcSA9IHkgKiB5O1xyXG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gZGF0YVt5ICogd2lkdGggKyB4XTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVt2YWwgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDAgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDEgKz0geTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTAgKz0geDtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTEgKz0geCAqIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAyICs9IHlzcTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMjAgKz0geCAqIHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVtpXTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGxhYmVsLm0wMCkgJiYgbGFiZWwubTAwICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB4XyA9IGxhYmVsLm0xMCAvIGxhYmVsLm0wMDtcclxuICAgICAgICAgICAgICAgIHlfID0gbGFiZWwubTAxIC8gbGFiZWwubTAwO1xyXG4gICAgICAgICAgICAgICAgbXUxMSA9IGxhYmVsLm0xMSAvIGxhYmVsLm0wMCAtIHhfICogeV87XHJcbiAgICAgICAgICAgICAgICBtdTAyID0gbGFiZWwubTAyIC8gbGFiZWwubTAwIC0geV8gKiB5XztcclxuICAgICAgICAgICAgICAgIG11MjAgPSBsYWJlbC5tMjAgLyBsYWJlbC5tMDAgLSB4XyAqIHhfO1xyXG4gICAgICAgICAgICAgICAgdG1wID0gKG11MDIgLSBtdTIwKSAvICgyICogbXUxMSk7XHJcbiAgICAgICAgICAgICAgICB0bXAgPSAwLjUgKiBNYXRoLmF0YW4odG1wKSArIChtdTExID49IDAgPyBQSV80IDogLVBJXzQpICsgUEk7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXHJcbiAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSA9ICh0bXAgKiAxODAgLyBQSSArIDkwKSAlIDE4MCAtIDkwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsLnRoZXRhIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhICs9IDE4MDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhYmVsLnJhZCA9IHRtcCA+IFBJID8gdG1wIC0gUEkgOiB0bXA7XHJcbiAgICAgICAgICAgICAgICBsYWJlbC52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyh0bXApLCBNYXRoLnNpbih0bXApXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm4gYSBVaW50OENsYW1wZWRBcnJheSBjb250YWluaW5nIHRoaXMgZ3JheXNjYWxlIGltYWdlIGNvbnZlcnRlZCB0byBSR0JBIGZvcm1cclxuICAgIGdldEFzUkdCQShzY2FsZSA9IDEuMCk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcclxuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCAqIHRoaXMuc2l6ZS54ICogdGhpcy5zaXplLnkpO1xyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplLnk7IHkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZS54OyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geSAqIHRoaXMuc2l6ZS54ICsgeDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldCh4LCB5KSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDBdID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAxXSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMl0gPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDNdID0gMjU1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGxheSB0aGlzIEltYWdlV3JhcHBlciBpbiBhIGdpdmVuIENhbnZhcyBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgc2NhbGVcclxuICAgIHNob3coY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGUgPSAxLjApOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBpZiAoIWN0eCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0QXNSR0JBKHNjYWxlKTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLnNpemUueDtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5zaXplLnk7XHJcbiAgICAgICAgY29uc3QgbmV3RnJhbWUgPSBuZXcgSW1hZ2VEYXRhKGRhdGEsIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xyXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEobmV3RnJhbWUsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BsYXlzIGEgc3BlY2lmaWVkIFN1YkltYWdlIGFyZWEgaW4gYSBnaXZlbiBjYW52YXMuIFRoaXMgZGlmZmVycyBkcmFzdGljYWxseSBmcm9tXHJcbiAgICAvLyBjcmVhdGluZyBhIG5ldyBTdWJJbWFnZSBhbmQgdXNpbmcgaXQncyBzaG93KCkgbWV0aG9kLiBXaHk/IEkgZG9uJ3QgaGF2ZSB0aGUgYW5zd2VyIHRvIHRoYXRcclxuICAgIC8vIHlldC4gIEkgc3VzcGVjdCB0aGUgSFNWL1JHQiBvcGVyYXRpb25zIGludm9sdmVkIGhlcmUgYXJlIG1ha2luZyBpdCBzaWduaWZpY2FudGx5IGRpZmZlcmVudCxcclxuICAgIC8vIGJ1dCB1bnRpbCBJIGNhbiB2aXN1YWxpemUgdGhlc2UgZnVuY3Rpb25zIHNpZGUgYnkgc2lkZSwgSSdtIGp1c3QgZ29pbmcgdG8gY29weSB0aGUgZXhpc3RpbmdcclxuICAgIC8vIGltcGxlbWVudGF0aW9uLlxyXG4gICAgb3ZlcmxheShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBpblNjYWxlOiBudW1iZXIsIGZyb206IFhZU2l6ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2NhbGUgPSAoaW5TY2FsZSA8IDAgfHwgaW5TY2FsZSA+IDM2MCkgPyAzNjAgOiBpblNjYWxlO1xyXG4gICAgICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcclxuICAgICAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XHJcbiAgICAgICAgY29uc3Qgd2hpdGVSZ2IgPSBbMjU1LCAyNTUsIDI1NV07XHJcbiAgICAgICAgY29uc3QgYmxhY2tSZ2IgPSBbMCwgMCwgMF07XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGlmICghY3R4KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoZnJvbS54LCBmcm9tLnksIHRoaXMuc2l6ZS54LCB0aGlzLnNpemUueSk7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBmcmFtZTtcclxuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IHRoaXMuZGF0YTtcclxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICAgICAgaHN2WzBdID0gdGhpcy5kYXRhW2xlbmd0aF0gKiBhZGp1c3RlZFNjYWxlO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgICAgICAgICAgcmVzdWx0ID0gaHN2WzBdIDw9IDAgPyB3aGl0ZVJnYiA6IGhzdlswXSA+PSAzNjAgPyBibGFja1JnYiA6IGhzdjJyZ2IoaHN2LCByZ2IpO1xyXG4gICAgICAgICAgICBjb25zdCBwb3MgPSBsZW5ndGggKiA0O1xyXG4gICAgICAgICAgICBbZGF0YVtwb3NdLCBkYXRhW3BvcyArIDFdLCBkYXRhW3BvcyArIDJdXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgZGF0YVtwb3MgKyAzXSA9IDI1NTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgZnJvbS54LCBmcm9tLnkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbWFnZVdyYXBwZXI7XHJcbiIsIi8vIFRPRE86IGNsdXN0ZXIuanMgYW5kIGN2X3V0aWxzLmpzIGFyZSBwcmV0dHkgdGlnaHRseSBpbnRlcnR3aW5lZCwgbWFraW5nIGZvciBhIGNvbXBsZXggY29udmVyc2lvblxyXG4vLyBpbnRvIHR5cGVzY3JpcHQuIGJlIHdhcm5lZC4gOi0pXHJcblxyXG5pbXBvcnQgeyBjbG9uZSwgZG90IH0gZnJvbSAnZ2wtdmVjMic7XHJcblxyXG5jb25zdCB2ZWMyID0geyBjbG9uZSwgZG90IH07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNsdXN0ZXIgZm9yIGdyb3VwaW5nIHNpbWlsYXIgb3JpZW50YXRpb25zIG9mIGRhdGFwb2ludHNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0ge1xyXG4gICAgICAgICAgICByYWQ6IDAsXHJcbiAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbMCwgMF0pLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcG9pbnRNYXAgPSB7fTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkKHBvaW50VG9BZGQpIHtcclxuICAgICAgICAgICAgcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0gPSBwb2ludFRvQWRkO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludFRvQWRkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNlbnRlcigpIHtcclxuICAgICAgICAgICAgbGV0IGk7IGxldFxyXG4gICAgICAgICAgICAgICAgc3VtID0gMDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IHBvaW50c1tpXS5yYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2VudGVyLnJhZCA9IHN1bSAvIHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNlbnRlci52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyhjZW50ZXIucmFkKSwgTWF0aC5zaW4oY2VudGVyLnJhZCldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgICAgICAgICAgIGFkZChwb2ludCk7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5pdCgpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhZGQocG9pbnRUb0FkZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludE1hcFtwb2ludFRvQWRkLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZml0cyhvdGhlclBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjb3NpbmUgc2ltaWxhcml0eSB0byBjZW50ZXItYW5nbGVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChvdGhlclBvaW50LnBvaW50LnZlYywgY2VudGVyLnZlYykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0UG9pbnRzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0Q2VudGVyKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVBvaW50KG5ld1BvaW50LCBpZCwgcHJvcGVydHkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByYWQ6IG5ld1BvaW50W3Byb3BlcnR5XSxcclxuICAgICAgICAgICAgcG9pbnQ6IG5ld1BvaW50LFxyXG4gICAgICAgICAgICBpZCxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbWl4ZWQtb3BlcmF0b3JzICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cclxuaW1wb3J0IHsgY2xvbmUgYXMgdjJjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xyXG5pbXBvcnQgeyBjbG9uZSBhcyB2M2Nsb25lIH0gZnJvbSAnZ2wtdmVjMyc7XHJcbmltcG9ydCBDbHVzdGVyMiBmcm9tICcuL2NsdXN0ZXInO1xyXG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xyXG5cclxuY29uc3QgdmVjMiA9IHsgY2xvbmU6IHYyY2xvbmUgfTtcclxuY29uc3QgdmVjMyA9IHsgY2xvbmU6IHYzY2xvbmUgfTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcclxuICogQHBhcmFtIHkgeS1jb29yZGluYXRlXHJcbiAqIEByZXR1cm4gSW1hZ2VSZWZlcmVuY2Uge3gseX0gQ29vcmRpbmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGltYWdlUmVmKHgsIHkpIHtcclxuICAgIGNvbnN0IHRoYXQgPSB7XHJcbiAgICAgICAgeCxcclxuICAgICAgICB5LFxyXG4gICAgICAgIHRvVmVjMigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzIuY2xvbmUoW3RoaXMueCwgdGhpcy55XSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1ZlYzMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm91bmQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy54ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy54IC0gMC41KTtcclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy55ID4gMC4wID8gTWF0aC5mbG9vcih0aGlzLnkgKyAwLjUpIDogTWF0aC5mbG9vcih0aGlzLnkgLSAwLjUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHJldHVybiB0aGF0O1xyXG59XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgYW4gaW50ZWdyYWwgaW1hZ2Ugb2YgYSBnaXZlbiBncmF5c2NhbGUgaW1hZ2UuXHJcbiAqIEBwYXJhbSBpbWFnZURhdGFDb250YWluZXIge0ltYWdlRGF0YUNvbnRhaW5lcn0gdGhlIGltYWdlIHRvIGJlIGludGVncmF0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZTIoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcclxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XHJcbiAgICBsZXQgc3VtID0gMDsgbGV0IHBvc0EgPSAwOyBsZXQgcG9zQiA9IDA7IGxldCBwb3NDID0gMDsgbGV0IHBvc0QgPSAwOyBsZXQgeDsgbGV0XHJcbiAgICAgICAgeTtcclxuXHJcbiAgICAvLyBzdW0gdXAgZmlyc3QgY29sdW1uXHJcbiAgICBwb3NCID0gd2lkdGg7XHJcbiAgICBzdW0gPSAwO1xyXG4gICAgZm9yICh5ID0gMTsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcclxuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArPSBzdW07XHJcbiAgICAgICAgcG9zQSArPSB3aWR0aDtcclxuICAgICAgICBwb3NCICs9IHdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIHBvc0EgPSAwO1xyXG4gICAgcG9zQiA9IDE7XHJcbiAgICBzdW0gPSAwO1xyXG4gICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3Bvc0FdO1xyXG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICs9IHN1bTtcclxuICAgICAgICBwb3NBKys7XHJcbiAgICAgICAgcG9zQisrO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoeSA9IDE7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIHBvc0EgPSB5ICogd2lkdGggKyAxO1xyXG4gICAgICAgIHBvc0IgPSAoeSAtIDEpICogd2lkdGggKyAxO1xyXG4gICAgICAgIHBvc0MgPSB5ICogd2lkdGg7XHJcbiAgICAgICAgcG9zRCA9ICh5IC0gMSkgKiB3aWR0aDtcclxuICAgICAgICBmb3IgKHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NBXVxyXG4gICAgICAgICAgICAgICAgKz0gaW1hZ2VEYXRhW3Bvc0FdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NDXSAtIGludGVncmFsSW1hZ2VEYXRhW3Bvc0RdO1xyXG4gICAgICAgICAgICBwb3NBKys7XHJcbiAgICAgICAgICAgIHBvc0IrKztcclxuICAgICAgICAgICAgcG9zQysrO1xyXG4gICAgICAgICAgICBwb3NEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcclxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuXHJcbiAgICAvLyBzdW0gdXAgZmlyc3Qgcm93XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW2ldO1xyXG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW2ldID0gc3VtO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IHYgPSAxOyB2IDwgaGVpZ2h0OyB2KyspIHtcclxuICAgICAgICBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xyXG4gICAgICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xyXG4gICAgICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSBzdW0gKyBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIDEpICogd2lkdGggKyB1XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcikge1xyXG4gICAgaWYgKCF0YXJnZXRXcmFwcGVyKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcclxuICAgIH1cclxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhOyBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTsgY29uc3RcclxuICAgICAgICB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xyXG5cclxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSGlzdG9ncmFtKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKSB7XHJcbiAgICBpZiAoIWJpdHNQZXJQaXhlbCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGJpdHNQZXJQaXhlbCA9IDg7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VEYXRhO1xyXG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xyXG4gICAgY29uc3QgYnVja2V0Q250ID0gMSA8PCBiaXRzUGVyUGl4ZWw7XHJcbiAgICBjb25zdCBoaXN0ID0gbmV3IEludDMyQXJyYXkoYnVja2V0Q250KTtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICBoaXN0W2ltYWdlRGF0YVtsZW5ndGhdID4+IGJpdFNoaWZ0XSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhpc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaGFycGVuTGluZShsaW5lKSB7XHJcbiAgICBsZXQgaTtcclxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBsaW5lO1xyXG4gICAgbGV0IGxlZnQgPSBsaW5lWzBdO1xyXG4gICAgbGV0IGNlbnRlciA9IGxpbmVbMV07XHJcbiAgICBsZXQgcmlnaHQ7XHJcblxyXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIHJpZ2h0ID0gbGluZVtpICsgMV07XHJcbiAgICAgICAgLy8gIC0xIDQgLTEga2VybmVsXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgbGluZVtpIC0gMV0gPSAoKChjZW50ZXIgKiAyKSAtIGxlZnQgLSByaWdodCkpICYgMjU1O1xyXG4gICAgICAgIGxlZnQgPSBjZW50ZXI7XHJcbiAgICAgICAgY2VudGVyID0gcmlnaHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGluZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwgPSA4KSB7XHJcbiAgICBsZXQgaGlzdDtcclxuICAgIGNvbnN0IGJpdFNoaWZ0ID0gOCAtIGJpdHNQZXJQaXhlbDtcclxuXHJcbiAgICBmdW5jdGlvbiBweChpbml0LCBlbmQpIHtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gKz0gaGlzdFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtICs9IGkgKiBoaXN0W2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZXRlcm1pbmVUaHJlc2hvbGQoKSB7XHJcbiAgICAgICAgY29uc3QgdmV0ID0gWzBdO1xyXG4gICAgICAgIGxldCBwMTtcclxuICAgICAgICBsZXQgcDI7XHJcbiAgICAgICAgbGV0IHAxMjtcclxuICAgICAgICBsZXQgbTE7XHJcbiAgICAgICAgbGV0IG0yO1xyXG4gICAgICAgIGxldCBtMTI7XHJcbiAgICAgICAgY29uc3QgbWF4ID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XHJcblxyXG4gICAgICAgIGhpc3QgPSBjb21wdXRlSGlzdG9ncmFtKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKTtcclxuICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IG1heDsgaysrKSB7XHJcbiAgICAgICAgICAgIHAxID0gcHgoMCwgayk7XHJcbiAgICAgICAgICAgIHAyID0gcHgoayArIDEsIG1heCk7XHJcbiAgICAgICAgICAgIHAxMiA9IHAxICogcDI7XHJcbiAgICAgICAgICAgIGlmIChwMTIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHAxMiA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbTEgPSBteCgwLCBrKSAqIHAyO1xyXG4gICAgICAgICAgICBtMiA9IG14KGsgKyAxLCBtYXgpICogcDE7XHJcbiAgICAgICAgICAgIG0xMiA9IG0xIC0gbTI7XHJcbiAgICAgICAgICAgIHZldFtrXSA9IG0xMiAqIG0xMiAvIHAxMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFycmF5SGVscGVyLm1heEluZGV4KHZldCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lVGhyZXNob2xkKCk7XHJcbiAgICByZXR1cm4gdGhyZXNob2xkIDw8IGJpdFNoaWZ0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcclxuICAgIGNvbnN0IHRocmVzaG9sZCA9IGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyKTtcclxuXHJcbiAgICB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcik7XHJcbiAgICByZXR1cm4gdGhyZXNob2xkO1xyXG59XHJcblxyXG4vLyBsb2NhbCB0aHJlc2hvbGRpbmdcclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xyXG4gICAgY29tcHV0ZUludGVncmFsSW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpO1xyXG5cclxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IHRhcmdldERhdGEgPSB0YXJnZXRXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xyXG4gICAgY29uc3QgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcclxuICAgIGxldCBzdW0gPSAwOyBsZXQgdjsgbGV0IHU7IGNvbnN0IGtlcm5lbCA9IDM7IGxldCBBOyBsZXQgQjsgbGV0IEM7IGxldCBEOyBsZXQgYXZnOyBjb25zdFxyXG4gICAgICAgIHNpemUgPSAoa2VybmVsICogMiArIDEpICogKGtlcm5lbCAqIDIgKyAxKTtcclxuXHJcbiAgICAvLyBjbGVhciBvdXQgdG9wICYgYm90dG9tLWJvcmRlclxyXG4gICAgZm9yICh2ID0gMDsgdiA8PSBrZXJuZWw7IHYrKykge1xyXG4gICAgICAgIGZvciAodSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XHJcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcclxuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKChoZWlnaHQgLSAxKSAtIHYpICogd2lkdGgpICsgdV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjbGVhciBvdXQgbGVmdCAmIHJpZ2h0IGJvcmRlclxyXG4gICAgZm9yICh2ID0ga2VybmVsOyB2IDwgaGVpZ2h0IC0ga2VybmVsOyB2KyspIHtcclxuICAgICAgICBmb3IgKHUgPSAwOyB1IDw9IGtlcm5lbDsgdSsrKSB7XHJcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcclxuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgKHdpZHRoIC0gMSAtIHUpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAodiA9IGtlcm5lbCArIDE7IHYgPCBoZWlnaHQgLSBrZXJuZWwgLSAxOyB2KyspIHtcclxuICAgICAgICBmb3IgKHUgPSBrZXJuZWwgKyAxOyB1IDwgd2lkdGggLSBrZXJuZWw7IHUrKykge1xyXG4gICAgICAgICAgICBBID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XHJcbiAgICAgICAgICAgIEIgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIGtlcm5lbCAtIDEpICogd2lkdGggKyAodSArIGtlcm5lbCldO1xyXG4gICAgICAgICAgICBDID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgKyBrZXJuZWwpICogd2lkdGggKyAodSAtIGtlcm5lbCAtIDEpXTtcclxuICAgICAgICAgICAgRCA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcclxuICAgICAgICAgICAgc3VtID0gRCAtIEMgLSBCICsgQTtcclxuICAgICAgICAgICAgYXZnID0gc3VtIC8gKHNpemUpO1xyXG4gICAgICAgICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gKGF2ZyArIDUpID8gMCA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2x1c3Rlcihwb2ludHMsIHRocmVzaG9sZCwgcHJvcGVydHkpIHtcclxuICAgIGxldCBpOyBsZXQgazsgbGV0IHRoaXNDbHVzdGVyOyBsZXQgcG9pbnQ7IGNvbnN0XHJcbiAgICAgICAgY2x1c3RlcnMgPSBbXTtcclxuXHJcbiAgICBpZiAoIXByb3BlcnR5KSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgcHJvcGVydHkgPSAncmFkJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRUb0NsdXN0ZXIobmV3UG9pbnQpIHtcclxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY2x1c3RlcnMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgdGhpc0NsdXN0ZXIgPSBjbHVzdGVyc1trXTtcclxuICAgICAgICAgICAgaWYgKHRoaXNDbHVzdGVyLmZpdHMobmV3UG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzQ2x1c3Rlci5hZGQobmV3UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpdGVyYXRlIG92ZXIgZWFjaCBjbG91ZFxyXG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBvaW50ID0gQ2x1c3RlcjIuY3JlYXRlUG9pbnQocG9pbnRzW2ldLCBpLCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgaWYgKCFhZGRUb0NsdXN0ZXIocG9pbnQpKSB7XHJcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQ2x1c3RlcjIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2x1c3RlcnM7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBUcmFjZXIgPSB7XHJcbiAgICB0cmFjZShwb2ludHMsIHZlYykge1xyXG4gICAgICAgIGxldCBpdGVyYXRpb247XHJcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwO1xyXG4gICAgICAgIGxldCB0b3AgPSBbXTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IGNlbnRlclBvcyA9IDA7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSAwO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB0cmFjZShpZHgsIGZvcndhcmQpIHtcclxuICAgICAgICAgICAgbGV0IHRvO1xyXG4gICAgICAgICAgICBsZXQgdG9JZHg7XHJcbiAgICAgICAgICAgIGxldCBwcmVkaWN0ZWRQb3M7XHJcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZFggPSAxO1xyXG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRZID0gTWF0aC5hYnModmVjWzFdIC8gMTApO1xyXG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoKHBvcywgcHJlZGljdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zLnggPiAocHJlZGljdGVkLnggLSB0aHJlc2hvbGRYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3MueCA8IChwcmVkaWN0ZWQueCArIHRocmVzaG9sZFgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55ID4gKHByZWRpY3RlZC55IC0gdGhyZXNob2xkWSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPCAocHJlZGljdGVkLnkgKyB0aHJlc2hvbGRZKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCBpbmRleCBpcyB3aXRoaW4gdGhlIHZlYyBzcGVjaWZpY2F0aW9uc1xyXG4gICAgICAgICAgICAvLyBpZiBub3QsIGNoZWNrIGFzIGxvbmcgYXMgdGhlIHRocmVzaG9sZCBpcyBtZXRcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBwb2ludHNbaWR4XTtcclxuICAgICAgICAgICAgaWYgKGZvcndhcmQpIHtcclxuICAgICAgICAgICAgICAgIHByZWRpY3RlZFBvcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55ICsgdmVjWzFdLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByZWRpY3RlZFBvcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggLSB2ZWNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55IC0gdmVjWzFdLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdG9JZHggPSBmb3J3YXJkID8gaWR4ICsgMSA6IGlkeCAtIDE7XHJcbiAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXHJcbiAgICAgICAgICAgIHdoaWxlICh0byAmJiAoZm91bmQgPSBtYXRjaCh0bywgcHJlZGljdGVkUG9zKSkgIT09IHRydWUgJiYgKE1hdGguYWJzKHRvLnkgLSBmcm9tLnkpIDwgdmVjWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgdG9JZHggPSBmb3J3YXJkID8gdG9JZHggKyAxIDogdG9JZHggLSAxO1xyXG4gICAgICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XHJcbiAgICAgICAgICAgIC8vIHJhbmRvbWx5IHNlbGVjdCBwb2ludCB0byBzdGFydCB3aXRoXHJcbiAgICAgICAgICAgIGNlbnRlclBvcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvaW50cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgLy8gdHJhY2UgZm9yd2FyZFxyXG4gICAgICAgICAgICB0b3AgPSBbXTtcclxuICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcclxuICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXHJcbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIHRydWUpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0b3AubGVuZ3RoID4gcmVzdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IERJTEFURSA9IDE7XHJcbmV4cG9ydCBjb25zdCBFUk9ERSA9IDI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGlsYXRlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcclxuICAgIGxldCB2O1xyXG4gICAgbGV0IHU7XHJcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgbGV0IHN1bTtcclxuICAgIGxldCB5U3RhcnQxO1xyXG4gICAgbGV0IHlTdGFydDI7XHJcbiAgICBsZXQgeFN0YXJ0MTtcclxuICAgIGxldCB4U3RhcnQyO1xyXG5cclxuICAgIGZvciAodiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcclxuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcclxuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xyXG4gICAgICAgICAgICB5U3RhcnQyID0gdiArIDE7XHJcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcclxuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xyXG4gICAgICAgICAgICBzdW0gPSBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDJdXHJcbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cclxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xyXG4gICAgICAgICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPiAwID8gMSA6IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVdyYXBwZXIsIG91dEltYWdlV3JhcHBlcikge1xyXG4gICAgbGV0IHY7XHJcbiAgICBsZXQgdTtcclxuICAgIGNvbnN0IGluSW1hZ2VEYXRhID0gaW5JbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55O1xyXG4gICAgY29uc3Qgd2lkdGggPSBpbkltYWdlV3JhcHBlci5zaXplLng7XHJcbiAgICBsZXQgc3VtO1xyXG4gICAgbGV0IHlTdGFydDE7XHJcbiAgICBsZXQgeVN0YXJ0MjtcclxuICAgIGxldCB4U3RhcnQxO1xyXG4gICAgbGV0IHhTdGFydDI7XHJcblxyXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xyXG4gICAgICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xyXG4gICAgICAgICAgICB5U3RhcnQxID0gdiAtIDE7XHJcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcclxuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xyXG4gICAgICAgICAgICB4U3RhcnQyID0gdSArIDE7XHJcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cclxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XVxyXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0Ml07XHJcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA9PT0gNSA/IDEgOiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xyXG4gICAgaWYgKCFyZXN1bHRJbWFnZVdyYXBwZXIpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xyXG4gICAgfVxyXG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3QgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gLSBiSW1hZ2VEYXRhW2xlbmd0aF07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlV3JhcHBlciwgYkltYWdlV3JhcHBlciwgcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIHJlc3VsdEltYWdlV3JhcHBlciA9IGFJbWFnZVdyYXBwZXI7XHJcbiAgICB9XHJcbiAgICBsZXQgeyBsZW5ndGggfSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGFJbWFnZURhdGEgPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3QgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xyXG5cclxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSB8fCBiSW1hZ2VEYXRhW2xlbmd0aF07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VXcmFwcGVyKSB7XHJcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3QgeyBkYXRhIH0gPSBpbWFnZVdyYXBwZXI7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICBzdW0gKz0gZGF0YVtsZW5ndGhdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1bTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvcEdlbmVyaWMobGlzdCwgdG9wLCBzY29yZUZ1bmMpIHtcclxuICAgIGxldCBpOyBsZXQgbWluSWR4ID0gMDsgbGV0IG1pbiA9IDA7IGNvbnN0IHF1ZXVlID0gW107IGxldCBzY29yZTsgbGV0IGhpdDsgbGV0XHJcbiAgICAgICAgcG9zO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0b3A7IGkrKykge1xyXG4gICAgICAgIHF1ZXVlW2ldID0ge1xyXG4gICAgICAgICAgICBzY29yZTogMCxcclxuICAgICAgICAgICAgaXRlbTogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc2NvcmUgPSBzY29yZUZ1bmMuYXBwbHkodGhpcywgW2xpc3RbaV1dKTtcclxuICAgICAgICBpZiAoc2NvcmUgPiBtaW4pIHtcclxuICAgICAgICAgICAgaGl0ID0gcXVldWVbbWluSWR4XTtcclxuICAgICAgICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XHJcbiAgICAgICAgICAgIGhpdC5pdGVtID0gbGlzdFtpXTtcclxuICAgICAgICAgICAgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbcG9zXS5zY29yZSA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHF1ZXVlW3Bvc10uc2NvcmU7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluSWR4ID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBxdWV1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21JbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIGN0eCwgYXJyYXkpIHtcclxuICAgIGN0eC5kcmF3SW1hZ2UoaHRtbEltYWdlLCBvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpO1xyXG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KS5kYXRhO1xyXG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XHJcbiAgICBjb25zdCBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksIHNpemUueCwgc2l6ZS55KS5kYXRhO1xyXG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YShjYW52YXNEYXRhLCBzaXplLCBvdXRBcnJheSkge1xyXG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XHJcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gc2l6ZS54O1xyXG4gICAgY29uc3QgZW5kSWR4ID0gTWF0aC5mbG9vcihjYW52YXNEYXRhLmxlbmd0aCAvIDQpO1xyXG4gICAgY29uc3Qgb3V0V2lkdGggPSBzaXplLnggLyAyO1xyXG4gICAgbGV0IG91dEltZ0lkeCA9IDA7XHJcbiAgICBjb25zdCBpbldpZHRoID0gc2l6ZS54O1xyXG4gICAgbGV0IGk7XHJcblxyXG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbWdJZHhdID0gKFxyXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMF1cclxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMV1cclxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMl0pXHJcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDBdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDFdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDJdKVxyXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDBdXHJcbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCkgKiA0ICsgMV1cclxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAyXSlcclxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF1cclxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMV1cclxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMl0pKSAvIDQ7XHJcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xyXG4gICAgICAgICAgICB0b3BSb3dJZHggKz0gMjtcclxuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvcFJvd0lkeCArPSBpbldpZHRoO1xyXG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUdyYXkoaW1hZ2VEYXRhLCBvdXRBcnJheSwgY29uZmlnKSB7XHJcbiAgICBjb25zdCBsID0gKGltYWdlRGF0YS5sZW5ndGggLyA0KSB8IDA7XHJcbiAgICBjb25zdCBzaW5nbGVDaGFubmVsID0gY29uZmlnICYmIGNvbmZpZy5zaW5nbGVDaGFubmVsID09PSB0cnVlO1xyXG5cclxuICAgIGlmIChzaW5nbGVDaGFubmVsKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgIG91dEFycmF5W2ldID0gaW1hZ2VEYXRhW2kgKiA0ICsgMF07XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSAwLjI5OSAqIGltYWdlRGF0YVtpICogNCArIDBdICsgMC41ODcgKiBpbWFnZURhdGFbaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW2kgKiA0ICsgMl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbG9hZEltYWdlQXJyYXkoc3JjLCBjYWxsYmFjaywgY2FudmFzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpIHtcclxuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgaW1nLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XHJcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayhhcnJheSwge1xyXG4gICAgICAgICAgICB4OiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCxcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBpbWcuc3JjID0gc3JjO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIGluSW1nIHtJbWFnZVdyYXBwZXJ9IGlucHV0IGltYWdlIHRvIGJlIHNhbXBsZWRcclxuICogQHBhcmFtIG91dEltZyB7SW1hZ2VXcmFwcGVyfSB0byBiZSBzdG9yZWQgaW5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoYWxmU2FtcGxlKGluSW1nV3JhcHBlciwgb3V0SW1nV3JhcHBlcikge1xyXG4gICAgY29uc3QgaW5JbWcgPSBpbkltZ1dyYXBwZXIuZGF0YTtcclxuICAgIGNvbnN0IGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xyXG4gICAgY29uc3Qgb3V0SW1nID0gb3V0SW1nV3JhcHBlci5kYXRhO1xyXG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XHJcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcclxuICAgIGNvbnN0IGVuZElkeCA9IGluSW1nLmxlbmd0aDtcclxuICAgIGNvbnN0IG91dFdpZHRoID0gaW5XaWR0aCAvIDI7XHJcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcclxuICAgIHdoaWxlIChib3R0b21Sb3dJZHggPCBlbmRJZHgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxyXG4gICAgICAgICAgICAgICAgKGluSW1nW3RvcFJvd0lkeF0gKyBpbkltZ1t0b3BSb3dJZHggKyAxXSArIGluSW1nW2JvdHRvbVJvd0lkeF0gKyBpbkltZ1tib3R0b21Sb3dJZHggKyAxXSkgLyA0LFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcclxuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XHJcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcclxuICAgICAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IgPSBbMCwgMCwgMF0pIHtcclxuICAgIGNvbnN0IGggPSBoc3ZbMF07XHJcbiAgICBjb25zdCBzID0gaHN2WzFdO1xyXG4gICAgY29uc3QgdiA9IGhzdlsyXTtcclxuICAgIGNvbnN0IGMgPSB2ICogcztcclxuICAgIGNvbnN0IHggPSBjICogKDEgLSBNYXRoLmFicygoaCAvIDYwKSAlIDIgLSAxKSk7XHJcbiAgICBjb25zdCBtID0gdiAtIGM7XHJcbiAgICBsZXQgciA9IDA7XHJcbiAgICBsZXQgZyA9IDA7XHJcbiAgICBsZXQgYiA9IDA7XHJcblxyXG4gICAgaWYgKGggPCA2MCkge1xyXG4gICAgICAgIHIgPSBjO1xyXG4gICAgICAgIGcgPSB4O1xyXG4gICAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XHJcbiAgICAgICAgciA9IHg7XHJcbiAgICAgICAgZyA9IGM7XHJcbiAgICB9IGVsc2UgaWYgKGggPCAxODApIHtcclxuICAgICAgICBnID0gYztcclxuICAgICAgICBiID0geDtcclxuICAgIH0gZWxzZSBpZiAoaCA8IDI0MCkge1xyXG4gICAgICAgIGcgPSB4O1xyXG4gICAgICAgIGIgPSBjO1xyXG4gICAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XHJcbiAgICAgICAgciA9IHg7XHJcbiAgICAgICAgYiA9IGM7XHJcbiAgICB9IGVsc2UgaWYgKGggPCAzNjApIHtcclxuICAgICAgICByID0gYztcclxuICAgICAgICBiID0geDtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgcmdiWzBdID0gKChyICsgbSkgKiAyNTUpIHwgMDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgcmdiWzJdID0gKChiICsgbSkgKiAyNTUpIHwgMDtcclxuICAgIHJldHVybiByZ2I7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcclxuICAgIGNvbnN0IGxhcmdlRGl2aXNvcnMgPSBbXTtcclxuICAgIGNvbnN0IGRpdmlzb3JzID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBNYXRoLnNxcnQobikgKyAxOyBpKyspIHtcclxuICAgICAgICBpZiAobiAlIGkgPT09IDApIHtcclxuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcclxuICAgICAgICAgICAgaWYgKGkgIT09IG4gLyBpKSB7XHJcbiAgICAgICAgICAgICAgICBsYXJnZURpdmlzb3JzLnVuc2hpZnQoTWF0aC5mbG9vcihuIC8gaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgbGV0IGogPSAwO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcblxyXG4gICAgd2hpbGUgKGkgPCBhcnIxLmxlbmd0aCAmJiBqIDwgYXJyMi5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnIxW2ldKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhcnIxW2ldID4gYXJyMltqXSkge1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQYXRjaFNpemUocGF0Y2hTaXplLCBpbWdTaXplKSB7XHJcbiAgICBjb25zdCBkaXZpc29yc1ggPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueCk7XHJcbiAgICBjb25zdCBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSk7XHJcbiAgICBjb25zdCB3aWRlU2lkZSA9IE1hdGgubWF4KGltZ1NpemUueCwgaW1nU2l6ZS55KTtcclxuICAgIGNvbnN0IGNvbW1vbiA9IF9jb21wdXRlSW50ZXJzZWN0aW9uKGRpdmlzb3JzWCwgZGl2aXNvcnNZKTtcclxuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXTtcclxuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTWFwID0ge1xyXG4gICAgICAgICd4LXNtYWxsJzogNSxcclxuICAgICAgICBzbWFsbDogNCxcclxuICAgICAgICBtZWRpdW06IDMsXHJcbiAgICAgICAgbGFyZ2U6IDIsXHJcbiAgICAgICAgJ3gtbGFyZ2UnOiAxLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IG5yT2ZQYXRjaGVzSWR4ID0gbnJPZlBhdGNoZXNNYXBbcGF0Y2hTaXplXSB8fCBuck9mUGF0Y2hlc01hcC5tZWRpdW07XHJcbiAgICBjb25zdCBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF07XHJcbiAgICBjb25zdCBkZXNpcmVkUGF0Y2hTaXplID0gTWF0aC5mbG9vcih3aWRlU2lkZSAvIG5yT2ZQYXRjaGVzKTtcclxuICAgIGxldCBvcHRpbWFsUGF0Y2hTaXplO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhkaXZpc29ycykge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBsZXQgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGkgPCAoZGl2aXNvcnMubGVuZ3RoIC0gMSkgJiYgZGl2aXNvcnNbaV0gPCBkZXNpcmVkUGF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaSAtIDFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdXHJcbiAgICAgICAgICAgICYmIGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA+IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCAtIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBmb3VuZCwgeTogZm91bmQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhjb21tb24pO1xyXG4gICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XHJcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XHJcbiAgICAgICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoKF9jb21wdXRlRGl2aXNvcnMoZGVzaXJlZFBhdGNoU2l6ZSAqIG5yT2ZQYXRjaGVzKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvcHRpbWFsUGF0Y2hTaXplO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBkaW1lbnNpb24gPSB7XHJcbiAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUpLFxyXG4gICAgICAgIHVuaXQ6IHZhbHVlLmluZGV4T2YoJyUnKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSA/ICclJyA6ICclJyxcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IF9kaW1lbnNpb25zQ29udmVydGVycyA9IHtcclxuICAgIHRvcChkaW1lbnNpb24sIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC5oZWlnaHQgKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xyXG4gICAgfSxcclxuICAgIHJpZ2h0KGRpbWVuc2lvbiwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LndpZHRoIC0gKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkpIDogbnVsbDtcclxuICAgIH0sXHJcbiAgICBib3R0b20oZGltZW5zaW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0IC0gKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XHJcbiAgICB9LFxyXG4gICAgbGVmdChkaW1lbnNpb24sIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSA6IG51bGw7XHJcbiAgICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbWFnZUFyZWEoaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIGFyZWEpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB7IHdpZHRoOiBpbnB1dFdpZHRoLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH07XHJcblxyXG4gICAgY29uc3QgcGFyc2VkQXJlYSA9IE9iamVjdC5rZXlzKGFyZWEpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZWFba2V5XTtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWQgPSBfZGltZW5zaW9uc0NvbnZlcnRlcnNba2V5XShwYXJzZWQsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICByZXN1bHRba2V5XSA9IGNhbGN1bGF0ZWQ7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sIHt9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN4OiBwYXJzZWRBcmVhLmxlZnQsXHJcbiAgICAgICAgc3k6IHBhcnNlZEFyZWEudG9wLFxyXG4gICAgICAgIHN3OiBwYXJzZWRBcmVhLnJpZ2h0IC0gcGFyc2VkQXJlYS5sZWZ0LFxyXG4gICAgICAgIHNoOiBwYXJzZWRBcmVhLmJvdHRvbSAtIHBhcnNlZEFyZWEudG9wLFxyXG4gICAgfTtcclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwiaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcblxyXG4vLyBUT0RPOiBYWVBvc2l0aW9uIHNob3VsZCBiZSBhbiBYWU9iamVjdCwgYnV0IHRoYXQgYnJlYWtzIFhZRGVmaW5pdGlvbiwgd2hpY2ggYnJlYWtzIGRyYXdQYXRoKCkgYmVsb3cuXHJcbmRlY2xhcmUgaW50ZXJmYWNlIFhZUG9zaXRpb24ge1xyXG4gICAgeDogbnVtYmVyO1xyXG4gICAgeTogbnVtYmVyO1xyXG59XHJcblxyXG5kZWNsYXJlIGludGVyZmFjZSBDYW52YXNTdHlsZSB7XHJcbiAgICBjb2xvcjogc3RyaW5nO1xyXG4gICAgbGluZVdpZHRoOiBudW1iZXI7XHJcbn1cclxuXHJcbi8vIFhZRGVmaW5pdGlvbiB0ZWxscyB1cyB3aGljaCBjb21wb25lbnQgb2YgYSBnaXZlbiBhcnJheSBvciBvYmplY3QgaXMgdGhlIFwiWFwiIGFuZCB3aGljaCBpcyB0aGUgXCJZXCIuXHJcbi8vIFVzdWFsbHkgdGhpcyBpcyAwIGZvciBYIGFuZCAxIGZvciBZLCBidXQgbWlnaHQgYmUgdXNlZCBhcyAneCcgZm9yIHggYW5kICd5JyBmb3IgWS5cclxuZGVjbGFyZSBpbnRlcmZhY2UgWFlEZWZpbml0aW9uIHtcclxuICAgIHg6IGtleW9mIFhZUG9zaXRpb247XHJcbiAgICB5OiBrZXlvZiBYWVBvc2l0aW9uO1xyXG59XHJcblxyXG5kZWNsYXJlIHR5cGUgUGF0aCA9IEFycmF5PFhZUG9zaXRpb24+O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgZHJhd1JlY3QocG9zOiBYWVBvc2l0aW9uLCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzdHlsZTogQ2FudmFzU3R5bGUpOiB2b2lkIHtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuY29sb3I7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aCB8fCAxO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlUmVjdChwb3MueCwgcG9zLnksIHNpemUueCwgc2l6ZS55KTtcclxuICAgIH0sXHJcbiAgICBkcmF3UGF0aChwYXRoOiBQYXRoLCBkZWY6IFhZRGVmaW5pdGlvbiwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubW92ZVRvKHBhdGhbMF1bZGVmLnhdLCBwYXRoWzBdW2RlZi55XSk7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocGF0aFtqXVtkZWYueF0sIHBhdGhbal1bZGVmLnldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH0sXHJcbiAgICBkcmF3SW1hZ2UoaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+LCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZS54LCBzaXplLnkpO1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gY2FudmFzRGF0YTtcclxuICAgICAgICBsZXQgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGxldCBpbWFnZURhdGFQb3MgPSBpbWFnZURhdGEubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoY2FudmFzRGF0YVBvcyAvIGltYWdlRGF0YVBvcyAhPT0gNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGltYWdlRGF0YVtpbWFnZURhdGFQb3NdO1xyXG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSAyNTU7XHJcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2FudmFzRGF0YSwgMCwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG59O1xyXG4iLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZVwiKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IHN1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQ7IiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsIi8qKlxyXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXHJcbiAqL1xyXG5jb25zdCBUcmFjZXIgPSB7XHJcbiAgICBzZWFyY2hEaXJlY3Rpb25zOiBbWzAsIDFdLCBbMSwgMV0sIFsxLCAwXSwgWzEsIC0xXSwgWzAsIC0xXSwgWy0xLCAtMV0sIFstMSwgMF0sIFstMSwgMV1dLFxyXG4gICAgY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XHJcbiAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XHJcbiAgICAgICAgY29uc3QgeyBzZWFyY2hEaXJlY3Rpb25zIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcclxuICAgICAgICBsZXQgcG9zO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkge1xyXG4gICAgICAgICAgICBsZXQgaTtcclxuICAgICAgICAgICAgbGV0IHk7XHJcbiAgICAgICAgICAgIGxldCB4O1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeSA9IGN1cnJlbnQuY3kgKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVswXTtcclxuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LmN4ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMV07XHJcbiAgICAgICAgICAgICAgICBwb3MgPSB5ICogd2lkdGggKyB4O1xyXG4gICAgICAgICAgICAgICAgaWYgKChpbWFnZURhdGFbcG9zXSA9PT0gY29sb3IpICYmICgobGFiZWxEYXRhW3Bvc10gPT09IDApIHx8IChsYWJlbERhdGFbcG9zXSA9PT0gbGFiZWwpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGVkZ2VsYWJlbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgMSkgJSA4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHZlcnRleDJEKHgsIHksIGRpcikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGlyLFxyXG4gICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcHJldjogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcclxuICAgICAgICAgICAgbGV0IEZ2ID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IEN2O1xyXG4gICAgICAgICAgICBsZXQgUDtcclxuICAgICAgICAgICAgbGV0IGxkaXI7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XHJcbiAgICAgICAgICAgICAgICBjeDogc3gsXHJcbiAgICAgICAgICAgICAgICBjeTogc3ksXHJcbiAgICAgICAgICAgICAgICBkaXI6IDAsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAodHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBGdiA9IHZlcnRleDJEKHN4LCBzeSwgY3VycmVudC5kaXIpO1xyXG4gICAgICAgICAgICAgICAgQ3YgPSBGdjtcclxuICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcclxuICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcclxuICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xyXG4gICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XHJcbiAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgQ3YgPSBQO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgNikgJSA4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGRpciAhPT0gY3VycmVudC5kaXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gY3VycmVudC5kaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDdiA9IFA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gbGRpcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueCA9IGN1cnJlbnQuY3g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnkgPSBjdXJyZW50LmN5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjdXJyZW50LmN4ICE9PSBzeCB8fCBjdXJyZW50LmN5ICE9PSBzeSk7XHJcbiAgICAgICAgICAgICAgICBGdi5wcmV2ID0gQ3YucHJldjtcclxuICAgICAgICAgICAgICAgIEN2LnByZXYubmV4dCA9IEZ2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBGdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoVHJhY2VyKTtcclxuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsImltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtdmVjMic7XHJcbmltcG9ydCAqIGFzIG1hdDIgZnJvbSAnZ2wtbWF0Mic7XHJcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xyXG5pbXBvcnQge1xyXG4gICAgY2FsY3VsYXRlUGF0Y2hTaXplLFxyXG4gICAgb3RzdVRocmVzaG9sZCxcclxuICAgIGhzdjJyZ2IsXHJcbiAgICBjbHVzdGVyLFxyXG4gICAgdG9wR2VuZXJpYyxcclxuICAgIGltYWdlUmVmLFxyXG4gICAgaGFsZlNhbXBsZSxcclxuICAgIGNvbXB1dGVJbWFnZUFyZWEsXHJcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xyXG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xyXG5pbXBvcnQgUmFzdGVyaXplciBmcm9tICcuL3Jhc3Rlcml6ZXInO1xyXG5pbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcclxuaW1wb3J0IHNrZWxldG9uaXplciBmcm9tICcuL3NrZWxldG9uaXplcic7XHJcblxyXG5cclxubGV0IF9jb25maWc7XHJcbmxldCBfY3VycmVudEltYWdlV3JhcHBlcjtcclxubGV0IF9za2VsSW1hZ2VXcmFwcGVyO1xyXG5sZXQgX3N1YkltYWdlV3JhcHBlcjtcclxubGV0IF9sYWJlbEltYWdlV3JhcHBlcjtcclxubGV0IF9wYXRjaEdyaWQ7XHJcbmxldCBfcGF0Y2hMYWJlbEdyaWQ7XHJcbmxldCBfaW1hZ2VUb1BhdGNoR3JpZDtcclxubGV0IF9iaW5hcnlJbWFnZVdyYXBwZXI7XHJcbmxldCBfcGF0Y2hTaXplO1xyXG5jb25zdCBfY2FudmFzQ29udGFpbmVyID0ge1xyXG4gICAgY3R4OiB7XHJcbiAgICAgICAgYmluYXJ5OiBudWxsLFxyXG4gICAgfSxcclxuICAgIGRvbToge1xyXG4gICAgICAgIGJpbmFyeTogbnVsbCxcclxuICAgIH0sXHJcbn07XHJcbmNvbnN0IF9udW1QYXRjaGVzID0geyB4OiAwLCB5OiAwIH07XHJcbmxldCBfaW5wdXRJbWFnZVdyYXBwZXI7XHJcbmxldCBfc2tlbGV0b25pemVyO1xyXG5cclxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoKSB7XHJcbiAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XHJcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgICAgICAgICAgeDogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCAvIDIgfCAwLFxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgICAgICB5OiBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gMiB8IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gX2lucHV0SW1hZ2VXcmFwcGVyO1xyXG4gICAgfVxyXG5cclxuICAgIF9wYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoX2NvbmZpZy5wYXRjaFNpemUsIF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUpO1xyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICBfbnVtUGF0Y2hlcy54ID0gX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3BhdGNoU2l6ZS54IHwgMDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICBfbnVtUGF0Y2hlcy55ID0gX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3BhdGNoU2l6ZS55IHwgMDtcclxuXHJcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfY3VycmVudEltYWdlV3JhcHBlci5zaXplLCB1bmRlZmluZWQsIFVpbnQ4QXJyYXksIGZhbHNlKTtcclxuXHJcbiAgICBfbGFiZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IHNrZWxldG9uSW1hZ2VEYXRhID0gbmV3IEFycmF5QnVmZmVyKDY0ICogMTAyNCk7XHJcbiAgICBfc3ViSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLFxyXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCAwLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpKTtcclxuICAgIF9za2VsSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLFxyXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkgKiAzLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpLFxyXG4gICAgICAgIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICBfc2tlbGV0b25pemVyID0gc2tlbGV0b25pemVyKFxyXG4gICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiBnbG9iYWwsXHJcbiAgICAgICAgeyBzaXplOiBfcGF0Y2hTaXplLnggfSxcclxuICAgICAgICBza2VsZXRvbkltYWdlRGF0YSxcclxuICAgICk7XHJcblxyXG4gICAgX2ltYWdlVG9QYXRjaEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgIHg6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCkgfCAwLFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgeTogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55KSB8IDAsXHJcbiAgICB9LCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcclxuICAgIF9wYXRjaEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgIF9wYXRjaExhYmVsR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCBJbnQzMkFycmF5LCB0cnVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcclxuICAgIGlmIChfY29uZmlnLnVzZVdvcmtlciB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuY2xhc3NOYW1lID0gJ2JpbmFyeUJ1ZmZlcic7XHJcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1ZycpLmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSk7XHJcbiAgICB9XHJcbiAgICBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnkgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS53aWR0aCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmhlaWdodCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCB3aGljaCBlbmNsb3NlcyBhbGwgdGhlIGdpdmVuIHBhdGNoZXNcclxuICogQHJldHVybnMge0FycmF5fSBUaGUgbWluaW1hbCBib3VuZGluZyBib3hcclxuICovXHJcbmZ1bmN0aW9uIGJveEZyb21QYXRjaGVzKHBhdGNoZXMpIHtcclxuICAgIGxldCBvdmVyQXZnO1xyXG4gICAgbGV0IGk7XHJcbiAgICBsZXQgajtcclxuICAgIGxldCBwYXRjaDtcclxuICAgIGxldCB0cmFuc01hdDtcclxuICAgIGxldCBtaW54ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XHJcbiAgICBsZXQgbWlueSA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xyXG4gICAgbGV0IG1heHggPSAtX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XHJcbiAgICBsZXQgbWF4eSA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgIGxldCBib3g7XHJcbiAgICBsZXQgc2NhbGU7XHJcblxyXG4gICAgLy8gZHJhdyBhbGwgcGF0Y2hlcyB3aGljaCBhcmUgdG8gYmUgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uXHJcbiAgICBvdmVyQXZnID0gMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xyXG4gICAgICAgIG92ZXJBdmcgKz0gcGF0Y2gucmFkO1xyXG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hlcykge1xyXG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICdyZWQnIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvdmVyQXZnIC89IHBhdGNoZXMubGVuZ3RoO1xyXG4gICAgb3ZlckF2ZyA9IChvdmVyQXZnICogMTgwIC8gTWF0aC5QSSArIDkwKSAlIDE4MCAtIDkwO1xyXG4gICAgaWYgKG92ZXJBdmcgPCAwKSB7XHJcbiAgICAgICAgb3ZlckF2ZyArPSAxODA7XHJcbiAgICB9XHJcblxyXG4gICAgb3ZlckF2ZyA9ICgxODAgLSBvdmVyQXZnKSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB0cmFuc01hdCA9IG1hdDIuY29weShtYXQyLmNyZWF0ZSgpLCBbTWF0aC5jb3Mob3ZlckF2ZyksIE1hdGguc2luKG92ZXJBdmcpLCAtTWF0aC5zaW4ob3ZlckF2ZyksIE1hdGguY29zKG92ZXJBdmcpXSk7XHJcblxyXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBhdGNoZXMgYW5kIHJvdGF0ZSBieSBhbmdsZVxyXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xyXG4gICAgICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIocGF0Y2guYm94W2pdLCBwYXRjaC5ib3hbal0sIHRyYW5zTWF0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWQpIHtcclxuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChwYXRjaC5ib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBmaW5kIGJvdW5kaW5nIGJveFxyXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdIDwgbWlueCkge1xyXG4gICAgICAgICAgICAgICAgbWlueCA9IHBhdGNoLmJveFtqXVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdID4gbWF4eCkge1xyXG4gICAgICAgICAgICAgICAgbWF4eCA9IHBhdGNoLmJveFtqXVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdIDwgbWlueSkge1xyXG4gICAgICAgICAgICAgICAgbWlueSA9IHBhdGNoLmJveFtqXVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdID4gbWF4eSkge1xyXG4gICAgICAgICAgICAgICAgbWF4eSA9IHBhdGNoLmJveFtqXVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBib3ggPSBbW21pbngsIG1pbnldLCBbbWF4eCwgbWlueV0sIFttYXh4LCBtYXh5XSwgW21pbngsIG1heHldXTtcclxuXHJcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd1RyYW5zZm9ybWVkQm94KSB7XHJcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNjYWxlID0gX2NvbmZpZy5oYWxmU2FtcGxlID8gMiA6IDE7XHJcbiAgICAvLyByZXZlcnNlIHJvdGF0aW9uO1xyXG4gICAgdHJhbnNNYXQgPSBtYXQyLmludmVydCh0cmFuc01hdCwgdHJhbnNNYXQpO1xyXG4gICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xyXG4gICAgICAgIHZlYzIudHJhbnNmb3JtTWF0Mihib3hbal0sIGJveFtqXSwgdHJhbnNNYXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93QkIpIHtcclxuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDIgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xyXG4gICAgICAgIHZlYzIuc2NhbGUoYm94W2pdLCBib3hbal0sIHNjYWxlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYm94O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGJpbmFyeSBpbWFnZSBvZiB0aGUgY3VycmVudCBpbWFnZVxyXG4gKi9cclxuZnVuY3Rpb24gYmluYXJpemVJbWFnZSgpIHtcclxuICAgIG90c3VUaHJlc2hvbGQoX2N1cnJlbnRJbWFnZVdyYXBwZXIsIF9iaW5hcnlJbWFnZVdyYXBwZXIpO1xyXG4gICAgX2JpbmFyeUltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XHJcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcykge1xyXG4gICAgICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc2hvdyhfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDI1NSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBpbWFnZVxyXG4gKiBleHRyYWN0IHBhdGNoZXNcclxuICovXHJcbmZ1bmN0aW9uIGZpbmRQYXRjaGVzKCkge1xyXG4gICAgbGV0IGk7XHJcbiAgICBsZXQgajtcclxuICAgIGxldCB4O1xyXG4gICAgbGV0IHk7XHJcbiAgICBsZXQgbW9tZW50cztcclxuICAgIGxldCBwYXRjaGVzRm91bmQgPSBbXTtcclxuICAgIGxldCByYXN0ZXJpemVyO1xyXG4gICAgbGV0IHJhc3RlclJlc3VsdDtcclxuICAgIGxldCBwYXRjaDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBfbnVtUGF0Y2hlcy54OyBpKyspIHtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX251bVBhdGNoZXMueTsgaisrKSB7XHJcbiAgICAgICAgICAgIHggPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCAqIGk7XHJcbiAgICAgICAgICAgIHkgPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueSAqIGo7XHJcblxyXG4gICAgICAgICAgICAvLyBzZXBlcmF0ZSBwYXJ0c1xyXG4gICAgICAgICAgICBza2VsZXRvbml6ZSh4LCB5KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJhc3Rlcml6ZSwgZmluZCBpbmRpdmlkdWFsIGJhcnNcclxuICAgICAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xyXG4gICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KF9sYWJlbEltYWdlV3JhcHBlci5kYXRhLCAwKTtcclxuICAgICAgICAgICAgcmFzdGVyaXplciA9IFJhc3Rlcml6ZXIuY3JlYXRlKF9za2VsSW1hZ2VXcmFwcGVyLCBfbGFiZWxJbWFnZVdyYXBwZXIpO1xyXG4gICAgICAgICAgICByYXN0ZXJSZXN1bHQgPSByYXN0ZXJpemVyLnJhc3Rlcml6ZSgwKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93TGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICBfbGFiZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIE1hdGguZmxvb3IoMzYwIC8gcmFzdGVyUmVzdWx0LmNvdW50KSxcclxuICAgICAgICAgICAgICAgICAgICB7IHgsIHkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBtb21lbnRzIGZyb20gdGhlIHNrZWxldG9uaXplZCBwYXRjaFxyXG4gICAgICAgICAgICBtb21lbnRzID0gX2xhYmVsSW1hZ2VXcmFwcGVyLm1vbWVudHMocmFzdGVyUmVzdWx0LmNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGV4dHJhY3QgZWxpZ2libGUgcGF0Y2hlc1xyXG4gICAgICAgICAgICBwYXRjaGVzRm91bmQgPSBwYXRjaGVzRm91bmQuY29uY2F0KGRlc2NyaWJlUGF0Y2gobW9tZW50cywgW2ksIGpdLCB4LCB5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Rm91bmRQYXRjaGVzKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtpXTtcclxuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxyXG4gICAgICAgICAgICAgICAgeyBjb2xvcjogJyM5OWZmMDAnLCBsaW5lV2lkdGg6IDIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kcyB0aG9zZSBjb25uZWN0ZWQgYXJlYXMgd2hpY2ggY29udGFpbiBhdCBsZWFzdCA2IHBhdGNoZXNcclxuICogYW5kIHJldHVybnMgdGhlbSBvcmRlcmVkIERFU0MgYnkgdGhlIG51bWJlciBvZiBjb250YWluZWQgcGF0Y2hlc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGFiZWxcclxuICovXHJcbmZ1bmN0aW9uIGZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMobWF4TGFiZWwpIHtcclxuICAgIGxldCBpO1xyXG4gICAgbGV0IHN1bTtcclxuICAgIGxldCBsYWJlbEhpc3QgPSBbXTtcclxuICAgIGxldCB0b3BMYWJlbHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF4TGFiZWw7IGkrKykge1xyXG4gICAgICAgIGxhYmVsSGlzdC5wdXNoKDApO1xyXG4gICAgfVxyXG4gICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xyXG4gICAgd2hpbGUgKHN1bS0tKSB7XHJcbiAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPiAwKSB7XHJcbiAgICAgICAgICAgIGxhYmVsSGlzdFtfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dIC0gMV0rKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGFiZWxIaXN0ID0gbGFiZWxIaXN0Lm1hcCgodmFsLCBpZHgpID0+ICh7XHJcbiAgICAgICAgdmFsLFxyXG4gICAgICAgIGxhYmVsOiBpZHggKyAxLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIGxhYmVsSGlzdC5zb3J0KChhLCBiKSA9PiBiLnZhbCAtIGEudmFsKTtcclxuXHJcbiAgICAvLyBleHRyYWN0IHRvcCBhcmVhcyB3aXRoIGF0IGxlYXN0IDYgcGF0Y2hlcyBwcmVzZW50XHJcbiAgICB0b3BMYWJlbHMgPSBsYWJlbEhpc3QuZmlsdGVyKChlbCkgPT4gZWwudmFsID49IDUpO1xyXG5cclxuICAgIHJldHVybiB0b3BMYWJlbHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpIHtcclxuICAgIGxldCBpO1xyXG4gICAgbGV0IGo7XHJcbiAgICBsZXQgc3VtO1xyXG4gICAgY29uc3QgcGF0Y2hlcyA9IFtdO1xyXG4gICAgbGV0IHBhdGNoO1xyXG4gICAgbGV0IGJveDtcclxuICAgIGNvbnN0IGJveGVzID0gW107XHJcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XHJcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRvcExhYmVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcclxuICAgICAgICBwYXRjaGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHN1bS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID09PSB0b3BMYWJlbHNbaV0ubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtzdW1dO1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBib3ggPSBib3hGcm9tUGF0Y2hlcyhwYXRjaGVzKTtcclxuICAgICAgICBpZiAoYm94KSB7XHJcbiAgICAgICAgICAgIGJveGVzLnB1c2goYm94KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBoc3ZbMF0gPSAodG9wTGFiZWxzW2ldLmxhYmVsIC8gKG1heExhYmVsICsgMSkpICogMzYwO1xyXG4gICAgICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjb2xvcjogYHJnYigke3JnYi5qb2luKCcsJyl9KWAsIGxpbmVXaWR0aDogMiB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBib3hlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmQgc2ltaWxhciBtb21lbnRzICh2aWEgY2x1c3RlcilcclxuICogQHBhcmFtIHtPYmplY3R9IG1vbWVudHNcclxuICovXHJcbmZ1bmN0aW9uIHNpbWlsYXJNb21lbnRzKG1vbWVudHMpIHtcclxuICAgIGNvbnN0IGNsdXN0ZXJzID0gY2x1c3Rlcihtb21lbnRzLCAwLjkwKTtcclxuICAgIGNvbnN0IHRvcENsdXN0ZXIgPSB0b3BHZW5lcmljKGNsdXN0ZXJzLCAxLCAoZSkgPT4gZS5nZXRQb2ludHMoKS5sZW5ndGgpO1xyXG4gICAgbGV0IHBvaW50cyA9IFtdOyBjb25zdFxyXG4gICAgICAgIHJlc3VsdCA9IFtdO1xyXG4gICAgaWYgKHRvcENsdXN0ZXIubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgcG9pbnRzID0gdG9wQ2x1c3RlclswXS5pdGVtLmdldFBvaW50cygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpXS5wb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2tlbGV0b25pemUoeCwgeSkge1xyXG4gICAgX2JpbmFyeUltYWdlV3JhcHBlci5zdWJJbWFnZUFzQ29weShfc3ViSW1hZ2VXcmFwcGVyLCBpbWFnZVJlZih4LCB5KSk7XHJcbiAgICBfc2tlbGV0b25pemVyLnNrZWxldG9uaXplKCk7XHJcblxyXG4gICAgLy8gU2hvdyBza2VsZXRvbiBpZiByZXF1ZXN0ZWRcclxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93U2tlbGV0b24pIHtcclxuICAgICAgICBfc2tlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMzYwLCBpbWFnZVJlZih4LCB5KSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBhbmQgZGVzY3JpYmVzIHRob3NlIHBhdGNoZXMgd2hpY2ggc2VlbSB0byBjb250YWluIGEgYmFyY29kZSBwYXR0ZXJuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG1vbWVudHNcclxuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoUG9zLFxyXG4gKiBAcGFyYW0ge051bWJlcn0geFxyXG4gKiBAcGFyYW0ge051bWJlcn0geVxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGxpc3Qgb2YgcGF0Y2hlc1xyXG4gKi9cclxuZnVuY3Rpb24gZGVzY3JpYmVQYXRjaChtb21lbnRzLCBwYXRjaFBvcywgeCwgeSkge1xyXG4gICAgbGV0IGs7XHJcbiAgICBsZXQgYXZnO1xyXG4gICAgY29uc3QgZWxpZ2libGVNb21lbnRzID0gW107XHJcbiAgICBsZXQgbWF0Y2hpbmdNb21lbnRzO1xyXG4gICAgbGV0IHBhdGNoO1xyXG4gICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gW107XHJcbiAgICBjb25zdCBtaW5Db21wb25lbnRXZWlnaHQgPSBNYXRoLmNlaWwoX3BhdGNoU2l6ZS54IC8gMyk7XHJcblxyXG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAvLyBvbmx5IGNvbGxlY3QgbW9tZW50cyB3aGljaCdzIGFyZWEgY292ZXJzIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodCBwaXhlbHMuXHJcbiAgICAgICAgZm9yIChrID0gMDsgayA8IG1vbWVudHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgaWYgKG1vbWVudHNba10ubTAwID4gbWluQ29tcG9uZW50V2VpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBlbGlnaWJsZU1vbWVudHMucHVzaChtb21lbnRzW2tdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgYXQgbGVhc3QgMiBtb21lbnRzIGFyZSBmb3VuZCB3aGljaCBoYXZlIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodHMgY292ZXJlZFxyXG4gICAgICAgIGlmIChlbGlnaWJsZU1vbWVudHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgbWF0Y2hpbmdNb21lbnRzID0gc2ltaWxhck1vbWVudHMoZWxpZ2libGVNb21lbnRzKTtcclxuICAgICAgICAgICAgYXZnID0gMDtcclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzaW1pbGFyaXR5IG9mIHRoZSBtb21lbnRzXHJcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBtYXRjaGluZ01vbWVudHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGF2ZyArPSBtYXRjaGluZ01vbWVudHNba10ucmFkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHR3byBvZiB0aGUgbW9tZW50cyBhcmUgYWxsb3dlZCBub3QgdG8gZml0IGludG8gdGhlIGVxdWF0aW9uXHJcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgcGF0Y2ggdG8gdGhlIHNldFxyXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID49IChlbGlnaWJsZU1vbWVudHMubGVuZ3RoIC8gNCkgKiAzXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IG1vbWVudHMubGVuZ3RoIC8gNCkge1xyXG4gICAgICAgICAgICAgICAgYXZnIC89IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBwYXRjaCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogcGF0Y2hQb3NbMV0gKiBfbnVtUGF0Y2hlcy54ICsgcGF0Y2hQb3NbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBib3g6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeSArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55XSksXHJcbiAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICBtb21lbnRzOiBtYXRjaGluZ01vbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmFkOiBhdmcsXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFtNYXRoLmNvcyhhdmcpLCBNYXRoLnNpbihhdmcpXSksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hlc0ZvdW5kLnB1c2gocGF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIGZpbmRzIHBhdGNoZXMgd2hpY2ggYXJlIGNvbm5lY3RlZCBhbmQgc2hhcmUgdGhlIHNhbWUgb3JpZW50YXRpb25cclxuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoZXNGb3VuZFxyXG4gKi9cclxuZnVuY3Rpb24gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKSB7XHJcbiAgICBsZXQgbGFiZWwgPSAwO1xyXG4gICAgY29uc3QgdGhyZXNob2xkID0gMC45NTtcclxuICAgIGxldCBjdXJySWR4ID0gMDtcclxuICAgIGxldCBqO1xyXG4gICAgbGV0IHBhdGNoO1xyXG4gICAgY29uc3QgaHN2ID0gWzAsIDEsIDFdO1xyXG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xyXG5cclxuICAgIGZ1bmN0aW9uIG5vdFlldFByb2Nlc3NlZCgpIHtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2ldID09PSAwICYmIF9wYXRjaEdyaWQuZGF0YVtpXSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9wYXRjaExhYmVsR3JpZC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudElkeCkge1xyXG4gICAgICAgIGxldCB4O1xyXG4gICAgICAgIGxldCB5O1xyXG4gICAgICAgIGxldCBjdXJyZW50UGF0Y2g7XHJcbiAgICAgICAgbGV0IGlkeDtcclxuICAgICAgICBsZXQgZGlyO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XHJcbiAgICAgICAgICAgIHg6IGN1cnJlbnRJZHggJSBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54LFxyXG4gICAgICAgICAgICB5OiAoY3VycmVudElkeCAvIF9wYXRjaExhYmVsR3JpZC5zaXplLngpIHwgMCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBzaW1pbGFyaXR5O1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudElkeCA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2N1cnJlbnRJZHhdO1xyXG4gICAgICAgICAgICAvLyBhc3NpZ24gbGFiZWxcclxuICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbY3VycmVudElkeF0gPSBsYWJlbDtcclxuICAgICAgICAgICAgZm9yIChkaXIgPSAwOyBkaXIgPCBUcmFjZXIuc2VhcmNoRGlyZWN0aW9ucy5sZW5ndGg7IGRpcisrKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC55ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVswXTtcclxuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LnggKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzFdO1xyXG4gICAgICAgICAgICAgICAgaWR4ID0geSAqIF9wYXRjaExhYmVsR3JpZC5zaXplLnggKyB4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHBhdGNoIGVtcHR5XHJcbiAgICAgICAgICAgICAgICBpZiAoX3BhdGNoR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2lkeF0udmVjLCBjdXJyZW50UGF0Y2gudmVjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2UoaWR4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHJlcGFyZSBmb3IgZmluZGluZyB0aGUgcmlnaHQgcGF0Y2hlc1xyXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hHcmlkLmRhdGEsIDApO1xyXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hMYWJlbEdyaWQuZGF0YSwgMCk7XHJcbiAgICBBcnJheUhlbHBlci5pbml0KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGEsIG51bGwpO1xyXG5cclxuICAgIGZvciAoaiA9IDA7IGogPCBwYXRjaGVzRm91bmQubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtqXTtcclxuICAgICAgICBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IHBhdGNoO1xyXG4gICAgICAgIF9wYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJhc3Rlcml6ZSB0aGUgcGF0Y2hlcyBmb3VuZCB0byBkZXRlcm1pbmUgYXJlYVxyXG4gICAgX3BhdGNoR3JpZC56ZXJvQm9yZGVyKCk7XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXHJcbiAgICB3aGlsZSAoKGN1cnJJZHggPSBub3RZZXRQcm9jZXNzZWQoKSkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICBsYWJlbCsrO1xyXG4gICAgICAgIHRyYWNlKGN1cnJJZHgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxyXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaExhYmVscykge1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gPiAwICYmIF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdIDw9IGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbal07XHJcbiAgICAgICAgICAgICAgICBoc3ZbMF0gPSAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gLyAobGFiZWwgKyAxKSkgKiAzNjA7XHJcbiAgICAgICAgICAgICAgICBoc3YycmdiKGhzdiwgcmdiKTtcclxuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcclxuICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYWJlbDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgaW5pdChpbnB1dEltYWdlV3JhcHBlciwgY29uZmlnKSB7XHJcbiAgICAgICAgX2NvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcclxuXHJcbiAgICAgICAgaW5pdEJ1ZmZlcnMoKTtcclxuICAgICAgICBpbml0Q2FudmFzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGxvY2F0ZSgpIHtcclxuICAgICAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XHJcbiAgICAgICAgICAgIGhhbGZTYW1wbGUoX2lucHV0SW1hZ2VXcmFwcGVyLCBfY3VycmVudEltYWdlV3JhcHBlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiaW5hcml6ZUltYWdlKCk7XHJcbiAgICAgICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gZmluZFBhdGNoZXMoKTtcclxuICAgICAgICAvLyByZXR1cm4gdW5sZXNzIDUlIG9yIG1vcmUgcGF0Y2hlcyBhcmUgZm91bmRcclxuICAgICAgICBpZiAocGF0Y2hlc0ZvdW5kLmxlbmd0aCA8IF9udW1QYXRjaGVzLnggKiBfbnVtUGF0Y2hlcy55ICogMC4wNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJhc3RlcnJpemUgYXJlYSBieSBjb21wYXJpbmcgYW5ndWxhciBzaW1pbGFyaXR5O1xyXG4gICAgICAgIGNvbnN0IG1heExhYmVsID0gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKTtcclxuICAgICAgICBpZiAobWF4TGFiZWwgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2VhcmNoIGZvciBhcmVhIHdpdGggdGhlIG1vc3QgcGF0Y2hlcyAoYmlnZ2VzdCBjb25uZWN0ZWQgYXJlYSlcclxuICAgICAgICBjb25zdCB0b3BMYWJlbHMgPSBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKTtcclxuICAgICAgICBpZiAodG9wTGFiZWxzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGJveGVzID0gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpO1xyXG4gICAgICAgIHJldHVybiBib3hlcztcclxuICAgIH0sXHJcblxyXG4gICAgY2hlY2tJbWFnZUNvbnN0cmFpbnRzKGlucHV0U3RyZWFtLCBjb25maWcpIHtcclxuICAgICAgICBsZXQgcGF0Y2hTaXplO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IGlucHV0U3RyZWFtLmdldFdpZHRoKCk7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IGlucHV0U3RyZWFtLmdldEhlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNIYWxmU2FtcGxlID0gY29uZmlnLmhhbGZTYW1wbGUgPyAwLjUgOiAxO1xyXG4gICAgICAgIGxldCBhcmVhO1xyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodCBiYXNlZCBvbiBhcmVhXHJcbiAgICAgICAgaWYgKGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpIHtcclxuICAgICAgICAgICAgYXJlYSA9IGNvbXB1dGVJbWFnZUFyZWEod2lkdGgsIGhlaWdodCwgaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSk7XHJcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNldFRvcFJpZ2h0KHsgeDogYXJlYS5zeCwgeTogYXJlYS5zeSB9KTtcclxuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0Q2FudmFzU2l6ZSh7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gYXJlYS5zdztcclxuICAgICAgICAgICAgaGVpZ2h0ID0gYXJlYS5zaDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNpemUgPSB7XHJcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3Iod2lkdGggKiB0aGlzSGFsZlNhbXBsZSksXHJcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoaGVpZ2h0ICogdGhpc0hhbGZTYW1wbGUpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShjb25maWcucGF0Y2hTaXplLCBzaXplKTtcclxuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXRjaC1TaXplOiAke0pTT04uc3RyaW5naWZ5KHBhdGNoU2l6ZSl9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRXaWR0aChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS54IC8gcGF0Y2hTaXplLngpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueCkpO1xyXG4gICAgICAgIGlucHV0U3RyZWFtLnNldEhlaWdodChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS55IC8gcGF0Y2hTaXplLnkpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueSkpO1xyXG5cclxuICAgICAgICBpZiAoKGlucHV0U3RyZWFtLmdldFdpZHRoKCkgJSBwYXRjaFNpemUueCkgPT09IDAgJiYgKGlucHV0U3RyZWFtLmdldEhlaWdodCgpICUgcGF0Y2hTaXplLnkpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKCR7XHJcbiAgICAgICAgICAgIHdpZHRofSApYW5kIGhlaWdodCAoJHtoZWlnaHRcclxuICAgICAgICB9KSBtdXN0IGEgbXVsdGlwbGUgb2YgJHtwYXRjaFNpemUueH1gKTtcclxuICAgIH0sXHJcbn07XHJcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGV0ZXJtaW5hbnQ6IHJlcXVpcmUoJy4vZGV0ZXJtaW5hbnQnKVxuICAsIHRyYW5zcG9zZTogcmVxdWlyZSgnLi90cmFuc3Bvc2UnKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBpZGVudGl0eTogcmVxdWlyZSgnLi9pZGVudGl0eScpXG4gICwgYWRqb2ludDogcmVxdWlyZSgnLi9hZGpvaW50JylcbiAgLCByb3RhdGU6IHJlcXVpcmUoJy4vcm90YXRlJylcbiAgLCBpbnZlcnQ6IHJlcXVpcmUoJy4vaW52ZXJ0JylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBmcm9iOiByZXF1aXJlKCcuL2Zyb2InKVxuICAsIGxkdTogcmVxdWlyZSgnLi9sZHUnKVxufVxuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsiLCJtb2R1bGUuZXhwb3J0cyA9IDAuMDAwMDAxXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IDBcbiAgICBvdXRbMV0gPSAwXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc3VidHJhY3RcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGl2aWRlXG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpc3RhbmNlXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWREaXN0YW5jZVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV1cbiAgICByZXR1cm4geCp4ICsgeSp5XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZW5ndGhcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWRMZW5ndGhcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgcmV0dXJuIHgqeCArIHkqeVxufSIsIm1vZHVsZS5leHBvcnRzID0gMC4wMDAwMDFcbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IDBcbiAgICBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gMFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemU7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pXG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW5cbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlblxuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuXG4gICAgfVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRvdDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3VidHJhY3Q7XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGl2aWRlO1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeilcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl1cbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Knpcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVBTSUxPTjogcmVxdWlyZSgnLi9lcHNpbG9uJylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpXG4gICwgYW5nbGU6IHJlcXVpcmUoJy4vYW5nbGUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBtaW46IHJlcXVpcmUoJy4vbWluJylcbiAgLCBtYXg6IHJlcXVpcmUoJy4vbWF4JylcbiAgLCBmbG9vcjogcmVxdWlyZSgnLi9mbG9vcicpXG4gICwgY2VpbDogcmVxdWlyZSgnLi9jZWlsJylcbiAgLCByb3VuZDogcmVxdWlyZSgnLi9yb3VuZCcpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHNjYWxlQW5kQWRkOiByZXF1aXJlKCcuL3NjYWxlQW5kQWRkJylcbiAgLCBkaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4gICwgZGlzdDogcmVxdWlyZSgnLi9kaXN0JylcbiAgLCBzcXVhcmVkRGlzdGFuY2U6IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiAgLCBzcXJEaXN0OiByZXF1aXJlKCcuL3NxckRpc3QnKVxuICAsIGxlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGgnKVxuICAsIGxlbjogcmVxdWlyZSgnLi9sZW4nKVxuICAsIHNxdWFyZWRMZW5ndGg6IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4gICwgc3FyTGVuOiByZXF1aXJlKCcuL3NxckxlbicpXG4gICwgbmVnYXRlOiByZXF1aXJlKCcuL25lZ2F0ZScpXG4gICwgaW52ZXJzZTogcmVxdWlyZSgnLi9pbnZlcnNlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQ0OiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDQnKVxuICAsIHRyYW5zZm9ybU1hdDM6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MycpXG4gICwgdHJhbnNmb3JtUXVhdDogcmVxdWlyZSgnLi90cmFuc2Zvcm1RdWF0JylcbiAgLCByb3RhdGVYOiByZXF1aXJlKCcuL3JvdGF0ZVgnKVxuICAsIHJvdGF0ZVk6IHJlcXVpcmUoJy4vcm90YXRlWScpXG4gICwgcm90YXRlWjogcmVxdWlyZSgnLi9yb3RhdGVaJylcbiAgLCBmb3JFYWNoOiByZXF1aXJlKCcuL2ZvckVhY2gnKVxufVxuIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwiaW1wb3J0IFRyYWNlciBmcm9tICcuL3RyYWNlcic7XHJcblxyXG4vKipcclxuICogaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vVGlwcy80MDcxNzIvQ29ubmVjdGVkLUNvbXBvbmVudC1MYWJlbGluZy1hbmQtVmVjdG9yaXphdGlvblxyXG4gKi9cclxuY29uc3QgUmFzdGVyaXplciA9IHtcclxuICAgIGNyZWF0ZUNvbnRvdXIyRCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkaXI6IG51bGwsXHJcbiAgICAgICAgICAgIGluZGV4OiBudWxsLFxyXG4gICAgICAgICAgICBmaXJzdFZlcnRleDogbnVsbCxcclxuICAgICAgICAgICAgaW5zaWRlQ29udG91cnM6IG51bGwsXHJcbiAgICAgICAgICAgIG5leHRwZWVyOiBudWxsLFxyXG4gICAgICAgICAgICBwcmV2cGVlcjogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIENPTlRPVVJfRElSOiB7XHJcbiAgICAgICAgQ1dfRElSOiAwLFxyXG4gICAgICAgIENDV19ESVI6IDEsXHJcbiAgICAgICAgVU5LTk9XTl9ESVI6IDIsXHJcbiAgICB9LFxyXG4gICAgRElSOiB7XHJcbiAgICAgICAgT1VUU0lERV9FREdFOiAtMzI3NjcsXHJcbiAgICAgICAgSU5TSURFX0VER0U6IC0zMjc2NixcclxuICAgIH0sXHJcbiAgICBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcclxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcclxuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcclxuICAgICAgICBjb25zdCB0cmFjZXIgPSBUcmFjZXIuY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmFzdGVyaXplKGRlcHRobGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb2xvcjtcclxuICAgICAgICAgICAgICAgIGxldCBiYztcclxuICAgICAgICAgICAgICAgIGxldCBsYztcclxuICAgICAgICAgICAgICAgIGxldCBsYWJlbGluZGV4O1xyXG4gICAgICAgICAgICAgICAgbGV0IGN4O1xyXG4gICAgICAgICAgICAgICAgbGV0IGN5O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JNYXAgPSBbXTtcclxuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICBsZXQgcDtcclxuICAgICAgICAgICAgICAgIGxldCBjYztcclxuICAgICAgICAgICAgICAgIGxldCBzYztcclxuICAgICAgICAgICAgICAgIGxldCBwb3M7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29ubmVjdGVkQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IGk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQwMDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbG9yTWFwWzBdID0gaW1hZ2VEYXRhWzBdO1xyXG4gICAgICAgICAgICAgICAgY2MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjeSA9IDE7IGN5IDwgaGVpZ2h0IC0gMTsgY3krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjeCA9IDE7IGN4IDwgd2lkdGggLSAxOyBjeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGN5ICogd2lkdGggKyBjeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGltYWdlRGF0YVtwb3NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9PSBiYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxjID0gY29ubmVjdGVkQ291bnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtsY10gPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgbGMsIGNvbG9yLCBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGxhYmVsaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IGNjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5wcmV2cGVlciA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYyA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb250b3VyVHJhY2luZyhjeSwgY3gsIFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFLCBjb2xvciwgbGFiZWxpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRobGFiZWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ0NXX0RJUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBkZXB0aGxhYmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBjYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoc2MgIT09IG51bGwpICYmIHNjLmluZGV4ICE9PSBsYWJlbGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBzYy5pbnNpZGVDb250b3VycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MuaW5zaWRlQ29udG91cnMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMucHJldnBlZXIgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3VycyA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWxpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuT1VUU0lERV9FREdFXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGltYWdlRGF0YVtwb3NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxhYmVsRGF0YVtwb3NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFtsYWJlbGluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNjID0gY2M7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2MgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzYy5pbmRleCA9IGRlcHRobGFiZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MsXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvbm5lY3RlZENvdW50LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGVidWc6IHtcclxuICAgICAgICAgICAgICAgIGRyYXdDb250b3VyKGNhbnZhcywgZmlyc3RDb250b3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBxID0gZmlyc3RDb250b3VyO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpcTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlxICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gaXE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IGlxLm5leHRwZWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHBxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHEgPSBwcS5uZXh0cGVlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChxLmRpcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5VTktOT1dOX0RJUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcS5maXJzdFZlcnRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAueCwgcC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocC54LCBwLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwICE9PSBxLmZpcnN0VmVydGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSYXN0ZXJpemVyO1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xyXG5cclxuLyogQHByZXNlcnZlIEFTTSBCRUdJTiAqL1xyXG5mdW5jdGlvbiBTa2VsZXRvbml6ZXIoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcclxuICAgICd1c2UgYXNtJztcclxuXHJcbiAgICBjb25zdCBpbWFnZXMgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgIGNvbnN0IHNpemUgPSBmb3JlaWduLnNpemUgfCAwO1xyXG4gICAgY29uc3QgeyBpbXVsIH0gPSBzdGRsaWIuTWF0aDtcclxuXHJcbiAgICBmdW5jdGlvbiBlcm9kZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xyXG4gICAgICAgIGluSW1hZ2VQdHIgfD0gMDtcclxuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xyXG5cclxuICAgICAgICBsZXQgdiA9IDA7XHJcbiAgICAgICAgbGV0IHUgPSAwO1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgIGxldCB5U3RhcnQxID0gMDtcclxuICAgICAgICBsZXQgeVN0YXJ0MiA9IDA7XHJcbiAgICAgICAgbGV0IHhTdGFydDEgPSAwO1xyXG4gICAgICAgIGxldCB4U3RhcnQyID0gMDtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xyXG4gICAgICAgICAgICBmb3IgKHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XHJcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcclxuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcclxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID09ICg1IHwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcclxuICAgICAgICBhSW1hZ2VQdHIgfD0gMDtcclxuICAgICAgICBiSW1hZ2VQdHIgfD0gMDtcclxuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xyXG5cclxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XHJcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgLSAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XHJcbiAgICAgICAgYUltYWdlUHRyIHw9IDA7XHJcbiAgICAgICAgYkltYWdlUHRyIHw9IDA7XHJcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcclxuXHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xyXG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIHwgKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlUHRyKSB7XHJcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcclxuXHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xyXG4gICAgICAgICAgICBzdW0gPSAoKHN1bSB8IDApICsgKGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChzdW0gfCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbml0KGltYWdlUHRyLCB2YWx1ZSkge1xyXG4gICAgICAgIGltYWdlUHRyIHw9IDA7XHJcbiAgICAgICAgdmFsdWUgfD0gMDtcclxuXHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xyXG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xyXG4gICAgICAgIGluSW1hZ2VQdHIgfD0gMDtcclxuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xyXG5cclxuICAgICAgICBsZXQgdiA9IDA7XHJcbiAgICAgICAgbGV0IHUgPSAwO1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgIGxldCB5U3RhcnQxID0gMDtcclxuICAgICAgICBsZXQgeVN0YXJ0MiA9IDA7XHJcbiAgICAgICAgbGV0IHhTdGFydDEgPSAwO1xyXG4gICAgICAgIGxldCB4U3RhcnQyID0gMDtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xyXG4gICAgICAgICAgICBmb3IgKHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XHJcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcclxuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcclxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID4gKDAgfCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lbWNweShzcmNJbWFnZVB0ciwgZHN0SW1hZ2VQdHIpIHtcclxuICAgICAgICBzcmNJbWFnZVB0ciB8PSAwO1xyXG4gICAgICAgIGRzdEltYWdlUHRyIHw9IDA7XHJcblxyXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcclxuICAgICAgICAgICAgaW1hZ2VzWyhkc3RJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IChpbWFnZXNbKHNyY0ltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHplcm9Cb3JkZXIoaW1hZ2VQdHIpIHtcclxuICAgICAgICBpbWFnZVB0ciB8PSAwO1xyXG5cclxuICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgbGV0IHkgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XHJcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB4KSB8IDBdID0gMDtcclxuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xyXG4gICAgICAgICAgICB5ID0gKCh5ICsgc2l6ZSkgLSAxKSB8IDA7XHJcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcclxuICAgICAgICAgICAgeSA9ICh5ICsgMSkgfCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKHNpemUgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XHJcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcclxuICAgICAgICAgICAgeSA9ICh5ICsgMSkgfCAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBza2VsZXRvbml6ZSgpIHtcclxuICAgICAgICBjb25zdCBzdWJJbWFnZVB0ciA9IDA7XHJcbiAgICAgICAgbGV0IGVyb2RlZEltYWdlUHRyID0gMDtcclxuICAgICAgICBsZXQgdGVtcEltYWdlUHRyID0gMDtcclxuICAgICAgICBsZXQgc2tlbEltYWdlUHRyID0gMDtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBsZXQgZG9uZSA9IDA7XHJcblxyXG4gICAgICAgIGVyb2RlZEltYWdlUHRyID0gaW11bChzaXplLCBzaXplKSB8IDA7XHJcbiAgICAgICAgdGVtcEltYWdlUHRyID0gKGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcclxuICAgICAgICBza2VsSW1hZ2VQdHIgPSAodGVtcEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcclxuXHJcbiAgICAgICAgLy8gaW5pdCBza2VsLWltYWdlXHJcbiAgICAgICAgaW5pdChza2VsSW1hZ2VQdHIsIDApO1xyXG4gICAgICAgIHplcm9Cb3JkZXIoc3ViSW1hZ2VQdHIpO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGVyb2RlKHN1YkltYWdlUHRyLCBlcm9kZWRJbWFnZVB0cik7XHJcbiAgICAgICAgICAgIGRpbGF0ZShlcm9kZWRJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcclxuICAgICAgICAgICAgc3VidHJhY3Qoc3ViSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcclxuICAgICAgICAgICAgYml0d2lzZU9yKHNrZWxJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCBza2VsSW1hZ2VQdHIpO1xyXG4gICAgICAgICAgICBtZW1jcHkoZXJvZGVkSW1hZ2VQdHIsIHN1YkltYWdlUHRyKTtcclxuICAgICAgICAgICAgc3VtID0gY291bnROb25aZXJvKHN1YkltYWdlUHRyKSB8IDA7XHJcbiAgICAgICAgICAgIGRvbmUgPSAoKHN1bSB8IDApID09IDAgfCAwKTtcclxuICAgICAgICB9IHdoaWxlICghZG9uZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNrZWxldG9uaXplLFxyXG4gICAgfTtcclxufVxyXG4vKiBAcHJlc2VydmUgQVNNIEVORCAqL1xyXG5leHBvcnQgZGVmYXVsdCBTa2VsZXRvbml6ZXI7XHJcbi8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXHJcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImdldC1waXhlbHNcIik7IiwiLy8gTk9URSBGT1IgQU5ZT05FIElOIEhFUkUgSU4gVEhFIEZVVFVSRTogVGhpcyBtb2R1bGUgaXMgdXNlZCB3aGVuIHRoZSBtb2R1bGUgaXMgYnVpbHQgZm9yIHVzZSBpbiBOb2RlLlxyXG4vLyBXZWJwYWNrLmNvbmZpZy5qcyBleHBsaWNpdGx5IFJFUExBQ0VTIHRoaXMgbW9kdWxlIHdpdGggdGhlIGZpbGUgY2FsbGVkIGZyYW1lX2dyYWJiZXJfYnJvd3NlciB3aGVuIGl0IGlzIHBhY2tpbmcgdGhlIEJyb3dzZXIgZGlzdHJpYnV0aW9uLlxyXG5cclxuY29uc3QgQ1ZVdGlscyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9jdl91dGlscycpO1xyXG5jb25zdCBOZGFycmF5ID0gcmVxdWlyZSgnbmRhcnJheScpO1xyXG5jb25zdCBJbnRlcnAyRCA9IHJlcXVpcmUoJ25kYXJyYXktbGluZWFyLWludGVycG9sYXRlJykuZDI7XHJcblxyXG5jb25zdCBGcmFtZUdyYWJiZXIgPSB7fTtcclxuXHJcbkZyYW1lR3JhYmJlci5jcmVhdGUgPSBmdW5jdGlvbiAoaW5wdXRTdHJlYW0sIGNhbnZhcykge1xyXG4gICAgY29uc3QgX3RoYXQgPSB7fTtcclxuICAgIGNvbnN0IF92aWRlb1NpemUgPSBDVlV0aWxzLmltYWdlUmVmKGlucHV0U3RyZWFtLmdldFJlYWxXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRSZWFsSGVpZ2h0KCkpO1xyXG4gICAgY29uc3QgX2NhbnZhc1NpemUgPSBpbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCk7XHJcbiAgICBjb25zdCBfc2l6ZSA9IENWVXRpbHMuaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpO1xyXG4gICAgY29uc3QgX3RvcFJpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcclxuICAgIGxldCBfZGF0YSA9IG5ldyBVaW50OEFycmF5KF9zaXplLnggKiBfc2l6ZS55KTtcclxuICAgIGNvbnN0IF9ncmF5RGF0YSA9IG5ldyBVaW50OEFycmF5KF92aWRlb1NpemUueCAqIF92aWRlb1NpemUueSk7XHJcbiAgICBjb25zdCBfY2FudmFzRGF0YSA9IG5ldyBVaW50OEFycmF5KF9jYW52YXNTaXplLnggKiBfY2FudmFzU2l6ZS55KTtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cclxuICAgIGNvbnN0IF9ncmF5SW1hZ2VBcnJheSA9IE5kYXJyYXkoX2dyYXlEYXRhLCBbX3ZpZGVvU2l6ZS55LCBfdmlkZW9TaXplLnhdKS50cmFuc3Bvc2UoMSwgMCk7XHJcbiAgICBjb25zdCBfY2FudmFzSW1hZ2VBcnJheSA9IE5kYXJyYXkoX2NhbnZhc0RhdGEsIFtfY2FudmFzU2l6ZS55LCBfY2FudmFzU2l6ZS54XSkudHJhbnNwb3NlKDEsIDApO1xyXG4gICAgY29uc3QgX3RhcmdldEltYWdlQXJyYXkgPSBfY2FudmFzSW1hZ2VBcnJheVxyXG4gICAgICAgIC5oaShfdG9wUmlnaHQueCArIF9zaXplLngsIF90b3BSaWdodC55ICsgX3NpemUueSlcclxuICAgICAgICAubG8oX3RvcFJpZ2h0LngsIF90b3BSaWdodC55KTtcclxuICAgIGNvbnN0IF9zdGVwU2l6ZVggPSBfdmlkZW9TaXplLnggLyBfY2FudmFzU2l6ZS54O1xyXG4gICAgY29uc3QgX3N0ZXBTaXplWSA9IF92aWRlb1NpemUueSAvIF9jYW52YXNTaXplLnk7XHJcblxyXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdGcmFtZUdyYWJiZXInLCBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgIHZpZGVvU2l6ZTogX2dyYXlJbWFnZUFycmF5LnNoYXBlLFxyXG4gICAgICAgICAgICBjYW52YXNTaXplOiBfY2FudmFzSW1hZ2VBcnJheS5zaGFwZSxcclxuICAgICAgICAgICAgc3RlcFNpemU6IFtfc3RlcFNpemVYLCBfc3RlcFNpemVZXSxcclxuICAgICAgICAgICAgc2l6ZTogX3RhcmdldEltYWdlQXJyYXkuc2hhcGUsXHJcbiAgICAgICAgICAgIHRvcFJpZ2h0OiBfdG9wUmlnaHQsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYXMgZnJhbWUtYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIF90aGF0LmF0dGFjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIF9kYXRhID0gZGF0YTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1c2VkIGZyYW1lLWJ1ZmZlclxyXG4gICAgICovXHJcbiAgICBfdGhhdC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZGF0YTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIGEgZnJhbWUgZnJvbSB0aGUgaW5wdXQtc3RyZWFtIGFuZCBwdXRzIGludG8gdGhlIGZyYW1lLWJ1ZmZlci5cclxuICAgICAqIFRoZSBpbWFnZS1kYXRhIGlzIGNvbnZlcnRlZCB0byBncmF5LXNjYWxlIGFuZCB0aGVuIGhhbGYtc2FtcGxlZCBpZiBjb25maWd1cmVkLlxyXG4gICAgICovXHJcbiAgICBfdGhhdC5ncmFiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcclxuXHJcbiAgICAgICAgaWYgKGZyYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGVBbmRDcm9wKGZyYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICBfdGhhdC5zY2FsZUFuZENyb3AgPSBmdW5jdGlvbihmcmFtZSkge1xyXG4gICAgICAgIC8vIDEuIGNvbXB1dGUgZnVsbC1zaXplZCBncmF5IGltYWdlXHJcbiAgICAgICAgQ1ZVdGlscy5jb21wdXRlR3JheShmcmFtZS5kYXRhLCBfZ3JheURhdGEpO1xyXG5cclxuICAgICAgICAvLyAyLiBpbnRlcnBvbGF0ZVxyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX2NhbnZhc1NpemUueTsgeSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgX2NhbnZhc1NpemUueDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgICAgICAgICAgX2NhbnZhc0ltYWdlQXJyYXkuc2V0KHgsIHksIChJbnRlcnAyRChfZ3JheUltYWdlQXJyYXksIHggKiBfc3RlcFNpemVYLCB5ICogX3N0ZXBTaXplWSkpIHwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRhcmdldEltYWdlQXJyYXkgbXVzdCBiZSBlcXVhbCB0byB0YXJnZXRTaXplXHJcbiAgICAgICAgaWYgKF90YXJnZXRJbWFnZUFycmF5LnNoYXBlWzBdICE9PSBfc2l6ZS54XHJcbiAgICAgICAgICAgIHx8IF90YXJnZXRJbWFnZUFycmF5LnNoYXBlWzFdICE9PSBfc2l6ZS55KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhcGVzIGRvIG5vdCBtYXRjaCEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDMuIGNyb3BcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IF9zaXplLnk7IHkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9zaXplLng7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgX2RhdGFbeSAqIF9zaXplLnggKyB4XSA9IF90YXJnZXRJbWFnZUFycmF5LmdldCh4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX3RoYXQuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3NpemU7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBfdGhhdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnJhbWVHcmFiYmVyO1xyXG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BsYWluT2JqZWN0O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCIvKlxyXG4gKiB0eXBlZGVmcy5qc1xyXG4gKiBOb3JtYWxpemVzIGJyb3dzZXItc3BlY2lmaWMgcHJlZml4ZXMgYW5kIHByb3ZpZGUgc29tZSBiYXNpYyBwb2x5ZmlsbHNcclxuICovXHJcblxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICAgICAgICAgICAgfHwgZnVuY3Rpb24gKC8qIGZ1bmN0aW9uIEZyYW1lUmVxdWVzdENhbGxiYWNrICovIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmlmICh0eXBlb2YgTWF0aC5pbXVsICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXHJcbiAgICBNYXRoLmltdWwgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGNvbnN0IGFoID0gKGEgPj4+IDE2KSAmIDB4ZmZmZjtcclxuICAgICAgICBjb25zdCBhbCA9IGEgJiAweGZmZmY7XHJcbiAgICAgICAgY29uc3QgYmggPSAoYiA+Pj4gMTYpICYgMHhmZmZmO1xyXG4gICAgICAgIGNvbnN0IGJsID0gYiAmIDB4ZmZmZjtcclxuICAgICAgICAvLyB0aGUgc2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0XHJcbiAgICAgICAgLy8gdGhlIGZpbmFsIHwwIGNvbnZlcnRzIHRoZSB1bnNpZ25lZCB2YWx1ZSBpbnRvIGEgc2lnbmVkIHZhbHVlXHJcbiAgICAgICAgcmV0dXJuICgoYWwgKiBibCkgKyAoKChhaCAqIGJsICsgYWwgKiBiaCkgPDwgMTYpID4+PiAwKSB8IDApO1xyXG4gICAgfTtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xyXG59XHJcblxyXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcclxuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IC8vIC5sZW5ndGggb2YgZnVuY3Rpb24gaXMgMlxyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7IC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRvID0gT2JqZWN0KHRhcmdldCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcclxuICAgICAgICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XHJcblxyXG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZSAhPT0gbnVsbCkgeyAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfTtcclxufVxyXG4iLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlc1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYjAgPSBiWzBdXG4gIHZhciBiMSA9IGJbMV1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZFxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJzZVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG1pblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtYXhcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIHZlYzIgYnkgYW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCBhbmdsZSkge1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSlcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV1cblxuICBvdXRbMF0gPSB4ICogYyAtIHkgKiBzXG4gIG91dFsxXSA9IHggKiBzICsgeSAqIGNcblxuICByZXR1cm4gb3V0XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZmxvb3JcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdW5kXG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJcbiAgICBvdXRbMV0gPSBhWzFdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkXG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSlcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZVxuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplXG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnlcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgfVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRvdFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXVxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3NcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXVxuICAgIG91dFswXSA9IG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVycFxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXVxuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpXG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb21cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MlxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHlcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MmRcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0M1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NFxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHZlYyA9IHJlcXVpcmUoJy4vY3JlYXRlJykoKVxuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGxcbiAgICBpZighc3RyaWRlKSB7XG4gICAgICAgIHN0cmlkZSA9IDJcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IDBcbiAgICB9XG4gICAgXG4gICAgaWYoY291bnQpIHtcbiAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGwgPSBhLmxlbmd0aFxuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgdmVjWzBdID0gYVtpXVxuICAgICAgICB2ZWNbMV0gPSBhW2krMV1cbiAgICAgICAgZm4odmVjLCB2ZWMsIGFyZylcbiAgICAgICAgYVtpXSA9IHZlY1swXVxuICAgICAgICBhW2krMV0gPSB2ZWNbMV1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGFcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxpbWl0O1xuXG4vKipcbiAqIExpbWl0IHRoZSBtYWduaXR1ZGUgb2YgdGhpcyB2ZWN0b3IgdG8gdGhlIHZhbHVlIHVzZWQgZm9yIHRoZSBgbWF4YFxuICogcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSAge3ZlYzJ9IHRoZSB2ZWN0b3IgdG8gbGltaXRcbiAqIEBwYXJhbSAge051bWJlcn0gbWF4IHRoZSBtYXhpbXVtIG1hZ25pdHVkZSBmb3IgdGhlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsaW1pdChvdXQsIGEsIG1heCkge1xuICB2YXIgbVNxID0gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcblxuICBpZiAobVNxID4gbWF4ICogbWF4KSB7XG4gICAgdmFyIG4gPSBNYXRoLnNxcnQobVNxKTtcbiAgICBvdXRbMF0gPSBhWzBdIC8gbiAqIG1heDtcbiAgICBvdXRbMV0gPSBhWzFdIC8gbiAqIG1heDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGFuZ2xlXG5cbnZhciBmcm9tVmFsdWVzID0gcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG52YXIgZG90ID0gcmVxdWlyZSgnLi9kb3QnKVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgdmFyIHRlbXBBID0gZnJvbVZhbHVlcyhhWzBdLCBhWzFdLCBhWzJdKVxuICAgIHZhciB0ZW1wQiA9IGZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSlcbiBcbiAgICBub3JtYWxpemUodGVtcEEsIHRlbXBBKVxuICAgIG5vcm1hbGl6ZSh0ZW1wQiwgdGVtcEIpXG4gXG4gICAgdmFyIGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpXG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKVxuICAgIH0gICAgIFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICB2YXIgYjIgPSBiWzJdXG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleGFjdEVxdWFsc1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbWluO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2VpbFxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgb3V0WzJdID0gYVsyXSAqIGJcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZUFuZEFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgb3V0WzJdID0gLWFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICBvdXRbMl0gPSAxLjAgLyBhWzJdXG4gIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyb3NzO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdXG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieVxuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYnhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcblxuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUElcbiAgICB2YXIgeiA9IChNYXRoLnJhbmRvbSgpICogMi4wKSAtIDEuMFxuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZVxuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZVxuICAgIG91dFsyXSA9IHogKiBzY2FsZVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdXG4gICAgdyA9IHcgfHwgMS4wXG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHdcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gd1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gd1xuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDM7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXVxuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XVxuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XVxuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybVF1YXQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeVxuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXpcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWDtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieSA9IGJbMV1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyBUcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICAgIHZhciBweiA9IGFbMl0gLSBielxuXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYnkgKyBweSAqIGNjIC0gcHogKiBzY1xuICAgIG91dFsyXSA9IGJ6ICsgcHkgKiBzYyArIHB6ICogY2NcblxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieCA9IGJbMF1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyB0cmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweiA9IGFbMl0gLSBielxuICAgIFxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcbiAgXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB6ICogc2MgKyBweCAqIGNjXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGJ6ICsgcHogKiBjYyAtIHB4ICogc2NcbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVaO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieSA9IGJbMV1cblxuICAgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHggPSBhWzBdIC0gYnhcbiAgICB2YXIgcHkgPSBhWzFdIC0gYnlcbiAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB4ICogY2MgLSBweSAqIHNjXG4gICAgb3V0WzFdID0gYnkgKyBweCAqIHNjICsgcHkgKiBjY1xuICAgIG91dFsyXSA9IGFbMl1cbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGxcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gM1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldIFxuICAgICAgICAgICAgdmVjWzFdID0gYVtpKzFdIFxuICAgICAgICAgICAgdmVjWzJdID0gYVtpKzJdXG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICAgICAgYVtpXSA9IHZlY1swXSBcbiAgICAgICAgICAgIGFbaSsxXSA9IHZlY1sxXSBcbiAgICAgICAgICAgIGFbaSsyXSA9IHZlY1syXVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYVxufSIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zdXBlclByb3BCYXNlOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJ2YXIgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZGV0ZXJtaW5hbnRcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5kZXRlcm1pbmFudFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3NlXG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIudHJhbnNwb3NlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGExID0gYVsxXVxuICAgIG91dFsxXSA9IGFbMl1cbiAgICBvdXRbMl0gPSBhMVxuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzJdXG4gICAgb3V0WzJdID0gYVsxXVxuICAgIG91dFszXSA9IGFbM11cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAYWxpYXMgbWF0Mi5tdWx0aXBseVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdXG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxXG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxXG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzXG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHlcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAYWxpYXMgbWF0Mi5pZGVudGl0eVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZGpvaW50XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuYWRqb2ludFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIHZhciBhMCA9ICBhWzBdXG4gIG91dFswXSA9ICBhWzNdXG4gIG91dFsxXSA9IC1hWzFdXG4gIG91dFsyXSA9IC1hWzJdXG4gIG91dFszXSA9ICBhMFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQGFsaWFzIG1hdDIucm90YXRlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgcyA9IE1hdGguc2luKHJhZClcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpXG4gIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHNcbiAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogc1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjXG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGNcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnRcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmludmVydFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBhMyA9IGFbM11cbiAgdmFyIGRldCA9IGEwICogYTMgLSBhMiAqIGExXG5cbiAgaWYgKCFkZXQpIHJldHVybiBudWxsXG4gIGRldCA9IDEuMCAvIGRldFxuXG4gIG91dFswXSA9ICBhMyAqIGRldFxuICBvdXRbMV0gPSAtYTEgKiBkZXRcbiAgb3V0WzJdID0gLWEyICogZGV0XG4gIG91dFszXSA9ICBhMCAqIGRldFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuY3JlYXRlXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpXG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBhbGlhcyBtYXQyLnNjYWxlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM11cbiAgdmFyIHYwID0gdlswXSwgdjEgPSB2WzFdXG4gIG91dFswXSA9IGEwICogdjBcbiAgb3V0WzFdID0gYTEgKiB2MFxuICBvdXRbMl0gPSBhMiAqIHYxXG4gIG91dFszXSA9IGEzICogdjFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBhbGlhcyBtYXQyLmNvcHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXVxuICBvdXRbMV0gPSBhWzFdXG4gIG91dFsyXSA9IGFbMl1cbiAgb3V0WzNdID0gYVszXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb2JcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmZyb2JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoXG4gICAgTWF0aC5wb3coYVswXSwgMikgK1xuICAgIE1hdGgucG93KGFbMV0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzJdLCAyKSArXG4gICAgTWF0aC5wb3coYVszXSwgMilcbiAgKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBsZHVcblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKlxuICogQGFsaWFzIG1hdDIubGR1XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cbmZ1bmN0aW9uIGxkdShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdL2FbMF1cbiAgVVswXSA9IGFbMF1cbiAgVVsxXSA9IGFbMV1cbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXVxuICByZXR1cm4gW0wsIEQsIFVdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZGFycmF5XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5kYXJyYXktbGluZWFyLWludGVycG9sYXRlXCIpOyIsImNvbnN0IEJyZXNlbmhhbSA9IHt9O1xyXG5cclxuY29uc3QgU2xvcGUgPSB7XHJcbiAgICBESVI6IHtcclxuICAgICAgICBVUDogMSxcclxuICAgICAgICBET1dOOiAtMSxcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBTY2FucyBhIGxpbmUgb2YgdGhlIGdpdmVuIGltYWdlIGZyb20gcG9pbnQgcDEgdG8gcDIgYW5kIHJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmdcclxuICogZ3JheS1zY2FsZSB2YWx1ZXMgKDAtMjU1KSBvZiB0aGUgdW5kZXJseWluZyBwaXhlbHMgaW4gYWRkaXRpb24gdG8gdGhlIG1pblxyXG4gKiBhbmQgbWF4IHZhbHVlcy5cclxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlV3JhcHBlclxyXG4gKiBAcGFyYW0ge09iamVjdH0gcDEgVGhlIHN0YXJ0IHBvaW50IHt4LHl9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiBUaGUgZW5kIHBvaW50IHt4LHl9XHJcbiAqIEByZXR1cm5zIHtsaW5lLCBtaW4sIG1heH1cclxuICovXHJcbkJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZSA9IGZ1bmN0aW9uIChpbWFnZVdyYXBwZXIsIHAxLCBwMikge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xyXG4gICAgbGV0IHgwID0gcDEueCB8IDA7XHJcbiAgICBsZXQgeTAgPSBwMS55IHwgMDtcclxuICAgIGxldCB4MSA9IHAyLnggfCAwO1xyXG4gICAgbGV0IHkxID0gcDIueSB8IDA7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXHJcbiAgICBjb25zdCBzdGVlcCA9IE1hdGguYWJzKHkxIC0geTApID4gTWF0aC5hYnMoeDEgLSB4MCk7XHJcbiAgICBsZXQgZXJyb3I7XHJcbiAgICBsZXQgeTtcclxuICAgIGxldCB0bXA7XHJcbiAgICBsZXQgeDtcclxuICAgIGNvbnN0IGxpbmUgPSBbXTtcclxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xyXG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xyXG4gICAgbGV0IHZhbDtcclxuICAgIGxldCBtaW4gPSAyNTU7XHJcbiAgICBsZXQgbWF4ID0gMDtcclxuXHJcbiAgICBmdW5jdGlvbiByZWFkKGEsIGIpIHtcclxuICAgICAgICB2YWwgPSBpbWFnZURhdGFbYiAqIHdpZHRoICsgYV07XHJcbiAgICAgICAgbWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xyXG4gICAgICAgIG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcclxuICAgICAgICBsaW5lLnB1c2godmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RlZXApIHtcclxuICAgICAgICB0bXAgPSB4MDtcclxuICAgICAgICB4MCA9IHkwO1xyXG4gICAgICAgIHkwID0gdG1wO1xyXG5cclxuICAgICAgICB0bXAgPSB4MTtcclxuICAgICAgICB4MSA9IHkxO1xyXG4gICAgICAgIHkxID0gdG1wO1xyXG4gICAgfVxyXG4gICAgaWYgKHgwID4geDEpIHtcclxuICAgICAgICB0bXAgPSB4MDtcclxuICAgICAgICB4MCA9IHgxO1xyXG4gICAgICAgIHgxID0gdG1wO1xyXG5cclxuICAgICAgICB0bXAgPSB5MDtcclxuICAgICAgICB5MCA9IHkxO1xyXG4gICAgICAgIHkxID0gdG1wO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVsdGFYID0geDEgLSB4MDtcclxuICAgIGNvbnN0IGRlbHRhWSA9IE1hdGguYWJzKHkxIC0geTApO1xyXG4gICAgZXJyb3IgPSAoZGVsdGFYIC8gMikgfCAwO1xyXG4gICAgeSA9IHkwO1xyXG4gICAgY29uc3QgeVN0ZXAgPSB5MCA8IHkxID8gMSA6IC0xO1xyXG4gICAgZm9yICh4ID0geDA7IHggPCB4MTsgeCsrKSB7XHJcbiAgICAgICAgaWYgKHN0ZWVwKSB7XHJcbiAgICAgICAgICAgIHJlYWQoeSwgeCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVhZCh4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXJyb3IgLT0gZGVsdGFZO1xyXG4gICAgICAgIGlmIChlcnJvciA8IDApIHtcclxuICAgICAgICAgICAgeSArPSB5U3RlcDtcclxuICAgICAgICAgICAgZXJyb3IgKz0gZGVsdGFYO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxpbmUsXHJcbiAgICAgICAgbWluLFxyXG4gICAgICAgIG1heCxcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHJlc3VsdCBmcm9tIGdldEJhcmNvZGVMaW5lIGludG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb25cclxuICogYWxzbyBjb25zaWRlcmluZyB0aGUgZnJlcXVlbmN5IGFuZCBzbG9wZSBvZiB0aGUgc2lnbmFsIGZvciBtb3JlIHJvYnVzdCByZXN1bHRzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQge2xpbmUsIG1pbiwgbWF4fVxyXG4gKi9cclxuQnJlc2VuaGFtLnRvQmluYXJ5TGluZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgIGNvbnN0IHsgbWluIH0gPSByZXN1bHQ7XHJcbiAgICBjb25zdCB7IG1heCB9ID0gcmVzdWx0O1xyXG4gICAgY29uc3QgeyBsaW5lIH0gPSByZXN1bHQ7XHJcbiAgICBsZXQgc2xvcGU7XHJcbiAgICBsZXQgc2xvcGUyO1xyXG4gICAgY29uc3QgY2VudGVyID0gbWluICsgKG1heCAtIG1pbikgLyAyO1xyXG4gICAgY29uc3QgZXh0cmVtYSA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnREaXI7XHJcbiAgICBsZXQgZGlyO1xyXG4gICAgbGV0IHRocmVzaG9sZCA9IChtYXggLSBtaW4pIC8gMTI7XHJcbiAgICBjb25zdCByVGhyZXNob2xkID0gLXRocmVzaG9sZDtcclxuICAgIGxldCBpO1xyXG4gICAgbGV0IGo7XHJcblxyXG4gICAgLy8gMS4gZmluZCBleHRyZW1hXHJcbiAgICBjdXJyZW50RGlyID0gbGluZVswXSA+IGNlbnRlciA/IFNsb3BlLkRJUi5VUCA6IFNsb3BlLkRJUi5ET1dOO1xyXG4gICAgZXh0cmVtYS5wdXNoKHtcclxuICAgICAgICBwb3M6IDAsXHJcbiAgICAgICAgdmFsOiBsaW5lWzBdLFxyXG4gICAgfSk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICBzbG9wZSA9IChsaW5lW2kgKyAxXSAtIGxpbmVbaV0pO1xyXG4gICAgICAgIHNsb3BlMiA9IChsaW5lW2kgKyAyXSAtIGxpbmVbaSArIDFdKTtcclxuICAgICAgICBpZiAoKHNsb3BlICsgc2xvcGUyKSA8IHJUaHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPCAoY2VudGVyICogMS41KSkge1xyXG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuRE9XTjtcclxuICAgICAgICB9IGVsc2UgaWYgKChzbG9wZSArIHNsb3BlMikgPiB0aHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPiAoY2VudGVyICogMC41KSkge1xyXG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuVVA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGlyID0gY3VycmVudERpcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50RGlyICE9PSBkaXIpIHtcclxuICAgICAgICAgICAgZXh0cmVtYS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBvczogaSxcclxuICAgICAgICAgICAgICAgIHZhbDogbGluZVtpXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnREaXIgPSBkaXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXh0cmVtYS5wdXNoKHtcclxuICAgICAgICBwb3M6IGxpbmUubGVuZ3RoLFxyXG4gICAgICAgIHZhbDogbGluZVtsaW5lLmxlbmd0aCAtIDFdLFxyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yIChqID0gZXh0cmVtYVswXS5wb3M7IGogPCBleHRyZW1hWzFdLnBvczsgaisrKSB7XHJcbiAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiBjZW50ZXIgPyAwIDogMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpdGVyYXRlIG92ZXIgZXh0cmVtYSBhbmQgY29udmVydCB0byBiaW5hcnkgYmFzZWQgb24gYXZnIGJldHdlZW4gbWlubWF4XHJcbiAgICBmb3IgKGkgPSAxOyBpIDwgZXh0cmVtYS5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICBpZiAoZXh0cmVtYVtpICsgMV0udmFsID4gZXh0cmVtYVtpXS52YWwpIHtcclxuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaV0udmFsICsgKChleHRyZW1hW2kgKyAxXS52YWwgLSBleHRyZW1hW2ldLnZhbCkgLyAzKSAqIDIpIHwgMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpICsgMV0udmFsICsgKChleHRyZW1hW2ldLnZhbCAtIGV4dHJlbWFbaSArIDFdLnZhbCkgLyAzKSkgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChqID0gZXh0cmVtYVtpXS5wb3M7IGogPCBleHRyZW1hW2kgKyAxXS5wb3M7IGorKykge1xyXG4gICAgICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IHRocmVzaG9sZCA/IDAgOiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxpbmUsXHJcbiAgICAgICAgdGhyZXNob2xkLFxyXG4gICAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVc2VkIGZvciBkZXZlbG9wbWVudCBvbmx5XHJcbiAqL1xyXG5CcmVzZW5oYW0uZGVidWcgPSB7XHJcbiAgICBwcmludEZyZXF1ZW5jeShsaW5lLCBjYW52YXMpIHtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMjU2O1xyXG5cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oaSwgMjU1KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhpLCAyNTUgLSBsaW5lW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJpbnRQYXR0ZXJuKGxpbmUsIGNhbnZhcykge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyBsZXRcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XHJcbiAgICAgICAgY3R4LmZpbGxDb2xvciA9ICdibGFjayc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpbmVbaV0gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChpLCAwLCAxLCAxMDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJyZXNlbmhhbTtcclxuIiwiaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xyXG5cclxuZXhwb3J0IGVudW0gQmFyY29kZURpcmVjdGlvbiB7XHJcbiAgICBGb3J3YXJkID0gMSxcclxuICAgIFJldmVyc2UgPSAtMSxcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIEJhcmNvZGVSZWFkZXJUeXBlID0gc3RyaW5nO1xyXG5leHBvcnQgdHlwZSBCYXJjb2RlRm9ybWF0ID0gc3RyaW5nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlUmVhZGVyQ29uZmlnIHtcclxuICAgIG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg/OiBib29sZWFuLFxyXG4gICAgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyVHlwZT4sXHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVDb3JyZWN0aW9uIHtcclxuICAgIGJhcjogbnVtYmVyLFxyXG4gICAgc3BhY2U6IG51bWJlcixcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZVBvc2l0aW9uIHtcclxuICAgIHN0YXJ0OiBudW1iZXIsXHJcbiAgICBzdGFydENvdW50ZXI/OiBudW1iZXIsXHJcbiAgICBlbmQ6IG51bWJlcixcclxuICAgIGVuZENvdW50ZXI/OiBudW1iZXIsXHJcbiAgICBlcnJvcj86IG51bWJlcixcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZUluZm8gZXh0ZW5kcyBCYXJjb2RlUG9zaXRpb24ge1xyXG4gICAgY29kZTogbnVtYmVyLFxyXG4gICAgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uLFxyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlIHtcclxuICAgIGNvZGU6IHN0cmluZyxcclxuICAgIGNvZGVzZXQ/OiBudW1iZXIsXHJcbiAgICBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24sXHJcbiAgICBkZWNvZGVkQ29kZXM/OiBBcnJheTxzdHJpbmcgfCBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4sXHJcbiAgICBkaXJlY3Rpb24/OiBCYXJjb2RlRGlyZWN0aW9uLFxyXG4gICAgZW5kOiBudW1iZXIsXHJcbiAgICBlbmRJbmZvPzogQmFyY29kZVBvc2l0aW9uLFxyXG4gICAgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LFxyXG4gICAgc3RhcnQ6IG51bWJlcixcclxuICAgIHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uLFxyXG4gICAgc3VwcGxlbWVudD86IEJhcmNvZGUsXHJcbn07XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFyY29kZVJlYWRlciB7XHJcbiAgICBfcm93OiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICBjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcgPSB7fTtcclxuICAgIHN1cHBsZW1lbnRzOiBBcnJheTxCYXJjb2RlUmVhZGVyPiA9IFtdO1xyXG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwO1xyXG4gICAgRk9STUFUOiBCYXJjb2RlRm9ybWF0ID0gJ3Vua25vd24nO1xyXG4gICAgQ09ORklHX0tFWVM6IEJhcmNvZGVSZWFkZXJDb25maWcgPSB7fTtcclxuICAgIC8vIFRPRE86IHNob3VsZCBhZGQgQUxQSEFCRVRIX1NUUklORywgQUxQSEFCRVQsIENIQVJBQ1RFUl9FTkNPRElOR1MgdG8gYmFzZSBjbGFzcywgaWYgdGhleVxyXG4gICAgLy8gYXJlIHVzZWZ1bCBpbiBtb3N0IHJlYWRlcnMuXHJcblxyXG4gICAgYWJzdHJhY3QgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsO1xyXG5cclxuICAgIHN0YXRpYyBnZXQgRXhjZXB0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFN0YXJ0Tm90Rm91bmRFeGNlcHRpb246ICdTdGFydC1JbmZvIHdhcyBub3QgZm91bmQhJyxcclxuICAgICAgICAgICAgQ29kZU5vdEZvdW5kRXhjZXB0aW9uOiAnQ29kZSBjb3VsZCBub3QgYmUgZm91bmQhJyxcclxuICAgICAgICAgICAgUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uOiAnUGF0dGVybiBjb3VsZCBub3QgYmUgZm91bmQhJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnLCBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXI+KSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3JvdyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgIGlmIChzdXBwbGVtZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLnN1cHBsZW1lbnRzID0gc3VwcGxlbWVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIF9uZXh0VW5zZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBzdGFydDogbnVtYmVyID0gMCk6IG51bWJlciB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWxpbmVbaV0pIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgX21hdGNoUGF0dGVybihjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbWF4U2luZ2xlRXJyb3I/OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBlcnJvciA9IDA7XHJcbiAgICAgICAgbGV0IHNpbmdsZUVycm9yID0gMDtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBsZXQgbW9kdWxvID0gMDtcclxuICAgICAgICBsZXQgYmFyV2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IHNjYWxlZCA9IDA7XHJcblxyXG4gICAgICAgIG1heFNpbmdsZUVycm9yID0gbWF4U2luZ2xlRXJyb3IgfHwgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiB8fCAxO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbaV07XHJcbiAgICAgICAgICAgIG1vZHVsbyArPSBjb2RlW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VtIDwgbW9kdWxvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYmFyV2lkdGggPSBzdW0gLyBtb2R1bG87XHJcbiAgICAgICAgbWF4U2luZ2xlRXJyb3IgKj0gYmFyV2lkdGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvdW50ID0gY291bnRlcltpXTtcclxuICAgICAgICAgICAgc2NhbGVkID0gY29kZVtpXSAqIGJhcldpZHRoO1xyXG4gICAgICAgICAgICBzaW5nbGVFcnJvciA9IE1hdGguYWJzKGNvdW50IC0gc2NhbGVkKSAvIHNjYWxlZDtcclxuICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yID4gbWF4U2luZ2xlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVycm9yICs9IHNpbmdsZUVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyb3IgLyBtb2R1bG87XHJcbiAgICB9XHJcblxyXG4gICAgX25leHRTZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciA9IDApIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobGluZVtpXSkgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBfY29ycmVjdEJhcnMoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogbnVtYmVyLCBpbmRpY2VzOiBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCB0bXAgPSAwO1xyXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgICAgICB0bXAgPSBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gKiAoMSAtICgoMSAtIGNvcnJlY3Rpb24pIC8gMikpO1xyXG4gICAgICAgICAgICBpZiAodG1wID4gMSkge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcltpbmRpY2VzW2xlbmd0aF1dID0gdG1wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRlY29kZVBhdHRlcm4ocGF0dGVybjogQXJyYXk8bnVtYmVyPikge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuJywgcGF0dGVybik7XHJcbiAgICAgICAgdGhpcy5fcm93ID0gcGF0dGVybjtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybiBjYWxsaW5nIGRlY29kZScsIHR5cGVvZiB0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLkZPUk1BVCwgSlNPTi5zdHJpbmdpZnkodGhpcykpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9kZWNvZGUoKTtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3QgcmVzdWx0PScsIHJlc3VsdCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGUoKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldmVyc2VkIHJlc3VsdD0nLCByZXN1bHQpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5SZXZlcnNlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5zdGFydDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gcmVzdWx0LmVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlRGlyZWN0aW9uLkZvcndhcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmZvcm1hdCA9IHRoaXMuRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgcmVzdWx0KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIF9tYXRjaFJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgc3RhcnQgPSBzdGFydCA8IDAgPyAwIDogc3RhcnQ7XHJcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIF9maWxsQ291bnRlcnMob2Zmc2V0OiBudW1iZXIgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KSwgZW5kOiBudW1iZXIgPSB0aGlzLl9yb3cubGVuZ3RoLCBpc1doaXRlOiBib29sZWFuID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudGVycztcclxuICAgIH1cclxuXHJcbiAgICBfdG9Db3VudGVycyhzdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkgfCBBcnJheTxudW1iZXI+KSB7XHJcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcclxuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbc3RhcnRdO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuXHJcbiAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChjb3VudGVycywgMCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IG51bUNvdW50ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvdW50ZXJzO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYXJjb2RlUmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlQ29ycmVjdGlvbiwgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBDb2RlMTI4UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgQ09ERV9TSElGVCA9IDk4O1xuICAgIENPREVfQyA9IDk5O1xuICAgIENPREVfQiA9IDEwMDtcbiAgICBDT0RFX0EgPSAxMDE7XG4gICAgU1RBUlRfQ09ERV9BID0gMTAzO1xuICAgIFNUQVJUX0NPREVfQiA9IDEwNDtcbiAgICBTVEFSVF9DT0RFX0MgPSAxMDU7XG4gICAgU1RPUF9DT0RFID0gMTA2O1xuICAgIENPREVfUEFUVEVSTiA9IFtcbiAgICAgICAgICAgIFsyLCAxLCAyLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAyLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAyLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAzLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAyLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAzLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAyLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAzLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAyLCAzLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAzLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAyLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAzLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAzLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAzLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAzLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAyLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAzLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAxLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAxLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAyLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAyLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAzLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAzLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAxLCAzLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAzLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAzLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAzLCAxLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFszLCAzLCAyLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCA0LCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAzLCAxLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAyLCAyLCA0XSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCA0LCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAxLCAyLCA0XSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCA0LCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCA0LCAxLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCA0LCAxLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAyLCAxLCA0XSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCA0LCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAxLCA0XSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCA0LCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCA0LCAyLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCA0LCAyLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCA0LCAxLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAxLCA0XSxcbiAgICAgICAgICAgIFs0LCAxLCAzLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCA0LCAxLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAyLCA0LCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAxLCA0LCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCA0LCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCA0LCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFs0LCAyLCAxLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFs0LCAyLCAxLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCA0LCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAxLCA0LCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAzLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCA0LCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAyLCAxLCA0XSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAyLCAzLCAyXSxcbiAgICAgICAgICAgIFsyLCAzLCAzLCAxLCAxLCAxLCAyXSxcbiAgICAgICAgXTtcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNjQ7XG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xuICAgIEZPUk1BVCA9ICdjb2RlXzEyOCc7XG4gICAgTU9EVUxFX0lORElDRVMgPSB7IGJhcjogWzAsIDIsIDRdLCBzcGFjZTogWzEsIDMsIDVdIH07XG5cbiAgICBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbb2Zmc2V0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ycmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ycmVjdChjb3VudGVyLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IHRoaXMuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guY29kZSA9PT0gLTEgfHwgYmVzdE1hdGNoLmVycm9yID4gdGhpcy5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2NvcnJlY3QoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogQmFyY29kZUNvcnJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5iYXIsIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5zcGFjZSwgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IF9maW5kU3RhcnQgYW5kIGRlY29kZUNvZGUgc2hhcmUgc2ltaWxhciBjb2RlLCBjYW4gd2UgcmUtdXNlIHNvbWU/XG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gdGhpcy5TVEFSVF9DT0RFX0E7IGNvZGUgPD0gdGhpcy5TVEFSVF9DT0RFX0M7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCB0aGlzLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAvLyAgICAgZG9uZSA9IGZhbHNlLFxuICAgICAgICAvLyAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIC8vICAgICBtdWx0aXBsaWVyID0gMCxcbiAgICAgICAgLy8gICAgIGNoZWNrc3VtID0gMCxcbiAgICAgICAgLy8gICAgIGNvZGVzZXQsXG4gICAgICAgIC8vICAgICByYXdSZXN1bHQgPSBbXSxcbiAgICAgICAgLy8gICAgIGRlY29kZWRDb2RlcyA9IFtdLFxuICAgICAgICAvLyAgICAgc2hpZnROZXh0ID0gZmFsc2UsXG4gICAgICAgIC8vICAgICB1bnNoaWZ0LFxuICAgICAgICAvLyAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG5cbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IHtcbiAgICAgICAgICAgIGNvZGU6IHN0YXJ0SW5mby5jb2RlLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IHN0YXJ0SW5mby5jb3JyZWN0aW9uLmJhcixcbiAgICAgICAgICAgICAgICBzcGFjZTogc3RhcnRJbmZvLmNvcnJlY3Rpb24uc3BhY2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIGxldCBjaGVja3N1bSA9IGNvZGUuY29kZTtcbiAgICAgICAgbGV0IGNvZGVzZXQgPSAoKGM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGNvZGUuY29kZSk7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGxldCBzaGlmdE5leHQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHVuc2hpZnQgPSBzaGlmdE5leHQ7XG4gICAgICAgIGxldCByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgbGV0IG11bHRpcGxpZXIgPSAwO1xuICAgICAgICBsZXQgcmF3UmVzdWx0OiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgICAgIGxldCByZXN1bHQ6IEFycmF5PHN0cmluZyB8IG51bWJlcj4gPSBbXTsgLy8gVE9ETzogaSB0aGluayB0aGlzIHNob3VsZCBiZSBzdHJpbmcgb25seSwgYnV0IGl0IGNyZWF0ZXMgcHJvYmxlbXMgaWYgaXQgaXNcblxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgIHVuc2hpZnQgPSBzaGlmdE5leHQ7XG4gICAgICAgICAgICBzaGlmdE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUhLmVuZCwgY29kZSEuY29ycmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd1Jlc3VsdC5wdXNoKGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gbXVsdGlwbGllciAqIGNvZGUuY29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGVzZXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLmNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlLmNvZGUgLSA2NCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSA8IDEwID8gJzAnICsgY29kZS5jb2RlIDogY29kZS5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5zaGlmdCkge1xuICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBjb2Rlc2V0ID09PSB0aGlzLkNPREVfQSA/IHRoaXMuQ09ERV9CIDogdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlLmVuZCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoY29kZSkpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaGVja3N1bSAtPSBtdWx0aXBsaWVyICogcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGNoZWNrc3VtICUgMTAzICE9PSByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgbGFzdCBjb2RlIGZyb20gcmVzdWx0IChjaGVja3N1bSlcbiAgICAgICAgaWYgKHJlbW92ZUxhc3RDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UocmVzdWx0Lmxlbmd0aCAtIDEsIDEpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogY29kZS5lbmQsXG4gICAgICAgICAgICBjb2Rlc2V0OiBjb2Rlc2V0IGFzIG51bWJlcixcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmRJbmZvOiBjb2RlLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlSW5mbyk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIGNhbGN1bGF0ZUNvcnJlY3Rpb24oZXhwZWN0ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbm9ybWFsaXplZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBpbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICAgICAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGgsXG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkID0gMCxcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkICs9IG5vcm1hbGl6ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtRXhwZWN0ZWQgLyBzdW1Ob3JtYWxpemVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTEyOFJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVSZWFkZXJDb25maWcsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XHJcblxyXG4vLyBjb25zdCBDT0RFX0xfU1RBUlQgPSAwO1xyXG5jb25zdCBDT0RFX0dfU1RBUlQgPSAxMDtcclxuZXhwb3J0IHsgQ09ERV9HX1NUQVJUIH07XHJcbmNvbnN0IFNUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMV07XHJcbmNvbnN0IE1JRERMRV9QQVRURVJOID0gWzEsIDEsIDEsIDEsIDFdO1xyXG5leHBvcnQgeyBNSURETEVfUEFUVEVSTiB9O1xyXG5jb25zdCBFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiA9IFsxLCAxLCAyXTtcclxuY29uc3QgQ09ERV9QQVRURVJOID0gW1xyXG4gICAgWzMsIDIsIDEsIDFdLFxyXG4gICAgWzIsIDIsIDIsIDFdLFxyXG4gICAgWzIsIDEsIDIsIDJdLFxyXG4gICAgWzEsIDQsIDEsIDFdLFxyXG4gICAgWzEsIDEsIDMsIDJdLFxyXG4gICAgWzEsIDIsIDMsIDFdLFxyXG4gICAgWzEsIDEsIDEsIDRdLFxyXG4gICAgWzEsIDMsIDEsIDJdLFxyXG4gICAgWzEsIDIsIDEsIDNdLFxyXG4gICAgWzMsIDEsIDEsIDJdLFxyXG4gICAgWzEsIDEsIDIsIDNdLFxyXG4gICAgWzEsIDIsIDIsIDJdLFxyXG4gICAgWzIsIDIsIDEsIDJdLFxyXG4gICAgWzEsIDEsIDQsIDFdLFxyXG4gICAgWzIsIDMsIDEsIDFdLFxyXG4gICAgWzEsIDMsIDIsIDFdLFxyXG4gICAgWzQsIDEsIDEsIDFdLFxyXG4gICAgWzIsIDEsIDMsIDFdLFxyXG4gICAgWzMsIDEsIDIsIDFdLFxyXG4gICAgWzIsIDEsIDEsIDNdLFxyXG5dO1xyXG5jb25zdCBDT0RFX0ZSRVFVRU5DWSA9IFswLCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XTtcclxuLy8gY29uc3QgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xyXG5jb25zdCBBVkdfQ09ERV9FUlJPUiA9IDAuNDg7XHJcblxyXG5jbGFzcyBFQU5SZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcclxuICAgIEZPUk1BVCA9ICdlYW5fMTMnO1xyXG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xyXG4gICAgU1RPUF9QQVRURVJOID0gWzEsIDEsIDFdOyAvLyBUT0RPOiBkb2VzIHRoaXMgbmVlZCB0byBiZSBpbiB0aGUgY2xhc3M/XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xyXG4gICAgICAgIHN1cGVyKG1lcmdlKHsgc3VwcGxlbWVudHM6IFtdIH0sIGNvbmZpZyksIHN1cHBsZW1lbnRzKTtcclxuICAgIH1cclxuICAgIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCB0cnlIYXJkZXI6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XHJcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBzdGFydDogMCxcclxuICAgICAgICAgICAgZW5kOiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRQYXR0ZXJuJywgcGF0dGVybiwgb2Zmc2V0LCBpc1doaXRlLCB0cnlIYXJkZXIsIGVwc2lsb24pO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuICAgICAgICBpZiAoIW9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGAqIGxvb3AgaT0ke29mZnNldH0gbGVuPSR7dGhpcy5fcm93Lmxlbmd0aH0gaXNXaGl0ZT0ke2lzV2hpdGV9IGNvdW50ZXJQb3M9JHtjb3VudGVyUG9zfWApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gKz0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogbWF0Y2hQYXR0ZXJuJywgZXJyb3IsIGNvdW50ZXIsIHBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24gJiYgYmVzdE1hdGNoLmVycm9yICYmIGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBjb3VudGVyLnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZmluZFBhdHRlcm4gYW5kIGRlY29kZUNvZGUgYXBwZWFyIHRvIHNoYXJlIHF1aXRlIHNpbWlsYXIgY29kZSwgY2FuIGl0IGJlIHJlZHVjZWQ/XHJcbiAgICBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb2RlcmFuZ2U/OiBudW1iZXIpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlJywgc3RhcnQsIGNvZGVyYW5nZSk7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcclxuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVJbmZvID0ge1xyXG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgY29kZTogLTEsXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgZW5kOiBzdGFydFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xyXG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tvZmZzZXRdO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlcmFuZ2UpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYmVmb3JlIGxlbmd0aCcpO1xyXG4gICAgICAgICAgICBjb2RlcmFuZ2UgPSBDT0RFX1BBVFRFUk4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBhZnRlciBsZW5ndGgnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBjb2RlcmFuZ2U7IGNvZGUrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPiBlcHNpbG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcclxuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm91bmQgPyBiZXN0TWF0Y2ggOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kU3RhcnQnKTtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xyXG4gICAgICAgIGxldCBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHN0YXJ0SW5mbz0nLCBKU09OLnN0cmluZ2lmeShzdGFydEluZm8pKTtcclxuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgc3RhcnRJbmZvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcclxuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZyBudWxsJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogY2FsY3VsYXRlRmlyc3REaWdpdCcsIGNvZGVGcmVxdWVuY3kpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENPREVfRlJFUVVFTkNZW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgaSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF5bG9hZCcsIGluQ29kZSwgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xyXG4gICAgICAgIGxldCBvdXRDb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSB7IC4uLmluQ29kZSB9O1xyXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMHgwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICBvdXRDb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvdXRDb2RlLmVuZCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlPScsIG91dENvZGUpO1xyXG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xyXG4gICAgICAgICAgICAgICAgKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLT0gQ09ERV9HX1NUQVJUO1xyXG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg1IC0gaSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDAgPDwgKDUgLSBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XHJcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZmlyc3REaWdpdCA9IHRoaXMuX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeSk7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0RGlnaXQ9JywgZmlyc3REaWdpdCk7XHJcbiAgICAgICAgaWYgKGZpcnN0RGlnaXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoZmlyc3REaWdpdCk7XHJcblxyXG4gICAgICAgIGxldCBtaWRkbGVQYXR0ZXJuID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIG91dENvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRQYXR0ZXJuPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcclxuXHJcbiAgICAgICAgaWYgKG1pZGRsZVBhdHRlcm4gPT09IG51bGwgfHwgIW1pZGRsZVBhdHRlcm4uZW5kKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG1pZGRsZVBhdHRlcm4pO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICBtaWRkbGVQYXR0ZXJuID0gdGhpcy5fZGVjb2RlQ29kZShtaWRkbGVQYXR0ZXJuIS5lbmQsIENPREVfR19TVEFSVCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghbWlkZGxlUGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChtaWRkbGVQYXR0ZXJuIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCByZXN1bHQ9JywgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBkZWNvZGVkQ29kZXM9JywgZGVjb2RlZENvZGVzKTtcclxuICAgICAgICByZXR1cm4gbWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlJywgSlNPTi5zdHJpbmdpZnkoZW5kSW5mbykpO1xyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCk7XHJcblxyXG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgSlNPTi5zdHJpbmdpZnkoZW5kSW5mbykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRFbmQnLCBvZmZzZXQsIGlzV2hpdGUpO1xyXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBpc1doaXRlLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBfY2hlY2tzdW0nLCByZXN1bHQpO1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdW0gKj0gMztcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xyXG4gICAgICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBjaGVja3N1bScsIHN1bSAlIDEwID09PSAwKTtcclxuICAgICAgICByZXR1cm4gc3VtICUgMTAgPT09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZGVjb2RlRXh0ZW5zaW9ucyhvZmZzZXQ6IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBvZmZzZXQpO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLCBzdGFydCwgZmFsc2UsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zJywgdGhpcy5zdXBwbGVtZW50cyk7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoZXJlIGFyZSAnLCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aCwgJyBzdXBwbGVtZW50cycpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZXh0ZW5zaW9ucyBsb29wJywgaSwgdGhpcy5zdXBwbGVtZW50c1tpXSwgdGhpcy5zdXBwbGVtZW50c1tpXS5fZGVjb2RlKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnN1cHBsZW1lbnRzW2ldLl9kZWNvZGUodGhpcy5fcm93LCBzdGFydEluZm8uZW5kKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUgcmVzdWx0PScsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LmNvZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZm8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcmVzdWx0LmVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQuZGVjb2RlZENvZGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuc3VwcGxlbWVudHNbaV0uRk9STUFULFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKiBkZWNvZGVFeHRlbnNpb25zIGVycm9yIGluICcsIHRoaXMuc3VwcGxlbWVudHNbaV0sICc6ICcsIGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlRXh0ZW5zaW9ucycpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHJvdyk7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHN0YXJ0KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xyXG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IG5ldyBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4oKTtcclxuICAgICAgICBsZXQgcmVzdWx0SW5mbzogQmFyY29kZSB8IHt9ID0ge307XHJcbiAgICAgICAgbGV0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG5cclxuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlUG9zaXRpb24gfCBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XHJcblxyXG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29kZSA9IHRoaXMuX2ZpbmRFbmQoY29kZS5lbmQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrc3VtXHJcbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja3N1bShyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoaXMuc3VwcGxlbWVudHM9JywgdGhpcy5zdXBwbGVtZW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdXBwbGVtZW50ID0gdGhpcy5fZGVjb2RlRXh0ZW5zaW9ucyhjb2RlLmVuZCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zIHJldHVybnMnLCBzdXBwbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50LmRlY29kZWRDb2Rlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDb2RlID0gc3VwcGxlbWVudC5kZWNvZGVkQ29kZXNbc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMubGVuZ3RoIC0gMV0gYXMgQmFyY29kZUluZm87XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogbGFzdENvZGUuc3RhcnQgKyAoKChsYXN0Q29kZS5lbmQgLSBsYXN0Q29kZS5zdGFydCkgLyAyKSB8IDApLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBsYXN0Q29kZS5lbmRcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0SW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIHN1cHBsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJykgKyBzdXBwbGVtZW50LmNvZGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcclxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcclxuICAgICAgICAgICAgc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXHJcbiAgICAgICAgICAgIC4uLnJlc3VsdEluZm8sXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRUFOUmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xyXG5cclxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAqJC8rJSc7XHJcbmNvbnN0IEFMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KFsuLi5BTFBIQUJFVEhfU1RSSU5HXS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcclxuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXHJcbiAgICAweDAzNCwgMHgxMjEsIDB4MDYxLCAweDE2MCwgMHgwMzEsIDB4MTMwLCAweDA3MCwgMHgwMjUsIDB4MTI0LCAweDA2NCwgMHgxMDksIDB4MDQ5LFxyXG4gICAgMHgxNDgsIDB4MDE5LCAweDExOCwgMHgwNTgsIDB4MDBELCAweDEwQywgMHgwNEMsIDB4MDFDLCAweDEwMywgMHgwNDMsIDB4MTQyLCAweDAxMywgMHgxMTIsIDB4MDUyLCAweDAwNywgMHgxMDYsXHJcbiAgICAweDA0NiwgMHgwMTYsIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MDk0LCAweDBBOCwgMHgwQTIsIDB4MDhBLCAweDAyQSxcclxuXSk7XHJcbmNvbnN0IEFTVEVSSVNLID0gMHgwOTQ7XHJcblxyXG5jbGFzcyBDb2RlMzlSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcclxuICAgIEZPUk1BVCA9ICdjb2RlXzM5JztcclxuXHJcbiAgICBfZmluZFN0YXJ0KCkge1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcclxuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XHJcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHN0YXJ0IHBhdHRlcm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBBU1RFUklTSykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbN10gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbOF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIF90b1BhdHRlcm4oY291bnRlcnM6IFVpbnQxNkFycmF5KSB7XHJcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IG1heE5hcnJvd1dpZHRoID0gMDtcclxuICAgICAgICBsZXQgbnVtV2lkZUJhcnMgPSBudW1Db3VudGVycztcclxuICAgICAgICBsZXQgd2lkZUJhcldpZHRoID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKG51bVdpZGVCYXJzID4gMykge1xyXG4gICAgICAgICAgICBtYXhOYXJyb3dXaWR0aCA9IHRoaXMuX2ZpbmROZXh0V2lkdGgoY291bnRlcnMsIG1heE5hcnJvd1dpZHRoKTtcclxuICAgICAgICAgICAgbnVtV2lkZUJhcnMgPSAwO1xyXG4gICAgICAgICAgICBsZXQgcGF0dGVybiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSAtIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZUJhcldpZHRoICs9IGNvdW50ZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobnVtV2lkZUJhcnMgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnMgJiYgbnVtV2lkZUJhcnMgPiAwOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1XaWRlQmFycy0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ZXJzW2ldICogMikgPj0gd2lkZUJhcldpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIF9maW5kTmV4dFdpZHRoKGNvdW50ZXJzOiBVaW50MTZBcnJheSwgY3VycmVudDogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IG1pbldpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPCBtaW5XaWR0aCAmJiBjb3VudGVyc1tpXSA+IGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gY291bnRlcnNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtaW5XaWR0aDtcclxuICAgIH07XHJcblxyXG4gICAgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkpIHtcclxuICAgICAgICBjb25zdCBwYXR0ZXJuU2l6ZSA9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IG5leHRTdGFydCAtIGxhc3RTdGFydCAtIHBhdHRlcm5TaXplO1xyXG4gICAgICAgIGlmICgodHJhaWxpbmdXaGl0ZXNwYWNlRW5kICogMykgPj0gcGF0dGVyblNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XHJcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcclxuXHJcbiAgICAgICAgaWYgKCFzdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xyXG5cclxuICAgICAgICBsZXQgZGVjb2RlZENoYXI7XHJcbiAgICAgICAgbGV0IGxhc3RTdGFydDogbnVtYmVyO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgY291bnRlcnMgPSB0aGlzLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpIGFzIFVpbnQxNkFycmF5O1xyXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcclxuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XHJcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xyXG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XHJcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xyXG4gICAgICAgICAgICBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgbmV4dFN0YXJ0KTtcclxuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcclxuICAgICAgICByZXN1bHQucG9wKCk7XHJcblxyXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcclxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXHJcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlSZWFkZXI7XHJcbiIsImltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XHJcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xyXG5cclxuY29uc3QgcGF0dGVybnMgPSB7XHJcbiAgICBJT1E6IC9bSU9RXS9nLFxyXG4gICAgQVowOTogL1tBLVowLTldezE3fS8sXHJcbn07XHJcblxyXG5jbGFzcyBDb2RlMzlWSU5SZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xyXG4gICAgRk9STUFUID0gJ2NvZGVfMzlfdmluJztcclxuXHJcbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXHJcbiAgICBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gISFjb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyaWJiZWQgZnJvbTpcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy96eGluZy9ibG9iL21hc3Rlci9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9jbGllbnQvcmVzdWx0L1ZJTlJlc3VsdFBhcnNlci5qYXZhXHJcbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLl9kZWNvZGUocm93LCBzdGFydCk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29kZSA9IHJlc3VsdC5jb2RlO1xyXG5cclxuICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHBhdHRlcm5zLklPUSwgJycpO1xyXG5cclxuICAgICAgICBpZiAoIWNvZGUubWF0Y2gocGF0dGVybnMuQVowOSkpIHtcclxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBBWjA5IHBhdHRlcm4gY29kZTonLCBjb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5VklOUmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuXHJcbi8vIGNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OS0kOi8uK0FCQ0QnO1xyXG5jb25zdCBBTFBIQUJFVCA9IFs0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDUsIDM2LCA1OCwgNDcsIDQ2LCA0MywgNjUsIDY2LCA2NywgNjhdO1xyXG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID1cclxuICAgIFsweDAwMywgMHgwMDYsIDB4MDA5LCAweDA2MCwgMHgwMTIsIDB4MDQyLCAweDAyMSwgMHgwMjQsIDB4MDMwLCAweDA0OCwgMHgwMGMsIDB4MDE4LFxyXG4gICAgICAgIDB4MDQ1LCAweDA1MSwgMHgwNTQsIDB4MDE1LCAweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XHJcbmNvbnN0IFNUQVJUX0VORCA9IFsweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XHJcbmNvbnN0IE1JTl9FTkNPREVEX0NIQVJTID0gNDtcclxuY29uc3QgTUFYX0FDQ0VQVEFCTEUgPSAyLjA7XHJcbmNvbnN0IFBBRERJTkcgPSAxLjU7XHJcblxyXG5pbnRlcmZhY2UgVGhyZXNob2xkU2l6ZSB7XHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICBjb3VudHM6IG51bWJlcixcclxuICAgIG1pbjogbnVtYmVyLFxyXG4gICAgbWF4OiBudW1iZXIsXHJcbn07XHJcblxyXG5pbnRlcmZhY2UgVGhyZXNob2xkIHtcclxuICAgIHNwYWNlOiB7XHJcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxyXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXHJcbiAgICB9LFxyXG4gICAgYmFyOiB7XHJcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxyXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXHJcbiAgICB9LFxyXG59O1xyXG5cclxuY2xhc3MgTmV3Q29kYWJhclJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xyXG4gICAgX2NvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICBGT1JNQVQgPSAnY29kYWJhcic7XHJcblxyXG4gICAgX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcclxuICAgICAgICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgbWF4ID0gMDtcclxuICAgICAgICBsZXQgY291bnRlciA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBjb3VudGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBjb3VudGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKChtaW4gKyBtYXgpIC8gMi4wKSB8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIF90b1BhdHRlcm4ob2Zmc2V0OiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IDc7XHJcbiAgICAgICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgbnVtQ291bnRlcnM7XHJcblxyXG4gICAgICAgIGlmIChlbmQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYmFyVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCwgZW5kKTtcclxuICAgICAgICBjb25zdCBzcGFjZVRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQgKyAxLCBlbmQpO1xyXG5cclxuICAgICAgICBsZXQgYml0bWFzayA9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSk7XHJcbiAgICAgICAgbGV0IHRocmVzaG9sZCA9IDA7XHJcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcclxuICAgICAgICAgICAgdGhyZXNob2xkID0gKGkgJiAxKSA9PT0gMCA/IGJhclRocmVzaG9sZCA6IHNwYWNlVGhyZXNob2xkO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnRlcnNbb2Zmc2V0ICsgaV0gPiB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gYml0bWFzaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiaXRtYXNrID4+PSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcbiAgICB9O1xyXG5cclxuICAgIF9pc1N0YXJ0RW5kKHBhdHRlcm46IG51bWJlcikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU1RBUlRfRU5ELmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChTVEFSVF9FTkRbaV0gPT09IHBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgX3N1bUNvdW50ZXJzKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG4gICAgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KTtcclxuICAgICAgICBsZXQgZW5kID0gc3RhcnQ7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fY291bnRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihpKTtcclxuICAgICAgICAgICAgaWYgKHBhdHRlcm4gIT09IC0xICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IExvb2sgZm9yIHdoaXRlc3BhY2UgYWhlYWRcclxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMuX3N1bUNvdW50ZXJzKDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhpLCBpICsgOCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydENvdW50ZXI6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kQ291bnRlcjogaSArIDgsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2FsY3VsYXRlUGF0dGVybkxlbmd0aChvZmZzZXQ6IG51bWJlcikge1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNzsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuICAgIF92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0Q291bnRlcjogbnVtYmVyLCBlbmRDb3VudGVyOiBudW1iZXIpIHtcclxuICAgICAgICBpZiAoKHN0YXJ0Q291bnRlciAtIDEgPD0gMClcclxuICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbc3RhcnRDb3VudGVyIC0gMV0gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoc3RhcnRDb3VudGVyKSAvIDIuMCkpIHtcclxuICAgICAgICAgICAgaWYgKChlbmRDb3VudGVyICsgOCA+PSB0aGlzLl9jb3VudGVycy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tlbmRDb3VudGVyICsgN10gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoZW5kQ291bnRlcikgLyAyLjApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFyVG9QYXR0ZXJuKGNoYXI6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChBTFBIQUJFVFtpXSA9PT0gY2hhckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDSEFSQUNURVJfRU5DT0RJTkdTW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAweDA7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3JpemF0aW9uOiBUaHJlc2hvbGQgPSB7XHJcbiAgICAgICAgICAgICAgICBzcGFjZToge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYmFyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcclxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcclxuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAyID8gY2F0ZWdvcml6YXRpb24uYmFyIDogY2F0ZWdvcml6YXRpb24uc3BhY2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XHJcbiAgICAgICAgICAgICAgICBjYXQuc2l6ZSArPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcclxuICAgICAgICAgICAgICAgIGNhdC5jb3VudHMrKztcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zICs9IDg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAoWydzcGFjZScsICdiYXInXSBhcyBjb25zdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld2tpbmQgPSBjYXRlZ29yaXphdGlvbltrZXldO1xyXG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWluID1cclxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKG5ld2tpbmQubmFycm93LnNpemUgLyBuZXdraW5kLm5hcnJvdy5jb3VudHMgKyBuZXdraW5kLndpZGUuc2l6ZSAvIG5ld2tpbmQud2lkZS5jb3VudHMpIC8gMik7XHJcbiAgICAgICAgICAgIG5ld2tpbmQubmFycm93Lm1heCA9IE1hdGguY2VpbChuZXdraW5kLndpZGUubWluKTtcclxuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1heCA9IE1hdGguY2VpbCgobmV3a2luZC53aWRlLnNpemUgKiBNQVhfQUNDRVBUQUJMRSArIFBBRERJTkcpIC8gbmV3a2luZC53aWRlLmNvdW50cyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSB0aGlzLl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdCwgc3RhcnRDb3VudGVyKTtcclxuICAgICAgICBsZXQgcG9zID0gc3RhcnRDb3VudGVyO1xyXG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA2OyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IChqICYgMSkgPT09IDAgPyB0aHJlc2hvbGRzLmJhciA6IHRocmVzaG9sZHMuc3BhY2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA8IGNhdC5taW4gfHwgc2l6ZSA+IGNhdC5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvcyArPSA4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XHJcblxyXG4gICAgICAgIHRoaXMuX2NvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKCk7XHJcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcclxuICAgICAgICBpZiAoIXN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlcjtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XHJcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4obmV4dFN0YXJ0KTtcclxuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XHJcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xyXG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gODtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAobmV4dFN0YXJ0IDwgdGhpcy5fY291bnRlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgLy8gdmVyaWZ5IGVuZFxyXG4gICAgICAgIGlmICgocmVzdWx0Lmxlbmd0aCAtIDIpIDwgTUlOX0VOQ09ERURfQ0hBUlMgfHwgIXRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB2ZXJpZnkgZW5kIHdoaXRlIHNwYWNlXHJcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIsIG5leHRTdGFydCAtIDgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZVJlc3VsdChyZXN1bHQsIHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmV4dFN0YXJ0ID0gbmV4dFN0YXJ0ID4gdGhpcy5fY291bnRlcnMubGVuZ3RoID8gdGhpcy5fY291bnRlcnMubGVuZ3RoIDogbmV4dFN0YXJ0O1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0LnN0YXJ0ICsgdGhpcy5fc3VtQ291bnRlcnMoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGVuZCxcclxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsIC8vIFRPRE86IGkgdGhpbmsgaXQgc2hvdWxkIG5vdCBiZSByZXF1aXJlZCB0byByZXR1cm4gZm9ybWF0IGZyb20gdGhpcywgYXMgYmFyY29kZV9yZWFkZXIgZm9yY2Ugc2V0cyB0aGUgZm9ybWF0IGFueXdheVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOZXdDb2RhYmFyUmVhZGVyO1xyXG4iLCJpbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgVVBDUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAndXBjX2EnO1xuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEVBTlJlYWRlci5wcm90b3R5cGUuX2RlY29kZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmNvZGUgJiYgcmVzdWx0LmNvZGUubGVuZ3RoID09PSAxMyAmJiByZXN1bHQuY29kZS5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgcmVzdWx0LmNvZGUgPSByZXN1bHQuY29kZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVVBDUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQsIE1JRERMRV9QQVRURVJOIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgRUFOOFJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl84JztcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IGluQ29kZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IHRoaXMuX2ZpbmRQYXR0ZXJuKE1JRERMRV9QQVRURVJOLCBjb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2RlIGFzIEJhcmNvZGVJbmZvO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjhSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUsIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cblxuY2xhc3MgRUFOMlJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl8yJztcbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcblxuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDEgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDIgfHwgKHBhcnNlSW50KHJlc3VsdC5qb2luKCcnKSkgJSA0KSAhPT0gY29kZUZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kOiAoY29kZSBhcyBCYXJjb2RlSW5mbykuZW5kLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiAoc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbikuc3RhcnQsXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFOMlJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGUsIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgQ0hFQ0tfRElHSVRfRU5DT0RJTkdTID0gWzI0LCAyMCwgMTgsIDE3LCAxMiwgNiwgMywgMTAsIDksIDVdO1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3k6IG51bWJlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ0hFQ0tfRElHSVRfRU5DT0RJTkdTW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICBsZXQgc3VtID0gMDtcblxuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgc3VtICo9IDM7XG4gICAgcmV0dXJuIHN1bSAlIDEwO1xufVxuXG5jbGFzcyBFQU41UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzUnO1xuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNSAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNCAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IDQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0KSAhPT0gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kOiAoY29kZSBhcyBCYXJjb2RlSW5mbykuZW5kLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiAoc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbikuc3RhcnQsXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFONVJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgVVBDRVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgQ09ERV9GUkVRVUVOQ1kgPSBbXG4gICAgICAgIFsgNTYsIDUyLCA1MCwgNDksIDQ0LCAzOCwgMzUsIDQyLCA0MSwgMzcgXSxcbiAgICAgICAgWzcsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdXTtcbiAgICBTVE9QX1BBVFRFUk4gPSBbMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogN107XG4gICAgRk9STUFUID0gJ3VwY19lJztcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRDb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvdXRDb2RlLmVuZCk7XG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA9IChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC0gQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gKDEgPDwgKDUgLSBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChvdXRDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5LCByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0Q29kZSBhcyBCYXJjb2RlSW5mbztcbiAgICB9O1xuXG4gICAgX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5OiBudW1iZXIsIHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBmb3IgKGxldCBuclN5c3RlbSA9IDA7IG5yU3lzdGVtIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IG5yU3lzdGVtKyspe1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChuclN5c3RlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfY29udmVydFRvVVBDQShyZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgbGV0IHVwY2EgPSBbcmVzdWx0WzBdXTtcbiAgICAgICAgY29uc3QgbGFzdERpZ2l0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAyXTtcblxuICAgICAgICBpZiAobGFzdERpZ2l0IDw9IDIpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgMykpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbbGFzdERpZ2l0LCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSgzLCA2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSAzKSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDQpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDQsIDYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDQpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNSkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMCwgcmVzdWx0WzVdXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDYpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIGxhc3REaWdpdF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBjYS5wdXNoKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gdXBjYTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jaGVja3N1bSh0aGlzLl9jb252ZXJ0VG9VUENBKHJlc3VsdCkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZEVuZChvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICByZXR1cm4gc3VwZXIuX2ZpbmRFbmQob2Zmc2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVVBDRVJlYWRlcjtcbiIsIi8vIFRPRE86IGkyb2Y1X3JlYWRlciBhbmQgMm9mNV9yZWFkZXIgc2hhcmUgdmVyeSBzaW1pbGFyIGNvZGUsIG1ha2UgdXNlIG9mIHRoYXRcclxuXHJcbmltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVSZWFkZXJDb25maWcsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XHJcblxyXG5jb25zdCBOID0gMTtcclxuY29uc3QgVyA9IDM7XHJcblxyXG5jbGFzcyBJMm9mNVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xyXG4gICAgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcclxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcclxuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zODtcclxuXHJcbiAgICBTVEFSVF9QQVRURVJOID0gW04sIE4sIE4sIE5dO1xyXG4gICAgU1RPUF9QQVRURVJOID0gW04sIE4sIFddO1xyXG4gICAgQ09ERV9QQVRURVJOID0gW1xyXG4gICAgICAgIFtOLCBOLCBXLCBXLCBOXSxcclxuICAgICAgICBbVywgTiwgTiwgTiwgV10sXHJcbiAgICAgICAgW04sIFcsIE4sIE4sIFddLFxyXG4gICAgICAgIFtXLCBXLCBOLCBOLCBOXSxcclxuICAgICAgICBbTiwgTiwgVywgTiwgV10sXHJcbiAgICAgICAgW1csIE4sIFcsIE4sIE5dLFxyXG4gICAgICAgIFtOLCBXLCBXLCBOLCBOXSxcclxuICAgICAgICBbTiwgTiwgTiwgVywgV10sXHJcbiAgICAgICAgW1csIE4sIE4sIFcsIE5dLFxyXG4gICAgICAgIFtOLCBXLCBOLCBXLCBOXSxcclxuICAgIF07XHJcbiAgICBNQVhfQ09SUkVDVElPTl9GQUNUT1IgPSA1O1xyXG4gICAgRk9STUFUID0gJ2kyb2Y1JztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzOiBCYXJjb2RlUmVhZGVyQ29uZmlnKSB7XHJcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBub3JtYWxpemVCYXJTcGFjZVdpZHRoOiBmYWxzZSB9LCBvcHRzKSk7XHJcbiAgICAgICAgaWYgKG9wdHMubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xyXG4gICAgICAgICAgICB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SID0gMC4zODtcclxuICAgICAgICAgICAgdGhpcy5BVkdfQ09ERV9FUlJPUiA9IDAuMDk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gb3B0cztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBfbWF0Y2hQYXR0ZXJuKGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPikge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJTdW0gPSBbMCwgMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVTdW0gPSBbMCwgMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb24gPSBbMCwgMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25SYXRpbyA9IHRoaXMuTUFYX0NPUlJFQ1RJT05fRkFDVE9SO1xyXG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlID0gMSAvIGNvcnJlY3Rpb25SYXRpbztcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY291bnRlclN1bVtpICUgMl0gKz0gY291bnRlcltpXTtcclxuICAgICAgICAgICAgICAgIGNvZGVTdW1baSAlIDJdICs9IGNvZGVbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IGNvZGVTdW1bMF0gLyBjb3VudGVyU3VtWzBdO1xyXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gY29kZVN1bVsxXSAvIGNvdW50ZXJTdW1bMV07XHJcblxyXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblswXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XHJcbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMV0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzFdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcclxuICAgICAgICAgICAgdGhpcy5iYXJTcGFjZVJhdGlvID0gY29ycmVjdGlvbjtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldICo9IHRoaXMuYmFyU3BhY2VSYXRpb1tpICUgMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9tYXRjaFBhdHRlcm4uY2FsbCh0aGlzLCBjb3VudGVyLCBjb2RlKTtcclxuICAgIH07XHJcblxyXG4gICAgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0PzogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuID0gZmFsc2UsIHRyeUhhcmRlcjogYm9vbGVhbiA9IGZhbHNlKTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XHJcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xyXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcclxuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIGNvZGU6IC0xLFxyXG4gICAgICAgICAgICBzdGFydDogMCxcclxuICAgICAgICAgICAgZW5kOiAwLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xyXG5cclxuICAgICAgICBpc1doaXRlID0gaXNXaGl0ZSB8fCBmYWxzZTtcclxuICAgICAgICB0cnlIYXJkZXIgPSB0cnlIYXJkZXIgfHwgZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtID0gY291bnRlci5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIF9maW5kU3RhcnQoKSB7XHJcbiAgICAgICAgbGV0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcclxuXHJcbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyA0KTtcclxuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogMTA7XHJcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBfZmluZEVuZCgpIHtcclxuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xyXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUT1BfUEFUVEVSTik7XHJcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcclxuICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xyXG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XHJcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xyXG5cclxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIF9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyOiBBcnJheTxBcnJheTxudW1iZXI+Pikge1xyXG4gICAgICAgIGNvbnN0IGNvZGVzOiBBcnJheTxCYXJjb2RlSW5mbz4gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyUGFpci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb3VudGVyUGFpcltpXSk7XHJcbiAgICAgICAgICAgIGlmICghY29kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29kZXMucHVzaChjb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBfZGVjb2RlQ29kZShjb3VudGVyOiBBcnJheTxudW1iZXI+KTogQmFyY29kZUluZm8gfCBudWxsIHtcclxuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcclxuXHJcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xyXG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgY29kZTogLTEsXHJcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxyXG4gICAgICAgICAgICBlbmQ6IDAsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCB0aGlzLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IGVwc2lsb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4pIHtcclxuICAgICAgICBsZXQgcG9zID0gMDtcclxuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXJQYWlyID0gW1swLCAwLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDAsIDBdXTtcclxuICAgICAgICBsZXQgY29kZXM6IEJhcmNvZGVJbmZvW10gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJQYWlyWzBdW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJQYWlyWzFdW2ldID0gY291bnRlcnNbcG9zICsgMV0gKiB0aGlzLmJhclNwYWNlUmF0aW9bMV07XHJcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb2RlcyA9IHRoaXMuX2RlY29kZVBhaXIoY291bnRlclBhaXIpO1xyXG4gICAgICAgICAgICBpZiAoIWNvZGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2Rlc1tpXS5jb2RlICsgJycpO1xyXG4gICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlcztcclxuICAgIH07XHJcblxyXG4gICAgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcclxuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcclxuICAgIH07XHJcblxyXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcclxuICAgICAgICB2YXIgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4oKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XHJcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kRW5kKCk7XHJcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoc3RhcnRJbmZvLmVuZCwgZW5kSW5mby5zdGFydCwgZmFsc2UpO1xyXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVycykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIgIT09IDAgfHxcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5sZW5ndGggPCA2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxyXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEkyb2Y1UmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcblxyXG5jb25zdCBOID0gMTtcclxuY29uc3QgVyA9IDM7XHJcbmNvbnN0IFNUQVJUX1BBVFRFUk4gPSBbVywgTiwgVywgTiwgTiwgTl07XHJcbmNvbnN0IFNUT1BfUEFUVEVSTiA9IFtXLCBOLCBOLCBOLCBXXTtcclxuY29uc3QgQ09ERV9QQVRURVJOID0gW1xyXG4gICAgW04sIE4sIFcsIFcsIE5dLFxyXG4gICAgW1csIE4sIE4sIE4sIFddLFxyXG4gICAgW04sIFcsIE4sIE4sIFddLFxyXG4gICAgW1csIFcsIE4sIE4sIE5dLFxyXG4gICAgW04sIE4sIFcsIE4sIFddLFxyXG4gICAgW1csIE4sIFcsIE4sIE5dLFxyXG4gICAgW04sIFcsIFcsIE4sIE5dLFxyXG4gICAgW04sIE4sIE4sIFcsIFddLFxyXG4gICAgW1csIE4sIE4sIFcsIE5dLFxyXG4gICAgW04sIFcsIE4sIFcsIE5dLFxyXG5dO1xyXG5jb25zdCBTVEFSVF9QQVRURVJOX0xFTkdUSCA9IFNUQVJUX1BBVFRFUk4ucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKTtcclxuXHJcbmNsYXNzIFR3b09mRml2ZVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xyXG4gICAgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcclxuXHJcbiAgICBGT1JNQVQgPSAnMm9mNSc7XHJcblxyXG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjc4O1xyXG5cclxuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcclxuXHJcbiAgICBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZSA9IGZhbHNlLCB0cnlIYXJkZXIgPSBmYWxzZSk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IFtdO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBjb2RlOiAtMSxcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgIGxldCBlcnJvciA9IDA7XHJcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XHJcblxyXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudGVyW2ldID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcclxuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBfZmluZFN0YXJ0KCkge1xyXG4gICAgICAgIGxldCBzdGFydEluZm8gPSBudWxsO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcclxuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIFNUQVJUX1BBVFRFUk5fTEVOR1RIKTtcclxuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogNTtcclxuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcclxuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcclxuICAgIH1cclxuXHJcbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKSB7XHJcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcclxuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgX2ZpbmRFbmQoKSB7XHJcbiAgICAgICAgLy8gVE9ETzogcmV2ZXJzZSwgZm9sbG93ZWQgYnkgc29tZSBjYWxjcywgZm9sbG93ZWQgYnkgYW5vdGhlciByZXZlcnNlPyByZWFsbHk/XHJcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XHJcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcclxuICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xyXG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XHJcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xyXG5cclxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcclxuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcclxuICAgIH1cclxuXHJcbiAgICBfZGVjb2RlQ29kZShjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4pIHtcclxuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcclxuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XHJcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBjb2RlOiAtMSxcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IENPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcclxuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBlcHNpbG9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbz4pIHtcclxuICAgICAgICBsZXQgcG9zID0gMDtcclxuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMF07XHJcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcclxuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXIpO1xyXG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGAke2NvZGUuY29kZX1gKTtcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xyXG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcclxuICAgICAgICBpZiAoIWVuZEluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XHJcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcclxuICAgICAgICBpZiAoIWNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcclxuICAgICAgICAgICAgc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVHdvT2ZGaXZlUmVhZGVyO1xyXG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcclxuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xyXG5cclxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZConO1xyXG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApKSk7XHJcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xyXG4gICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXHJcbiAgICAweDFBOCwgMHgxQTQsIDB4MUEyLCAweDE5NCwgMHgxOTIsIDB4MThBLCAweDE2OCwgMHgxNjQsIDB4MTYyLCAweDEzNCxcclxuICAgIDB4MTFBLCAweDE1OCwgMHgxNEMsIDB4MTQ2LCAweDEyQywgMHgxMTYsIDB4MUI0LCAweDFCMiwgMHgxQUMsIDB4MUE2LFxyXG4gICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXHJcbiAgICAweDE2RSwgMHgxNzYsIDB4MUFFLCAweDEyNiwgMHgxREEsIDB4MUQ2LCAweDEzMiwgMHgxNUUsXHJcbl0pO1xyXG5jb25zdCBBU1RFUklTSyA9IDB4MTVFO1xyXG5cclxuY2xhc3MgQ29kZTkzUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XHJcbiAgICBGT1JNQVQgPSAnY29kZV85Myc7XHJcbiAgICBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpIHtcclxuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVycy5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcclxuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbm9ybWFsaXplZCA9IE1hdGgucm91bmQoY291bnRlcnNbaV0gKiA5IC8gc3VtKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPCAxIHx8IG5vcm1hbGl6ZWQgPiA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChpICYgMSkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9ybWFsaXplZDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IChwYXR0ZXJuIDw8IDEpIHwgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPDw9IG5vcm1hbGl6ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcbiAgICB9O1xyXG5cclxuICAgIF9maW5kU3RhcnQoKSB7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xyXG4gICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xyXG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcclxuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtICgoaSAtIHBhdHRlcm5TdGFydCkgLyA0KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZSh3aGl0ZVNwYWNlTXVzdFN0YXJ0LCBwYXR0ZXJuU3RhcnQsIDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls1XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcclxuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgX3ZlcmlmeUVuZChsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIpIHtcclxuICAgICAgICBpZiAobGFzdFN0YXJ0ID09PSBuZXh0U3RhcnQgfHwgIXRoaXMuX3Jvd1tuZXh0U3RhcnRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIF9kZWNvZGVFeHRlbmRlZChjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBjaGFyQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhciA9IGNoYXJBcnJheVtpXTtcclxuICAgICAgICAgICAgaWYgKGNoYXIgPj0gJ2EnICYmIGNoYXIgPD0gJ2QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IChsZW5ndGggLSAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyQXJyYXlbKytpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IG5leHRDaGFyLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGVjb2RlZENoYXI7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSA2NCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnRScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0YnICYmIG5leHRDaGFyIDw9ICdKJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDExKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnSycgJiYgbmV4dENoYXIgPD0gJ08nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdQJyAmJiBuZXh0Q2hhciA8PSAnUycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyA0Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1QnICYmIG5leHRDaGFyIDw9ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyogY29kZV85M19yZWFkZXIgX2RlY29kZUV4dGVuZGVkIGhpdCBkZWZhdWx0IGNhc2UsIHRoaXMgbWF5IGJlIGFuIGVycm9yJywgZGVjb2RlZENoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4sIGluZGV4OiBudW1iZXIsIG1heFdlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgYXJyYXlUb0NoZWNrID0gY2hhckFycmF5LnNsaWNlKDAsIGluZGV4KTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheVRvQ2hlY2subGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHdlaWdodGVkU3VtcyA9IGFycmF5VG9DaGVjay5yZWR1Y2UoKHN1bSwgY2hhciwgaSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSAoKChpICogLTEpICsgKGxlbmd0aCAtIDEpKSAlIG1heFdlaWdodCkgKyAxO1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEFMUEhBQkVULmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN1bSArICh3ZWlnaHQgKiB2YWx1ZSk7XHJcbiAgICAgICAgfSwgMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNoZWNrQ2hhciA9IEFMUEhBQkVUWyh3ZWlnaHRlZFN1bXMgJSA0NyldO1xyXG4gICAgICAgIHJldHVybiBjaGVja0NoYXIgPT09IGNoYXJBcnJheVtpbmRleF0uY2hhckNvZGVBdCgwKTtcclxuICAgIH07XHJcblxyXG4gICAgX3ZlcmlmeUNoZWNrc3VtcyhjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMiwgMjApXHJcbiAgICAgICAgICAgICYmIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDEsIDE1KTtcclxuICAgIH07XHJcblxyXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XHJcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcclxuICAgICAgICBpZiAoIXN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwXSk7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiB8IG51bGwgPSBbXTtcclxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XHJcbiAgICAgICAgbGV0IGxhc3RTdGFydDtcclxuICAgICAgICBsZXQgZGVjb2RlZENoYXI6IHN0cmluZyB8IG51bGw7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjb3VudGVycyA9IHRoaXMuX3RvQ291bnRlcnMobmV4dFN0YXJ0LCBjb3VudGVycykgYXMgVWludDE2QXJyYXk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xyXG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcclxuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XHJcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcclxuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XHJcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xyXG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xyXG4gICAgICAgIHJlc3VsdC5wb3AoKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlFbmQobGFzdFN0YXJ0LCBuZXh0U3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDaGVja3N1bXMocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCByZXN1bHQubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgLy8geWVzLCB0aGlzIGlzIGFuIGFzc2lnbiBpbnNpZGUgYW4gaWYuXHJcbiAgICAgICAgaWYgKChyZXN1bHQgPSB0aGlzLl9kZWNvZGVFeHRlbmRlZChyZXN1bHQpKSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IG5leHRTdGFydCxcclxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcclxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvZGU5M1JlYWRlcjtcclxuIiwiaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcclxuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XHJcblxyXG5jb25zdCBwYXR0ZXJucyA9IHtcclxuICAgIEFFSU86IC9bQUVJT10vZyxcclxuICAgIEFaMDk6IC9bQS1aMC05XS8sXHJcbn07XHJcblxyXG5jb25zdCBjb2RlMzJzZXQgPSAnMDEyMzQ1Njc4OUJDREZHSEpLTE1OUFFSU1RVVldYWVonO1xyXG5cclxuY2xhc3MgQ29kZTMyUmVhZGVyIGV4dGVuZHMgQ29kZTM5UmVhZGVyIHtcclxuICAgIEZPUk1BVCA9ICdjb2RlXzMyX3JlYWRlcic7XHJcblxyXG4gICAgX2RlY29kZUNvZGUzMihjb2RlOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoL1teMC05QkNERkdISktMTU5QUVJTVFVWV1hZWl0vLnRlc3QoY29kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXMgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXMgPSByZXMgKiAzMiArIGNvZGUzMnNldC5pbmRleE9mKGNvZGVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29kZTMyID0gJycgKyByZXM7XHJcbiAgICAgICAgaWYgKGNvZGUzMi5sZW5ndGggPCA5KSB7XHJcbiAgICAgICAgICAgIGNvZGUzMiA9ICgnMDAwMDAwMDAwJyArIGNvZGUzMikuc2xpY2UoLTkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ0EnICsgY29kZTMyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcclxuICAgIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiAhIWNvZGU7XHJcbiAgICB9XHJcblxyXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5fZGVjb2RlKHJvdywgc3RhcnQpO1xyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNvZGUgPSByZXN1bHQuY29kZTtcclxuXHJcbiAgICAgICAgaWYgKCFjb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5BRUlPLCAnJyk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb2RlMzIgPSB0aGlzLl9kZWNvZGVDb2RlMzIoY29kZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFjb2RlMzIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTMyO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29kZTMyUmVhZGVyO1xyXG4iLCJpbXBvcnQgQnJlc2VuaGFtIGZyb20gJy4vYnJlc2VuaGFtJztcclxuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcclxuaW1wb3J0IENvZGUxMjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMTI4X3JlYWRlcic7XHJcbmltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl9yZWFkZXInO1xyXG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3JlYWRlcic7XHJcbmltcG9ydCBDb2RlMzlWSU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlcic7XHJcbmltcG9ydCBDb2RhYmFyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RhYmFyX3JlYWRlcic7XHJcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19yZWFkZXInO1xyXG5pbXBvcnQgRUFOOFJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzhfcmVhZGVyJztcclxuaW1wb3J0IEVBTjJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl8yX3JlYWRlcic7XHJcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fNV9yZWFkZXInO1xyXG5pbXBvcnQgVVBDRVJlYWRlciBmcm9tICcuLi9yZWFkZXIvdXBjX2VfcmVhZGVyJztcclxuaW1wb3J0IEkyb2Y1UmVhZGVyIGZyb20gJy4uL3JlYWRlci9pMm9mNV9yZWFkZXInO1xyXG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4uL3JlYWRlci8yb2Y1X3JlYWRlcic7XHJcbmltcG9ydCBDb2RlOTNSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfOTNfcmVhZGVyJztcclxuaW1wb3J0IENvZGUzMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zMl9yZWFkZXInO1xyXG5cclxuY29uc3QgUkVBREVSUyA9IHtcclxuICAgIGNvZGVfMTI4X3JlYWRlcjogQ29kZTEyOFJlYWRlcixcclxuICAgIGVhbl9yZWFkZXI6IEVBTlJlYWRlcixcclxuICAgIGVhbl81X3JlYWRlcjogRUFONVJlYWRlcixcclxuICAgIGVhbl8yX3JlYWRlcjogRUFOMlJlYWRlcixcclxuICAgIGVhbl84X3JlYWRlcjogRUFOOFJlYWRlcixcclxuICAgIGNvZGVfMzlfcmVhZGVyOiBDb2RlMzlSZWFkZXIsXHJcbiAgICBjb2RlXzM5X3Zpbl9yZWFkZXI6IENvZGUzOVZJTlJlYWRlcixcclxuICAgIGNvZGFiYXJfcmVhZGVyOiBDb2RhYmFyUmVhZGVyLFxyXG4gICAgdXBjX3JlYWRlcjogVVBDUmVhZGVyLFxyXG4gICAgdXBjX2VfcmVhZGVyOiBVUENFUmVhZGVyLFxyXG4gICAgaTJvZjVfcmVhZGVyOiBJMm9mNVJlYWRlcixcclxuICAgICcyb2Y1X3JlYWRlcic6IFR3b09mRml2ZVJlYWRlcixcclxuICAgIGNvZGVfOTNfcmVhZGVyOiBDb2RlOTNSZWFkZXIsXHJcbiAgICBjb2RlXzMyX3JlYWRlcjogQ29kZTMyUmVhZGVyLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcmVnaXN0ZXJSZWFkZXI6IChuYW1lLCByZWFkZXIpID0+IHtcclxuICAgICAgICBSRUFERVJTW25hbWVdID0gcmVhZGVyO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZShjb25maWcsIGlucHV0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICAgICAgY29uc3QgX2NhbnZhcyA9IHtcclxuICAgICAgICAgICAgY3R4OiB7XHJcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZG9tOiB7XHJcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IF9iYXJjb2RlUmVhZGVycyA9IFtdO1xyXG5cclxuICAgICAgICBpbml0Q2FudmFzKCk7XHJcbiAgICAgICAgaW5pdFJlYWRlcnMoKTtcclxuICAgICAgICBpbml0Q29uZmlnKCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJGRlYnVnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlYnVnLmRldGVjdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmZyZXF1ZW5jeScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5mcmVxdWVuY3kpIHtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kuY2xhc3NOYW1lID0gJ2ZyZXF1ZW5jeSc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5mcmVxdWVuY3kgPSBfY2FudmFzLmRvbS5mcmVxdWVuY3kuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLnBhdHRlcm5CdWZmZXInKTtcclxuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20ucGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuLmNsYXNzTmFtZSA9ICdwYXR0ZXJuQnVmZmVyJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWJ1Zy5hcHBlbmRDaGlsZChfY2FudmFzLmRvbS5wYXR0ZXJuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5wYXR0ZXJuID0gX2NhbnZhcy5kb20ucGF0dGVybi5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZHJhd2luZ0J1ZmZlcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jYW52YXMuZG9tLm92ZXJsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5vdmVybGF5ID0gX2NhbnZhcy5kb20ub3ZlcmxheS5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbml0UmVhZGVycygpIHtcclxuICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMuZm9yRWFjaCgocmVhZGVyQ29uZmlnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIGxldCBzdXBwbGVtZW50cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZy5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHJlYWRlckNvbmZpZy5jb25maWc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgcmVnaXN0ZXJpbmcgcmVhZGVyOiAnLCByZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uc3VwcGxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXBwbGVtZW50cyA9IGNvbmZpZ3VyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1cHBsZW1lbnRzLm1hcCgoc3VwcGxlbWVudCkgPT4gbmV3IFJFQURFUlNbc3VwcGxlbWVudF0oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlck9iaiA9IG5ldyBSRUFERVJTW3JlYWRlcl0oY29uZmlndXJhdGlvbiwgc3VwcGxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5wdXNoKHJlYWRlck9iaik7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIEVycm9yIGNvbnN0cnVjdGluZyByZWFkZXIgJywgcmVhZGVyLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWdpc3RlcmVkIFJlYWRlcnM6ICR7X2JhcmNvZGVSZWFkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVhZGVyKSA9PiBKU09OLnN0cmluZ2lmeSh7IGZvcm1hdDogcmVhZGVyLkZPUk1BVCwgY29uZmlnOiByZWFkZXIuY29uZmlnIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbml0Q29uZmlnKCkge1xyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzID0gW3tcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5mcmVxdWVuY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3ksXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20ucGF0dGVybixcclxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4sXHJcbiAgICAgICAgICAgICAgICB9XTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc1tpXS5wcm9wID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBleHRlbmQgdGhlIGxpbmUgb24gYm90aCBlbmRzXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dGVuZGVkTGluZShsaW5lLCBhbmdsZSwgZXh0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZExpbmUoYW1vdW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeTogYW1vdW50ICogTWF0aC5zaW4oYW5nbGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IGFtb3VudCAqIE1hdGguY29zKGFuZ2xlKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4gICAgICAgICAgICAgICAgbGluZVswXS55IC09IGV4dGVuc2lvbi55O1xyXG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi54O1xyXG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi55O1xyXG4gICAgICAgICAgICAgICAgbGluZVsxXS54ICs9IGV4dGVuc2lvbi54O1xyXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpbnNpZGUgaW1hZ2VcclxuICAgICAgICAgICAgZXh0ZW5kTGluZShleHQpO1xyXG4gICAgICAgICAgICB3aGlsZSAoZXh0ID4gMSAmJiAoIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMV0pKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgICAgICAgICBleHQgLT0gTWF0aC5jZWlsKGV4dCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kTGluZSgtZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGluZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmUoYm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbe1xyXG4gICAgICAgICAgICAgICAgeDogKGJveFsxXVswXSAtIGJveFswXVswXSkgLyAyICsgYm94WzBdWzBdLFxyXG4gICAgICAgICAgICAgICAgeTogKGJveFsxXVsxXSAtIGJveFswXVsxXSkgLyAyICsgYm94WzBdWzFdLFxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICB4OiAoYm94WzNdWzBdIC0gYm94WzJdWzBdKSAvIDIgKyBib3hbMl1bMF0sXHJcbiAgICAgICAgICAgICAgICB5OiAoYm94WzNdWzFdIC0gYm94WzJdWzFdKSAvIDIgKyBib3hbMl1bMV0sXHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlKGxpbmUpIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBjb25zdCBiYXJjb2RlTGluZSA9IEJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZShpbnB1dEltYWdlV3JhcHBlciwgbGluZVswXSwgbGluZVsxXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5KSB7XHJcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgX2NhbnZhcy5jdHgub3ZlcmxheSwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcclxuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludEZyZXF1ZW5jeShiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5mcmVxdWVuY3kpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBCcmVzZW5oYW0udG9CaW5hcnlMaW5lKGJhcmNvZGVMaW5lKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLnBhdHRlcm4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZVBhdHRlcm4oYmFyY29kZUxpbmUubGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdCxcclxuICAgICAgICAgICAgICAgIGJhcmNvZGVMaW5lLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2xpY2VzIHRoZSBnaXZlbiBhcmVhIGFwYXJ0IGFuZCB0cmllcyB0byBkZXRlY3QgYSBiYXJjb2RlLXBhdHRlcm5cclxuICAgICAgICAgKiBmb3IgZWFjaCBzbGljZS4gSXQgcmV0dXJucyB0aGUgZGVjb2RlZCBiYXJjb2RlLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIGZvdW5kXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYm94XHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lQW5nbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGVMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coYm94WzFdWzBdIC0gYm94WzBdWzBdLCAyKSArIE1hdGgucG93KChib3hbMV1bMV0gLSBib3hbMF1bMV0pLCAyKSk7XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBjb25zdCBzbGljZXMgPSAxNjtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBkaXI7XHJcbiAgICAgICAgICAgIGxldCBleHRlbnNpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHhkaXIgPSBNYXRoLnNpbihsaW5lQW5nbGUpO1xyXG4gICAgICAgICAgICBjb25zdCB5ZGlyID0gTWF0aC5jb3MobGluZUFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBzbGljZXMgJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIG1vdmUgbGluZSBwZXJwZW5kaWN1bGFyIHRvIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXHJcbiAgICAgICAgICAgICAgICBkaXIgPSBzaWRlTGVuZ3RoIC8gc2xpY2VzICogaSAqIChpICUgMiA9PT0gMCA/IC0xIDogMSk7XHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeTogZGlyICogeGRpcixcclxuICAgICAgICAgICAgICAgICAgICB4OiBkaXIgKiB5ZGlyLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXHJcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgKz0gZXh0ZW5zaW9uLng7XHJcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLnk7XHJcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLng7XHJcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggLT0gZXh0ZW5zaW9uLnk7XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXHJcblxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChcclxuICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSksIDIpXHJcbiAgICAgICAgICAgICAgICArIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueCAtIGxpbmVbMF0ueCksIDIpLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlcikge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlSW1hZ2UgPyBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2l0aCB0aGUgaGVscCBvZiB0aGUgY29uZmlndXJlZCByZWFkZXJzIChDb2RlMTI4IG9yIEVBTikgdGhpcyBmdW5jdGlvbiB0cmllcyB0byBkZXRlY3QgYVxyXG4gICAgICAgICAqIHZhbGlkIGJhcmNvZGUgcGF0dGVybiB3aXRoaW4gdGhlIGdpdmVuIGFyZWEuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGJveCBUaGUgYXJlYSB0byBzZWFyY2ggaW5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVzdWx0IHtjb2RlUmVzdWx0LCBsaW5lLCBhbmdsZSwgcGF0dGVybiwgdGhyZXNob2xkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcclxuICAgICAgICAgICAgbGV0IGxpbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IF9jYW52YXMuY3R4Lm92ZXJsYXk7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnLmRyYXdCb3VuZGluZ0JveCAmJiBjdHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIGN0eCwgeyBjb2xvcjogJ2JsdWUnLCBsaW5lV2lkdGg6IDIgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxpbmUgPSBnZXRMaW5lKGJveCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBnZXRMaW5lTGVuZ3RoKGxpbmUpO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lQW5nbGUgPSBNYXRoLmF0YW4yKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSwgbGluZVsxXS54IC0gbGluZVswXS54KTtcclxuICAgICAgICAgICAgbGluZSA9IGdldEV4dGVuZGVkTGluZShsaW5lLCBsaW5lQW5nbGUsIE1hdGguZmxvb3IobGluZUxlbmd0aCAqIDAuMSkpO1xyXG4gICAgICAgICAgICBpZiAobGluZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHJlc3VsdCAmJiBjb25maWcuZGVidWcuZHJhd1NjYW5saW5lICYmIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIGN0eCwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdC5jb2RlUmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgICAgIGFuZ2xlOiBsaW5lQW5nbGUsXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiByZXN1bHQuYmFyY29kZUxpbmUubGluZSxcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogcmVzdWx0LmJhcmNvZGVMaW5lLnRocmVzaG9sZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpOyBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFyY29kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlwbGUgfSA9IGNvbmZpZztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBib3hlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm94ID0gYm94O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGVjb2RlRnJvbUltYWdlKGlucHV0SW1hZ2VXcmFwcGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVGcm9tSW1hZ2UoaW5wdXRJbWFnZVdyYXBwZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUkVBREVSU1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlZ2lzdGVyIGV4aXN0aW5nIHJlYWRlcicsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0UmVhZGVycyhyZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzID0gcmVhZGVycztcclxuICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcclxuIiwidHlwZSBFdmVudE5hbWUgPSBzdHJpbmc7XHJcblxyXG5pbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcclxuICAgIGFzeW5jPzogYm9vbGVhbjtcclxuICAgIGNhbGxiYWNrOiBGdW5jdGlvbjtcclxuICAgIG9uY2U/OiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgRXZlbnREYXRhIHtcclxuICAgIHN1YnNjcmliZXJzOiBBcnJheTxTdWJzY3JpcHRpb24+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgRXZlbnRzIHtcclxuICAgIFtrZXk6IHN0cmluZ106IEV2ZW50RGF0YTtcclxufVxyXG5cclxuaW50ZXJmYWNlIEV2ZW50SW50ZXJmYWNlIHtcclxuICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICBwdWJsaXNoKGV2ZW50TmFtZTogRXZlbnROYW1lLCBkYXRhPzogbmV2ZXIpOiB2b2lkO1xyXG4gICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gRXZlbnRJbnRlcmZhY2UoKTogRXZlbnRJbnRlcmZhY2Uge1xyXG4gICAgbGV0IGV2ZW50czogRXZlbnRzID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnROYW1lOiBFdmVudE5hbWUpOiBFdmVudERhdGEge1xyXG4gICAgICAgIGlmICghZXZlbnRzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudHNbZXZlbnROYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhckV2ZW50cygpOiB2b2lkIHtcclxuICAgICAgICBldmVudHMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uLCBkYXRhOiBuZXZlcik6IHZvaWQge1xyXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XHJcbiAgICAgICAgICAgIH0sIDQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGxldCBzdWJzY3JpcHRpb247XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBhc3luYyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgd2FzIG5vdCBzcGVjaWZpZWQgb24gb3B0aW9ucycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnZXRFdmVudChldmVudCkuc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZCB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgeyBzdWJzY3JpYmVycyB9ID0gZXZlbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIG9uZS10aW1lIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhIXN1YnNjcmliZXIub25jZSkuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhc3Vic2NyaWJlci5vbmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdGhlIHJlc3RcclxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmMgPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICAgICAgICBfc3Vic2NyaWJlKGV2ZW50LCB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgIGFzeW5jLFxyXG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBldmVudC5zdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIuY2FsbGJhY2sgIT09IGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufSgpKTtcclxuIiwiY29uc3QgRVJST1JfREVTQyA9ICdUaGlzIG1heSBtZWFuIHRoYXQgdGhlIHVzZXIgaGFzIGRlY2xpbmVkIGNhbWVyYSBhY2Nlc3MsIG9yIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbWVkaWEgQVBJcy4gSWYgeW91IGFyZSBydW5uaW5nIGluIGlPUywgeW91IG11c3QgdXNlIFNhZmFyaS4nO1xyXG5cclxuaW50ZXJmYWNlIEVycm9yIHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIG1lc3NhZ2U6IHN0cmluZztcclxuICAgIHN0YWNrPzogc3RyaW5nO1xyXG4gICAgY29kZT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZURldmljZXMoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciA9IG5ldyBFcnJvcihgZW51bWVyYXRlRGV2aWNlcyBpcyBub3QgZGVmaW5lZC4gJHtFUlJPUl9ERVNDfWApO1xyXG4gICAgICAgIGVycm9yLmNvZGUgPSAtMTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTxNZWRpYVN0cmVhbT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3I6IEVycm9yID0gbmV3IEVycm9yKGBnZXRVc2VyTWVkaWEgaXMgbm90IGRlZmluZWQuICR7RVJST1JfREVTQ31gKTtcclxuICAgICAgICBlcnJvci5jb2RlID0gLTE7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgcGljayBmcm9tICdsb2Rhc2gvcGljayc7XHJcbmltcG9ydCB7IGdldFVzZXJNZWRpYSwgZW51bWVyYXRlRGV2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9tZWRpYURldmljZXMnO1xyXG5pbXBvcnQgeyBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCwgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MgYXMgQ2FtZXJhQWNjZXNzVHlwZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxubGV0IHN0cmVhbVJlZjogTWVkaWFTdHJlYW0gfCBudWxsO1xyXG5cclxuZnVuY3Rpb24gd2FpdEZvclZpZGVvKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGxldCBhdHRlbXB0cyA9IDEwO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjaGVja1ZpZGVvKCk6IHZvaWQge1xyXG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8udmlkZW9XaWR0aCA+IDEwICYmIHZpZGVvLnZpZGVvSGVpZ2h0ID4gMTApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAqIGRldjogY2hlY2tWaWRlbyBmb3VuZCAke3ZpZGVvLnZpZGVvV2lkdGh9cHggeCAke3ZpZGVvLnZpZGVvSGVpZ2h0fXB4YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tWaWRlbywgNTAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VuYWJsZSB0byBwbGF5IHZpZGVvIHN0cmVhbS4gSXMgd2ViY2FtIHdvcmtpbmc/JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF0dGVtcHRzLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoZWNrVmlkZW8oKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjYW1lcmEtc3RyZWFtIHRvIGEgZ2l2ZW4gdmlkZW8tZWxlbWVudFxyXG4gKiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGNvbnRlbnQgaXMgcmVhZHlcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWRlb1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gaW5pdENhbWVyYSh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwsIGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xyXG4gICAgc3RyZWFtUmVmID0gc3RyZWFtO1xyXG4gICAgaWYgKHZpZGVvKSB7XHJcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XHJcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdtdXRlZCcsICd0cnVlJyk7XHJcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7IC8vIG5vdCBsaXN0ZWQgb24gTUROLi4uXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB2aWRlby5wbGF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHdhaXRGb3JWaWRlbyh2aWRlbyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCk6IE1lZGlhVHJhY2tDb25zdHJhaW50cyB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gcGljayh2aWRlb0NvbnN0cmFpbnRzLCBbJ3dpZHRoJywgJ2hlaWdodCcsICdmYWNpbmdNb2RlJyxcclxuICAgICAgICAnYXNwZWN0UmF0aW8nLCAnZGV2aWNlSWQnXSk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAmJiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvID4gMCkge1xyXG4gICAgICAgIG5vcm1hbGl6ZWQuYXNwZWN0UmF0aW8gPSB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ21pbkFzcGVjdFJhdGlvXFwnIGlzIGRlcHJlY2F0ZWQ7IFVzZSBcXCdhc3BlY3RSYXRpb1xcJyBpbnN0ZWFkJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMuZmFjaW5nICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIG5vcm1hbGl6ZWQuZmFjaW5nTW9kZSA9IHZpZGVvQ29uc3RyYWludHMuZmFjaW5nO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ2ZhY2luZ1xcJyBpcyBkZXByZWNhdGVkLiBVc2UgXFwnZmFjaW5nTW9kZVxcJyBpbnN0ZWFkXFwnJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufVxyXG5cclxuLy8gVE9ETzogIzE5MiBJIGRvbid0IHRoaW5rIHRoZXJlJ3MgYW55IGdvb2QgcmVhc29uIHBpY2tDb25zdHJhaW50cyBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSxcclxuLy8gSSB0aGluayBpdCB3YXMganVzdCB0aGF0IHdheSBzbyBpdCBjb3VsZCBiZSBjaGFpbmVkIHRvIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGRpZCByZXR1cm4gYSBQcm9taXNlLlxyXG4vLyBUaGF0J3Mgbm90IG5lY2Vzc2FyeSB3aXRoIGFzeW5jIGZ1bmN0aW9ucyBiZWluZyBhIHRoaW5nLCBzbyB0aGF0IHNob3VsZCBiZSBmaXhlZC5cclxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCA9IHt9KTogUHJvbWlzZTxNZWRpYVN0cmVhbUNvbnN0cmFpbnRzPiB7XHJcbiAgICBjb25zdCB2aWRlbyA9IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcclxuXHJcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8uZGV2aWNlSWQgJiYgdmlkZW8uZmFjaW5nTW9kZSkge1xyXG4gICAgICAgIGRlbGV0ZSB2aWRlby5mYWNpbmdNb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGF1ZGlvOiBmYWxzZSwgdmlkZW8gfSk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGVudW1lcmF0ZVZpZGVvRGV2aWNlcygpOiBQcm9taXNlPEFycmF5PE1lZGlhRGV2aWNlSW5mbz4+IHtcclxuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBlbnVtZXJhdGVEZXZpY2VzKCk7XHJcbiAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoKGRldmljZTogTWVkaWFEZXZpY2VJbmZvKSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QWN0aXZlVHJhY2soKTogTWVkaWFTdHJlYW1UcmFjayB8IG51bGwge1xyXG4gICAgaWYgKCFzdHJlYW1SZWYpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xyXG4gICAgcmV0dXJuIHRyYWNrcyAmJiB0cmFja3M/Lmxlbmd0aCA/IHRyYWNrc1swXSA6IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIGZvciBhY2Nlc3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFjdGl2ZSBzdHJlYW0gdHJhY2sgYW5kIGF2YWlsYWJsZSB2aWRlbyBkZXZpY2VzLlxyXG4gKi9cclxuY29uc3QgUXVhZ2dhSlNDYW1lcmFBY2Nlc3M6IENhbWVyYUFjY2Vzc1R5cGUgPSB7XHJcbiAgICByZXF1ZXN0ZWRWaWRlb0VsZW1lbnQ6IG51bGwsXHJcbiAgICBhc3luYyByZXF1ZXN0KHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCwgdmlkZW9Db25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogUHJvbWlzZTxhbnk+IHtcclxuICAgICAgICBRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQgPSB2aWRlbztcclxuICAgICAgICBjb25zdCBuZXdDb25zdHJhaW50cyA9IGF3YWl0IHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcclxuICAgICAgICByZXR1cm4gaW5pdENhbWVyYSh2aWRlbywgbmV3Q29uc3RyYWludHMpO1xyXG4gICAgfSxcclxuICAgIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmICYmIHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xyXG4gICAgICAgIGlmIChRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50LnBhdXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrc1swXS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHJlYW1SZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZW51bWVyYXRlVmlkZW9EZXZpY2VzLFxyXG4gICAgZ2V0QWN0aXZlU3RyZWFtTGFiZWwoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XHJcbiAgICAgICAgcmV0dXJuIHRyYWNrID8gdHJhY2subGFiZWwgOiAnJztcclxuICAgIH0sXHJcbiAgICBnZXRBY3RpdmVUcmFjayxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzO1xyXG4iLCJpbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xyXG5pbXBvcnQge1xyXG4gICAgUXVhZ2dhSlNDb2RlUmVzdWx0LFxyXG4gICAgUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IsXHJcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uLFxyXG4gICAgWFlTaXplLFxyXG4gICAgUXVhZ2dhSW1hZ2VEYXRhLFxyXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuZnVuY3Rpb24gY29udGFpbnMoY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LCBsaXN0OiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gbGlzdCAmJiBsaXN0LnNvbWUoKGl0ZW0pID0+IHtcclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXRlbSkgYXMgQXJyYXk8a2V5b2YgUXVhZ2dhSlNDb2RlUmVzdWx0PjtcclxuICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoa2V5KSA9PiBpdGVtW2tleV0gPT09IGNvZGVSZXN1bHRba2V5XSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFzc2VzRmlsdGVyKFxyXG4gICAgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LFxyXG4gICAgZmlsdGVyOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uIHwgdW5kZWZpbmVkLFxyXG4pOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nID8gZmlsdGVyKGNvZGVSZXN1bHQpIDogdHJ1ZTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFJlc3VsdENvbGxlY3RvciB7XHJcbiAgICBhZGRSZXN1bHQ6IChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpID0+IHZvaWQ7XHJcbiAgICBnZXRSZXN1bHRzOiAoKSA9PiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBjcmVhdGUoY29uZmlnOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3Rvcik6IFJlc3VsdENvbGxlY3RvciB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4gPSBbXTtcclxuICAgICAgICBsZXQgY2FwYWNpdHkgPSBjb25maWcuY2FwYWNpdHkgPz8gMjA7XHJcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGNvbmZpZy5jYXB0dXJlID09PSB0cnVlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzQ29uc3RyYWludHMoY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0KTogYm9vbGVhbiB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIWNhcGFjaXR5XHJcbiAgICAgICAgICAgICAgICAmJiBjb2RlUmVzdWx0XHJcbiAgICAgICAgICAgICAgICAmJiAhY29udGFpbnMoY29kZVJlc3VsdCwgY29uZmlnLmJsYWNrbGlzdCBhcyBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+KVxyXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGNvbmZpZy5maWx0ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWRkUmVzdWx0KGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IHZvaWQge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSB7IH07IC8vIHRoaXMgaXMgJ2FueScgdG8gYXZvaWQgaGF2aW5nIHRvIGNvbnN0cnVjdCBhIHdob2xlIFF1YWdnYUpTQ29kZVJlc3VsdCA6fFxyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcGFjaXR5LS07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvZGVSZXN1bHQgPSBjb2RlUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlU2l6ZS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2VTaXplLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd0ltYWdlKGRhdGEsIGltYWdlU2l6ZSwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZyYW1lID0gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0UmVzdWx0cygpOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xyXG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuY29uc3QgRGV2Q29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcclxuICAgIGlucHV0U3RyZWFtOiB7XHJcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxyXG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcclxuICAgICAgICBjb25zdHJhaW50czoge1xyXG4gICAgICAgICAgICB3aWR0aDogNjQwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcclxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXJlYToge1xyXG4gICAgICAgICAgICB0b3A6ICcwJScsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxyXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxyXG4gICAgICAgICAgICBib3R0b206ICcwJScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxyXG4gICAgfSxcclxuICAgIGxvY2F0ZTogdHJ1ZSxcclxuICAgIG51bU9mV29ya2VyczogMCxcclxuICAgIGRlY29kZXI6IHtcclxuICAgICAgICByZWFkZXJzOiBbXHJcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGVidWc6IHtcclxuICAgICAgICAgICAgZHJhd0JvdW5kaW5nQm94OiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0ZyZXF1ZW5jeTogZmFsc2UsXHJcbiAgICAgICAgICAgIGRyYXdTY2FubGluZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dQYXR0ZXJuOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIGxvY2F0b3I6IHtcclxuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxyXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXHJcbiAgICAgICAgZGVidWc6IHtcclxuICAgICAgICAgICAgc2hvd0NhbnZhczogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dQYXRjaGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0ZvdW5kUGF0Y2hlczogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dTa2VsZXRvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dMYWJlbHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93UGF0Y2hMYWJlbHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHM6IGZhbHNlLFxyXG4gICAgICAgICAgICBib3hGcm9tUGF0Y2hlczoge1xyXG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZEJveDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzaG93QkI6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGV2Q29uZmlnO1xyXG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuY29uc3QgTm9kZUNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XHJcbiAgICBpbnB1dFN0cmVhbToge1xyXG4gICAgICAgIHR5cGU6ICdJbWFnZVN0cmVhbScsXHJcbiAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxyXG4gICAgICAgIHNpemU6IDgwMCxcclxuICAgICAgICBhcmVhOiB7XHJcbiAgICAgICAgICAgIHRvcDogJzAlJyxcclxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXHJcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXHJcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXHJcbiAgICB9LFxyXG4gICAgbG9jYXRlOiB0cnVlLFxyXG4gICAgbnVtT2ZXb3JrZXJzOiAwLFxyXG4gICAgZGVjb2Rlcjoge1xyXG4gICAgICAgIHJlYWRlcnM6IFtcclxuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICBsb2NhdG9yOiB7XHJcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcclxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vZGVDb25maWc7XHJcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcblxyXG5jb25zdCBQcm9kQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcclxuICAgIGlucHV0U3RyZWFtOiB7XHJcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxyXG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcclxuICAgICAgICBjb25zdHJhaW50czoge1xyXG4gICAgICAgICAgICB3aWR0aDogNjQwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcclxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXJlYToge1xyXG4gICAgICAgICAgICB0b3A6ICcwJScsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxyXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxyXG4gICAgICAgICAgICBib3R0b206ICcwJScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxyXG4gICAgfSxcclxuICAgIGxvY2F0ZTogdHJ1ZSxcclxuICAgIG51bU9mV29ya2VyczogNCxcclxuICAgIGRlY29kZXI6IHtcclxuICAgICAgICByZWFkZXJzOiBbXHJcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAgbG9jYXRvcjoge1xyXG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXHJcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcclxuICAgIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcm9kQ29uZmlnO1xyXG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5pbXBvcnQgRGV2Q29uZmlnIGZyb20gJy4vY29uZmlnLmRldic7XHJcbmltcG9ydCBOb2RlQ29uZmlnIGZyb20gJy4vY29uZmlnLm5vZGUnO1xyXG5pbXBvcnQgUHJvZENvbmZpZyBmcm9tICcuL2NvbmZpZy5wcm9kJztcclxuXHJcbi8vIEB0cy1pZ25vcmUgLy8gVE9ETzogdGhpcyBwcm9kdWNlcyBhIGJpemFycmUgdHlwZXNjcmlwdCBlcnJvclxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuY29uc3QgUXVhZ2dhQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IEVOVi5kZXZlbG9wbWVudFxyXG4gICAgPyBEZXZDb25maWdcclxuICAgIDogRU5WLm5vZGVcclxuICAgICAgICA/IE5vZGVDb25maWdcclxuICAgICAgICA6IFByb2RDb25maWc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FDb25maWc7XHJcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSBcIi4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gXCJjb21tb24vaW1hZ2Vfd3JhcHBlclwiO1xuXG5leHBvcnQgY2xhc3MgUXVhZ2dhQ29udGV4dCB7XG4gICAgcHVibGljIGNvbmZpZz86IFF1YWdnYUpTQ29uZmlnT2JqZWN0O1xuXG4gICAgcHVibGljIGlucHV0U3RyZWFtOiBhbnk7XG5cbiAgICBwdWJsaWMgZnJhbWVncmFiYmVyOiBhbnk7XG5cbiAgICBwdWJsaWMgaW5wdXRJbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXI7XG5cbiAgICBwdWJsaWMgc3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHVibGljIGJveFNpemU6IGFueTtcblxuICAgIHB1YmxpYyByZXN1bHRDb2xsZWN0b3I6IGFueTtcblxuICAgIHB1YmxpYyBkZWNvZGVyOiBhbnk7XG5cbiAgICBwdWJsaWMgd29ya2VyUG9vbDogYW55W10gPSBbXTtcblxuICAgIHB1YmxpYyBvblVJVGhyZWFkID0gdHJ1ZTtcblxuICAgIHB1YmxpYyByZWFkb25seSBjYW52YXNDb250YWluZXIgPSBuZXcgQ2FudmFzQ29udGFpbmVyKCk7XG59XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNJbmZvIHtcbiAgICBpbWFnZTogYW55O1xuICAgIG92ZXJsYXk6IGFueTtcbn1cblxuZXhwb3J0IGNsYXNzIENhbnZhc0NvbnRhaW5lciB7XG4gICAgcHVibGljIHJlYWRvbmx5IGN0eDogQ2FudmFzSW5mbztcbiAgICBwdWJsaWMgcmVhZG9ubHkgZG9tOiBDYW52YXNJbmZvO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gbmV3IENhbnZhc0luZm8oKTtcbiAgICAgICAgdGhpcy5kb20gPSBuZXcgQ2FudmFzSW5mbygpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XHJcbmltcG9ydCB0eXBlIHsgSW5wdXRTdHJlYW0gfSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtLmQnO1xyXG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcclxuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcclxuXHJcbnR5cGUgQnVmZmVyUmV0dXJuID0ge1xyXG4gICAgaW5wdXRJbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcjtcclxuICAgIC8vIGJveFNpemUgc2hvdWxkIGJlIGxpa2UgW1sgbnVtYmVyLCBudW1iZXJdLCAuLi5dIGJ1dCBjbG9uZSdzIHNpZ25hdHVyZSBkb2Vzbid0IHNlZW0gdG8gYWxsb3cgdGhhdFxyXG4gICAgYm94U2l6ZTogQXJyYXk8QXJyYXk8bnVtYmVyPj47XHJcbn07XHJcblxyXG4vLyBUT0RPOiBuZWVkIHR5cGVzY3JpcHQgZGVmIGZvciBCYXJjb2RlTG9jYXRvclxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0QnVmZmVycyhcclxuICAgIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSxcclxuICAgIGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyIHwgdW5kZWZpbmVkLFxyXG4gICAgbG9jYXRvcjogYW55LFxyXG4pOiBCdWZmZXJSZXR1cm4ge1xyXG4gICAgY29uc3QgaW5wdXRJbWFnZVdyYXBwZXIgPSBpbWFnZVdyYXBwZXIgfHwgbmV3IEltYWdlV3JhcHBlcih7XHJcbiAgICAgICAgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcclxuICAgICAgICB5OiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSxcclxuICAgICAgICB0eXBlOiAnWFlTaXplJyxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgaW1hZ2Ugd3JhcHBlciBzaXplICR7aW5wdXRJbWFnZVdyYXBwZXIuc2l6ZX1gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGJveFNpemUgPSBbXHJcbiAgICAgICAgY2xvbmUoWzAsIDBdKSxcclxuICAgICAgICBjbG9uZShbMCwgaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55XSksXHJcbiAgICAgICAgY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55XSksXHJcbiAgICAgICAgY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgMF0pLFxyXG4gICAgXTtcclxuICAgIEJhcmNvZGVMb2NhdG9yLmluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGxvY2F0b3IpO1xyXG4gICAgcmV0dXJuIHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfTtcclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3UG9ydCh0YXJnZXQ/OiBFbGVtZW50IHwgc3RyaW5nKTogRWxlbWVudCB8IG51bGwge1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYWxyZWFkeSBhIERPTSBlbGVtZW50XHJcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0Lm5vZGVOYW1lICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyBVc2UgJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCcgYXMgYSBmYWxsYmFjayBzZWxlY3RvciAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXHJcbiAgICBjb25zdCBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCc7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XHJcbn1cclxuIiwiaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCwgQ2FudmFzQ29udGFpbmVyIH0gZnJvbSAnUXVhZ2dhQ29udGV4dCc7XHJcbmltcG9ydCB7IFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5pbXBvcnQgZ2V0Vmlld1BvcnQgZnJvbSAnLi9nZXRWaWV3UG9ydCc7XHJcblxyXG5mdW5jdGlvbiBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcclxuICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xyXG4gICAgaWYgKCFjYW52YXMpIHtcclxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbnZhcztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q2FudmFzQW5kQ29udGV4dChzZWxlY3Rvcjogc3RyaW5nLCBjbGFzc05hbWU6IHN0cmluZykge1xyXG4gICAgY29uc3QgY2FudmFzID0gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yLCBjbGFzc05hbWUpO1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgcmV0dXJuIHsgY2FudmFzLCBjb250ZXh0IH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRDYW52YXNlcyhjYW52YXNTaXplOiBYWVNpemUpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuaW1nQnVmZmVyJywgJ2ltZ0J1ZmZlcicpO1xyXG4gICAgICAgIGNvbnN0IG92ZXJsYXkgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuZHJhd2luZ0J1ZmZlcicsICdkcmF3aW5nQnVmZmVyJyk7XHJcblxyXG4gICAgICAgIGltYWdlLmNhbnZhcy53aWR0aCA9IG92ZXJsYXkuY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZS54O1xyXG4gICAgICAgIGltYWdlLmNhbnZhcy5oZWlnaHQgPSBvdmVybGF5LmNhbnZhcy5oZWlnaHQgPSBjYW52YXNTaXplLnk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRvbToge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLmNhbnZhcyxcclxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY2FudmFzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjdHg6IHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogb3ZlcmxheS5jb250ZXh0LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdENhbnZhcyhjb250ZXh0OiBRdWFnZ2FDb250ZXh0KTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XHJcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnRhcmdldCk7XHJcbiAgICBjb25zdCB0eXBlID0gY29udGV4dD8uY29uZmlnPy5pbnB1dFN0cmVhbT8udHlwZTtcclxuICAgIGlmICghdHlwZSkgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkpO1xyXG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybiB7IGRvbTogeyBpbWFnZTogbnVsbCwgb3ZlcmxheTogbnVsbCB9LCBjdHg6IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSB9O1xyXG5cclxuICAgIGNvbnN0IHsgZG9tIH0gPSBjb250YWluZXI7XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGlmICh2aWV3cG9ydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQoZG9tLmltYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5vdmVybGF5KSkge1xyXG4gICAgICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQoZG9tLm92ZXJsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxufVxyXG4iLCIvLyBUT0RPOiBJdCdzIHByZXR0eSBsaWtlbHkgdGhhdCB0aGlzIHNoYXJlcyBjb2RlIHdpdGggdGhlIGJyb3dzZXIgdmVyc2lvbiwgaW52ZXN0aWdhdGUgdGhhdFxyXG4vLyBGT1IgQU5ZT05FIElOIEhFUkUgSU4gVEhFIEZVVFVSRTogVGhpcyBpcyB0aGUgZGVmYXVsdCBpbnB1dF9zdHJlYW0gbW9kdWxlIHVzZWQgZm9yIHRoZSBOb2RlIGJ1bmRsZS5cclxuLy8gd2VicGFjay5jb25maWcuanMgKnJlcGxhY2VzKiB0aGlzIHdpdGggaW5wdXRfc3RyZWFtX2Jyb3dzZXIudHMgd2hlbiB0aGUgYnVuZGxlIGlzIGJlaW5nIGJ1aWx0IGZvciBicm93c2VyLlxyXG5cclxuaW1wb3J0IEdldFBpeGVscyBmcm9tICdnZXQtcGl4ZWxzJztcclxuaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5LCBJbnB1dFN0cmVhbSwgRXZlbnRIYW5kbGVyTGlzdCB9IGZyb20gJy4vaW5wdXRfc3RyZWFtLmQnO1xyXG5pbXBvcnQgeyBQb2ludCwgWFlTaXplIH0gZnJvbSAnLi4vLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XHJcblxyXG5jb25zdCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSA9IHtcclxuICAgIGNyZWF0ZVZpZGVvU3RyZWFtKCk6IG5ldmVyIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVZpZGVvU3RyZWFtIG5vdCBhdmFpbGFibGUnKTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVMaXZlU3RyZWFtKCk6IG5ldmVyIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUxpdmVTdHJlYW0gbm90IGF2YWlsYWJsZScpO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUltYWdlU3RyZWFtKCk6IElucHV0U3RyZWFtIHtcclxuICAgICAgICBsZXQgX2NvbmZpZzogeyBtaW1lOiBzdHJpbmc7IHNpemU6IG51bWJlcjsgc3JjOiBhbnkgfSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgICAgICBsZXQgd2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xyXG4gICAgICAgIGxldCBsb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBUT0RPOiBmcmFtZSBzaG91bGQgYmUgYSB0eXBlIE5kQXJyYXksIGJ1dCBOZEFycmF5IGRvZXNuJ3QgaGF2ZSB0cyBkZWZpbml0aW9uc1xyXG4gICAgICAgIC8vIFRPRE86IHRoZXJlIGlzIGEgdHMtbmRhcnJheSB0aGF0IG1pZ2h0IHdvcmssIHRob3VnaFxyXG4gICAgICAgIGxldCBmcmFtZTogYW55ID0gbnVsbDtcclxuICAgICAgICBsZXQgYmFzZVVybDogc3RyaW5nO1xyXG4gICAgICAgIGNvbnN0IGVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xyXG4gICAgICAgIGxldCBjYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XHJcbiAgICAgICAgY29uc3QgX2V2ZW50TmFtZXMgPSBbJ2NhbnJlY29yZCcsICdlbmRlZCddO1xyXG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XHJcbiAgICAgICAgY29uc3QgX3RvcFJpZ2h0OiBQb2ludCA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1BvaW50JyB9O1xyXG4gICAgICAgIGNvbnN0IF9jYW52YXNTaXplOiBYWVNpemUgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdYWVNpemUnIH07XHJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi8gLy8gZmFsc2UgZXNsaW50IGVycm9ycz8gd2VpcmQuXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGxldCBzaXplID0gMDtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgbGV0IGZyYW1lSWR4ID0gMDtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlcygpOiB2b2lkIHtcclxuICAgICAgICAgICAgbG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cclxuICAgICAgICAgICAgR2V0UGl4ZWxzKGJhc2VVcmwsIF9jb25maWc/Lm1pbWUsIChlcnIsIHBpeGVscykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyoqKiogcXVhZ2dhIGxvYWRJbWFnZXMgZXJyb3I6JywgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIGRlY29kaW5nIHBpeGVscyBpbiBsb2FkSW1hZ2VzJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcqIElucHV0U3RyZWFtTm9kZSBwaXhlbHMuc2hhcGUnLCBwaXhlbHMuc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxyXG4gICAgICAgICAgICAgICAgZnJhbWUgPSBwaXhlbHM7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xyXG4gICAgICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdID0gcGl4ZWxzLnNoYXBlO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBfY29uZmlnPy5zaXplXHJcbiAgICAgICAgICAgICAgICAgICAgPyB3aWR0aCAvIGhlaWdodCA+IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBfY29uZmlnLnNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLmZsb29yKCh3aWR0aCAvIGhlaWdodCkgKiBfY29uZmlnLnNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgOiB3aWR0aDtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemVcclxuICAgICAgICAgICAgICAgICAgICA/IHdpZHRoIC8gaGVpZ2h0ID4gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfY29uZmlnLnNpemVcclxuICAgICAgICAgICAgICAgICAgICA6IGhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gY2FsY3VsYXRlZFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxyXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudCgnY2FucmVjb3JkJywgW10pO1xyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KGlucHV0U3RyZWFtLCBhcmdzIGFzIGFueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcclxuICAgICAgICB2YXIgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtID0ge1xyXG4gICAgICAgICAgICB0cmlnZ2VyOiBwdWJsaXNoRXZlbnQsXHJcblxyXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkV2lkdGg7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZEhlaWdodDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldFdpZHRoKHcpIHtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IHc7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRIZWlnaHQoaCkge1xyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IGg7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRSZWFsV2lkdGgoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxyXG4gICAgICAgICAgICAgICAgX2NvbmZpZyA9IHN0cmVhbTtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsID0gX2NvbmZpZz8uc3JjO1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBlbmRlZCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRlZDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZSgpIHt9LFxyXG5cclxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25maWc7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBwYXVzZSgpIHtcclxuICAgICAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBwbGF5KCkge1xyXG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZUlkeCA9IHRpbWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2V2ZW50TmFtZXMuaW5kZXhPZihldmVudCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX2V2ZW50SGFuZGxlcnMpLmZvckVhY2goKGluZCkgPT4gZGVsZXRlIF9ldmVudEhhbmRsZXJzW2luZF0pO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XHJcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKHN6KSB7XHJcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gc3oueDtcclxuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBzei55O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcclxuIiwiLyogV29ya2VyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlIHN0cmFpZ2h0IGZyb20gdGhlIG9yaWdpbmFsIHF1YWdnYS5qcyBmaWxlLlxyXG4gKiBOb3QgcHJlc2VudGx5IHVzZWQsIGFzIHdvcmtlciBzdXBwb3J0IGlzIG5vbi1mdW5jdGlvbmFsLiAgS2VlcGluZyB0aGVtIGFyb3VuZCB0ZW1wb3JhcmlseVxyXG4gKiB0byByZWZlciB0byB1bnRpbCBpdCBpcyByZS1pbXBsZW1lbnRlZC4gV2UgbWF5IGJlIGFibGUgdG8gZml4L3VzZSBzb21lIG9mIHRoaXMuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QsIFF1YWdnYUpTUmVhZGVyQ29uZmlnIH0gZnJvbSBcIi4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XHJcblxyXG4vLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCBpbnRlcmZhY2UgZm9yIEZyYW1lR3JhYmJlclxyXG5cclxuaW50ZXJmYWNlIFFXb3JrZXJUaHJlYWQge1xyXG4gICAgaW1hZ2VEYXRhOiBVaW50OEFycmF5O1xyXG4gICAgYnVzeTogYm9vbGVhbjtcclxuICAgIHdvcmtlcjogV29ya2VyO1xyXG59XHJcblxyXG5sZXQgd29ya2VyUG9vbDogQXJyYXk8UVdvcmtlclRocmVhZD4gPSBbXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVXb3JrZXJzKGZyYW1lR3JhYmJlcjogYW55KSB7XHJcbiAgICBsZXQgYXZhaWxhYmxlV29ya2VyOiBRV29ya2VyVGhyZWFkO1xyXG4gICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoKSB7XHJcbiAgICAgICAgYXZhaWxhYmxlV29ya2VyID0gd29ya2VyUG9vbC5maWx0ZXIoKHdvcmtlclRocmVhZCkgPT4gIXdvcmtlclRocmVhZC5idXN5KVswXTtcclxuICAgICAgICBpZiAoYXZhaWxhYmxlV29ya2VyKSB7XHJcbiAgICAgICAgICAgIGZyYW1lR3JhYmJlci5hdHRhY2hEYXRhKGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEpO1xyXG4gICAgICAgICAgICBpZiAoZnJhbWVHcmFiYmVyLmdyYWIoKSkge1xyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLmJ1c3kgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY21kOiAncHJvY2VzcycsXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhOiBhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLFxyXG4gICAgICAgICAgICAgICAgfSwgW2F2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEuYnVmZmVyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25maWdGb3JXb3JrZXIoY29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5jb25maWcsXHJcbiAgICAgICAgaW5wdXRTdHJlYW06IHtcclxuICAgICAgICAgICAgLi4uY29uZmlnLmlucHV0U3RyZWFtLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIEB0cy1pZ25vcmVcclxuZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlKGZhY3RvcnkpIHtcclxuICAgIGlmIChmYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIFF1YWdnYSA9IGZhY3RvcnkoKS5kZWZhdWx0O1xyXG4gICAgICAgIGlmICghUXVhZ2dhKSB7XHJcbi8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7ICdldmVudCc6ICdlcnJvcicsIG1lc3NhZ2U6ICdRdWFnZ2EgY291bGQgbm90IGJlIGNyZWF0ZWQnIH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICB2YXIgaW1hZ2VXcmFwcGVyO1xyXG5cclxuLy8gQHRzLWlnbm9yZVxyXG4gICAgZnVuY3Rpb24gb25Qcm9jZXNzZWQocmVzdWx0KSB7XHJcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICdldmVudCc6ICdwcm9jZXNzZWQnLFxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHdvcmtlckludGVyZmFjZVJlYWR5KCkge1xyXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAnZXZlbnQnOiAnaW5pdGlhbGl6ZWQnLFxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXHJcbi8vIEB0cy1pZ25vcmVcclxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XHJcbiAgICB9XHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUuZGF0YS5jbWQgPT09ICdpbml0Jykge1xyXG4gICAgICAgICAgICB2YXIgY29uZmlnID0gZS5kYXRhLmNvbmZpZztcclxuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XHJcbiAgICAgICAgICAgIGltYWdlV3JhcHBlciA9IG5ldyBRdWFnZ2EuSW1hZ2VXcmFwcGVyKHtcclxuICAgICAgICAgICAgICAgIHg6IGUuZGF0YS5zaXplLngsXHJcbiAgICAgICAgICAgICAgICB5OiBlLmRhdGEuc2l6ZS55LFxyXG4gICAgICAgICAgICB9LCBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIFF1YWdnYS5pbml0KGNvbmZpZywgd29ya2VySW50ZXJmYWNlUmVhZHksIGltYWdlV3JhcHBlcik7XHJcbiAgICAgICAgICAgIFF1YWdnYS5vblByb2Nlc3NlZChvblByb2Nlc3NlZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncHJvY2VzcycpIHtcclxuLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xyXG4gICAgICAgICAgICBRdWFnZ2Euc3RhcnQoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdzZXRSZWFkZXJzJykge1xyXG4gICAgICAgICAgICBRdWFnZ2Euc2V0UmVhZGVycyhlLmRhdGEucmVhZGVycyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncmVnaXN0ZXJSZWFkZXInKSB7XHJcbiAgICAgICAgICAgIFF1YWdnYS5yZWdpc3RlclJlYWRlcihlLmRhdGEubmFtZSwgZS5kYXRhLnJlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVXb3JrZXJCbG9iKCkge1xyXG4gICAgdmFyIGJsb2IsXHJcbiAgICAgICAgZmFjdG9yeVNvdXJjZTtcclxuXHJcbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBpZiAodHlwZW9mIF9fZmFjdG9yeVNvdXJjZV9fICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBmYWN0b3J5U291cmNlID0gX19mYWN0b3J5U291cmNlX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcclxuICAgIH1cclxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcblxyXG4gICAgYmxvYiA9IG5ldyBCbG9iKFsnKCcgKyB3b3JrZXJJbnRlcmZhY2UudG9TdHJpbmcoKSArICcpKCcgKyBmYWN0b3J5U291cmNlICsgJyk7J10sXHJcbiAgICAgICAgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcclxuXHJcbiAgICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0V29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtOiBhbnksIGNiOiBGdW5jdGlvbikge1xyXG4gICAgY29uc3QgYmxvYlVSTCA9IGdlbmVyYXRlV29ya2VyQmxvYigpO1xyXG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcclxuXHJcbiAgICBjb25zdCB3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQgPSB7XHJcbiAgICAgICAgd29ya2VyLFxyXG4gICAgICAgIGltYWdlRGF0YTogbmV3IFVpbnQ4QXJyYXkoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAqIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKSxcclxuICAgICAgICBidXN5OiB0cnVlLFxyXG4gICAgfTtcclxuXHJcbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2luaXRpYWxpemVkJykge1xyXG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xyXG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgaW5pdGlhbGl6ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYih3b3JrZXJUaHJlYWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAncHJvY2Vzc2VkJykge1xyXG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XHJcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGhvdyB0byB0aHJlYWQgcHVibGlzaFJlc3VsdCBpbnRvIGhlcmU/XHJcbiAgICAgICAgICAgIC8vIHB1Ymxpc2hSZXN1bHQoZS5kYXRhLnJlc3VsdCwgd29ya2VyVGhyZWFkLmltYWdlRGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuZXZlbnQgPT09ICdlcnJvcicpIHtcclxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBlcnJvcjogJyArIGUuZGF0YS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgY21kOiAnaW5pdCcsXHJcbiAgICAgICAgc2l6ZTogeyB4OiBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCB5OiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSB9LFxyXG4gICAgICAgIGltYWdlRGF0YTogd29ya2VyVGhyZWFkLmltYWdlRGF0YSxcclxuICAgICAgICBjb25maWc6IGNvbmZpZ0Zvcldvcmtlcihjb25maWcpLFxyXG4gICAgfSwgW3dvcmtlclRocmVhZC5pbWFnZURhdGEuYnVmZmVyXSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RXb3JrZXJQb29sKGNhcGFjaXR5OiBudW1iZXIsIGNvbmZpZz86IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBpbnB1dFN0cmVhbT86IGFueSwgY2I/OiBGdW5jdGlvbikge1xyXG4gICAgY29uc3QgaW5jcmVhc2VCeSA9IGNhcGFjaXR5IC0gd29ya2VyUG9vbC5sZW5ndGg7XHJcbiAgICBpZiAoaW5jcmVhc2VCeSA9PT0gMCAmJiBjYikge1xyXG4gICAgICAgIGNiKCk7XHJcbiAgICB9IGVsc2UgaWYgKGluY3JlYXNlQnkgPCAwKSB7XHJcbiAgICAgICAgY29uc3Qgd29ya2Vyc1RvVGVybWluYXRlID0gd29ya2VyUG9vbC5zbGljZShpbmNyZWFzZUJ5KTtcclxuICAgICAgICB3b3JrZXJzVG9UZXJtaW5hdGUuZm9yRWFjaChmdW5jdGlvbiAod29ya2VyVGhyZWFkKSB7XHJcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC53b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgdGVybWluYXRlZCEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdvcmtlclBvb2wgPSB3b3JrZXJQb29sLnNsaWNlKDAsIGluY3JlYXNlQnkpO1xyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICBjYigpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgd29ya2VySW5pdGlhbGl6ZWQgPSAod29ya2VyVGhyZWFkOiBRV29ya2VyVGhyZWFkKSA9PiB7XHJcbiAgICAgICAgICAgIHdvcmtlclBvb2wucHVzaCh3b3JrZXJUaHJlYWQpO1xyXG4gICAgICAgICAgICBpZiAod29ya2VyUG9vbC5sZW5ndGggPj0gY2FwYWNpdHkgJiYgY2IpIHtcclxuICAgICAgICAgICAgICAgIGNiKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5jcmVhc2VCeTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpbml0V29ya2VyKGNvbmZpZywgaW5wdXRTdHJlYW0sIHdvcmtlckluaXRpYWxpemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KSB7XHJcbiAgICB3b3JrZXJQb29sLmZvckVhY2goKHdvcmtlclRocmVhZCkgPT4gd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7IGNtZDogJ3NldFJlYWRlcnMnLCByZWFkZXJzIH0pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBhbnkpIHtcclxuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAncmVnaXN0ZXJSZWFkZXInLCBuYW1lLCByZWFkZXIgfSkpO1xyXG59XHJcbiIsImltcG9ydCB7IElucHV0U3RyZWFtVHlwZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuLy8gVE9ETzogbmVlZCB0byBjcmVhdGUgYW4gSW5wdXRTdHJlYW0gdHlwZXNjcmlwdCBpbnRlcmZhY2UsIHNvIHdlIGRvbid0IGhhdmUgYW4gXCJhbnlcIiBpbiB0aGUgbmV4dCBsaW5lXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwSW5wdXRTdHJlYW0odHlwZTogSW5wdXRTdHJlYW1UeXBlID0gJ0xpdmVTdHJlYW0nLCB2aWV3cG9ydDogRWxlbWVudCB8IG51bGwsIElucHV0U3RyZWFtOiBhbnkpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ1ZpZGVvU3RyZWFtJzoge1xyXG4gICAgICAgICAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2aWRlbyxcclxuICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbS5jcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ0ltYWdlU3RyZWFtJzpcclxuICAgICAgICAgICAgcmV0dXJuIHsgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLmNyZWF0ZUltYWdlU3RyZWFtKCkgfTtcclxuICAgICAgICBjYXNlICdMaXZlU3RyZWFtJzoge1xyXG4gICAgICAgICAgICBsZXQgdmlkZW86IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHZpZXdwb3J0KSB7XHJcbiAgICAgICAgICAgICAgICB2aWRlbyA9IHZpZXdwb3J0LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKHZpZGVvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmlkZW8sXHJcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCogc2V0dXBJbnB1dFN0cmVhbSBpbnZhbGlkIHR5cGUgJHt0eXBlfWApO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2aWRlbzogbnVsbCwgaW5wdXRTdHJlYW06IG51bGwgfTtcclxuICAgIH1cclxufVxyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xyXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xyXG5cclxuZXhwb3J0IHR5cGUgQm94ID0gQXJyYXk8WyBudW1iZXIsIG51bWJlciBdPjtcclxuXHJcbmV4cG9ydCB0eXBlIExpbmUgPSBbIFBvaW50LCBQb2ludCBdO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVCb3goYm94OiBCb3gsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBsZXQgY29ybmVyID0gYm94Lmxlbmd0aDtcclxuICAgIHdoaWxlIChjb3JuZXItLSkge1xyXG4gICAgICAgIGJveFtjb3JuZXJdWzBdICs9IHhPZmZzZXQ7XHJcbiAgICAgICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVMaW5lKGxpbmU6IExpbmUsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBsaW5lWzBdLnggKz0geE9mZnNldDtcclxuICAgIGxpbmVbMF0ueSArPSB5T2Zmc2V0O1xyXG4gICAgbGluZVsxXS54ICs9IHhPZmZzZXQ7XHJcbiAgICBsaW5lWzFdLnkgKz0geU9mZnNldDtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xyXG5pbXBvcnQgeyBRdWFnZ2FDb250ZXh0IH0gZnJvbSAnLi4vUXVhZ2dhQ29udGV4dCc7XHJcbmltcG9ydCBfaW5pdEJ1ZmZlcnMgZnJvbSAnLi9pbml0QnVmZmVycyc7XHJcbmltcG9ydCBfZ2V0Vmlld1BvcnQgZnJvbSAnLi9nZXRWaWV3UG9ydCc7XHJcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xyXG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi4vZGVjb2Rlci9iYXJjb2RlX2RlY29kZXInO1xyXG5pbXBvcnQgX2luaXRDYW52YXMgZnJvbSAnLi9pbml0Q2FudmFzJztcclxuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcclxuaW1wb3J0IElucHV0U3RyZWFtIGZyb20gJy4uL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW0nO1xyXG5pbXBvcnQgRnJhbWVHcmFiYmVyIGZyb20gJy4uL2lucHV0L2ZyYW1lX2dyYWJiZXIuanMnO1xyXG5pbXBvcnQgKiBhcyBRV29ya2VycyBmcm9tICcuL3F3b3JrZXInO1xyXG5pbXBvcnQgc2V0dXBJbnB1dFN0cmVhbSBmcm9tICcuL3NldHVwSW5wdXRTdHJlYW0nO1xyXG5pbXBvcnQgQ2FtZXJhQWNjZXNzIGZyb20gJy4uL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xyXG5pbXBvcnQgeyBCYXJjb2RlSW5mbyB9IGZyb20gJy4uL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XHJcbmltcG9ydCB7IG1vdmVMaW5lLCBtb3ZlQm94IH0gZnJvbSAnLi90cmFuc2Zvcm0nO1xyXG5pbXBvcnQgeyBRdWFnZ2FKU1Jlc3VsdE9iamVjdCwgUXVhZ2dhSlNSZWFkZXJDb25maWcgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcclxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWdnYSB7XHJcbiAgICBjb250ZXh0OiBRdWFnZ2FDb250ZXh0ID0gbmV3IFF1YWdnYUNvbnRleHQoKTtcclxuXHJcbiAgICBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGlucHV0SW1hZ2VXcmFwcGVyLCBib3hTaXplIH0gPSBfaW5pdEJ1ZmZlcnMoXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcclxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLFxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLmxvY2F0b3IsXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcclxuICAgICAgICB0aGlzLmNvbnRleHQuYm94U2l6ZSA9IGJveFNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0QnVmZmVycyhpbWFnZVdyYXBwZXIpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyID0gQmFyY29kZURlY29kZXIuY3JlYXRlKHRoaXMuY29udGV4dC5jb25maWcuZGVjb2RlciwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRWaWV3UG9ydCgpOiBFbGVtZW50IHwgbnVsbCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnIHx8ICF0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbTtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdQb3J0KHRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZHkoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0ucGxheSgpO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdENhbnZhcygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBfaW5pdENhbnZhcyh0aGlzLmNvbnRleHQpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIGRvbSB9ID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLmltYWdlID0gZG9tLmltYWdlO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkgPSBkb20ub3ZlcmxheTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5pbWFnZSA9IGN0eC5pbWFnZTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5vdmVybGF5ID0gY3R4Lm92ZXJsYXk7XHJcbiAgICB9XHJcblxyXG4gICAgY2FuUmVjb3JkID0gKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgQmFyY29kZUxvY2F0b3IuY2hlY2tJbWFnZUNvbnN0cmFpbnRzKHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSwgdGhpcy5jb250ZXh0LmNvbmZpZz8ubG9jYXRvcik7XHJcbiAgICAgICAgdGhpcy5pbml0Q2FudmFzKCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlciA9IEZyYW1lR3JhYmJlci5jcmVhdGUoXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgUVdvcmtlcnMuYWRqdXN0V29ya2VyUG9vbCh0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyxcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZyxcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZz8ubnVtT2ZXb3JrZXJzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeShjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbml0SW5wdXRTdHJlYW0oY2FsbGJhY2s6IChlcnI/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgdHlwZTogaW5wdXRUeXBlLCBjb25zdHJhaW50cyB9ID0gdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbTtcclxuICAgICAgICBjb25zdCB7IHZpZGVvLCBpbnB1dFN0cmVhbSB9ID0gc2V0dXBJbnB1dFN0cmVhbShpbnB1dFR5cGUsIHRoaXMuZ2V0Vmlld1BvcnQoKSwgSW5wdXRTdHJlYW0pO1xyXG5cclxuICAgICAgICBpZiAoaW5wdXRUeXBlID09PSAnTGl2ZVN0cmVhbScgJiYgdmlkZW8pIHtcclxuICAgICAgICAgICAgQ2FtZXJhQWNjZXNzLnJlcXVlc3QodmlkZW8sIGNvbnN0cmFpbnRzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gaW5wdXRTdHJlYW0udHJpZ2dlcignY2FucmVjb3JkJykpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gY2FsbGJhY2soZXJyKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRBdHRyaWJ1dGUoJ3ByZWxvYWQnLCAnYXV0bycpO1xyXG4gICAgICAgIGlucHV0U3RyZWFtLnNldElucHV0U3RyZWFtKHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pO1xyXG4gICAgICAgIGlucHV0U3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnJlY29yZCcsIHRoaXMuY2FuUmVjb3JkLmJpbmQodW5kZWZpbmVkLCBjYWxsYmFjaykpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0gPSBpbnB1dFN0cmVhbTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRCb3VuZGluZ0JveGVzKCk6IEFycmF5PEFycmF5PG51bWJlcj4+IHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0ZSA/IEJhcmNvZGVMb2NhdG9yLmxvY2F0ZSgpXHJcbiAgICAgICAgICAgIDogW1tcclxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzBdKSxcclxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzFdKSxcclxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzJdKSxcclxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzNdKSxcclxuICAgICAgICAgICAgXV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgdHlwZSBmb3IgcmVzdWx0IGhlcmUuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xyXG4gICAgdHJhbnNmb3JtUmVzdWx0KHJlc3VsdDogYW55KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcclxuICAgICAgICBjb25zdCB4T2Zmc2V0ID0gdG9wUmlnaHQueDtcclxuICAgICAgICBjb25zdCB5T2Zmc2V0ID0gdG9wUmlnaHQueTtcclxuXHJcbiAgICAgICAgaWYgKHhPZmZzZXQgPT09IDAgJiYgeU9mZnNldCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IEJhcmNvZGVJbmZvIG1heSBub3QgYmUgdGhlIHJpZ2h0IHR5cGUgaGVyZS5cclxuICAgICAgICAgICAgcmVzdWx0LmJhcmNvZGVzLmZvckVhY2goKGJhcmNvZGU6IEJhcmNvZGVJbmZvKSA9PiB0aGlzLnRyYW5zZm9ybVJlc3VsdChiYXJjb2RlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVzdWx0LmxpbmUgJiYgcmVzdWx0LmxpbmUubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIG1vdmVMaW5lKHJlc3VsdC5saW5lLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHQuYm94KSB7XHJcbiAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveCwgeE9mZnNldCwgeU9mZnNldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVzdWx0LmJveGVzICYmIHJlc3VsdC5ib3hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0LmJveGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3hlc1tpXSwgeE9mZnNldCwgeU9mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUmVzdWx0KHJlc3VsdDogUXVhZ2dhSlNSZXN1bHRPYmplY3QsIGltYWdlRGF0YTogQXJyYXk8bnVtYmVyPik6IHZvaWQge1xyXG4gICAgICAgIGlmICghaW1hZ2VEYXRhIHx8ICF0aGlzLmNvbnRleHQucmVzdWx0Q29sbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBkYXRhIHN0cnVjdHVyZSBob2xkcyBhIFwiYmFyY29kZXNcIiByZXN1bHQsIGlmIGFueS4uLlxyXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmJhcmNvZGVzLmZpbHRlcigoYmFyY29kZTogUXVhZ2dhSlNSZXN1bHRPYmplY3QpID0+IGJhcmNvZGUuY29kZVJlc3VsdClcclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gdGhpcy5hZGRSZXN1bHQoYmFyY29kZSwgaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdChcclxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSxcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCksXHJcbiAgICAgICAgICAgICAgICByZXN1bHQuY29kZVJlc3VsdCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcclxuICAgIGhhc0NvZGVSZXN1bHQocmVzdWx0OiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAhIShyZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2Rlc1xyXG4gICAgICAgICAgICA/IHJlc3VsdC5iYXJjb2Rlcy5zb21lKChiYXJjb2RlKSA9PiBiYXJjb2RlLmNvZGVSZXN1bHQpXHJcbiAgICAgICAgICAgIDogcmVzdWx0LmNvZGVSZXN1bHQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xyXG4gICAgcHVibGlzaFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IG51bGwsIGltYWdlRGF0YT86IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGxldCByZXN1bHRUb1B1Ymxpc2g6IEFycmF5PFF1YWdnYUpTUmVzdWx0T2JqZWN0PiB8IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IHJlc3VsdDtcclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVJlc3VsdChyZXN1bHQpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFJlc3VsdChyZXN1bHQsIGltYWdlRGF0YSk7XHJcbiAgICAgICAgICAgIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdC5iYXJjb2RlcyB8fCByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFdmVudHMucHVibGlzaCgncHJvY2Vzc2VkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcclxuICAgICAgICBpZiAodGhpcy5oYXNDb2RlUmVzdWx0KHJlc3VsdCBhcyBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkpIHtcclxuICAgICAgICAgICAgRXZlbnRzLnB1Ymxpc2goJ2RldGVjdGVkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbG9jYXRlQW5kRGVjb2RlKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGJveGVzID0gdGhpcy5nZXRCb3VuZGluZ0JveGVzKCk7XHJcbiAgICAgICAgaWYgKGJveGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVJlc3VsdCA9IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSB8fCB7fTtcclxuICAgICAgICAgICAgZGVjb2RlUmVzdWx0LmJveGVzID0gYm94ZXM7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChkZWNvZGVSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VSZXN1bHQgPSB0aGlzLmNvbnRleHQuZGVjb2Rlci5kZWNvZGVGcm9tSW1hZ2UodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcclxuICAgICAgICAgICAgaWYgKGltYWdlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoaW1hZ2VSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlcnNVcGRhdGVkID0gUVdvcmtlcnMudXBkYXRlV29ya2Vycyh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyKTtcclxuICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXdvcmtlcnNVcGRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYXRlQW5kRGVjb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuZ3JhYigpO1xyXG4gICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc3RhcnRDb250aW51b3VzVXBkYXRlKCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBuZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBjb25zdCBkZWxheSA9IDEwMDAgLyAodGhpcy5jb250ZXh0LmNvbmZpZz8uZnJlcXVlbmN5IHx8IDYwKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB7IGNvbnRleHQgfSA9IHRoaXM7XHJcblxyXG4gICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG5leHQgPSBuZXh0IHx8IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnN0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgKz0gZGVsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobmV3RnJhbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbmV3RnJhbWUocGVyZm9ybWFuY2Uubm93KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQub25VSVRocmVhZCAmJiB0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbT8udHlwZSA9PT0gJ0xpdmVTdHJlYW0nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb250aW51b3VzVXBkYXRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgc3RvcCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgUVdvcmtlcnMuYWRqdXN0V29ya2VyUG9vbCgwKTtcclxuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0gJiYgdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSAnTGl2ZVN0cmVhbScpIHtcclxuICAgICAgICAgICAgYXdhaXQgQ2FtZXJhQWNjZXNzLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmNsZWFyRXZlbnRIYW5kbGVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPik6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5zZXRSZWFkZXJzKHJlYWRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBRV29ya2Vycy5zZXRSZWFkZXJzKHJlYWRlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBRdWFnZ2FKU1JlYWRlckNvbmZpZyk6IHZvaWQge1xyXG4gICAgICAgIEJhcmNvZGVEZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5kZWNvZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFFXb3JrZXJzLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XHJcbmltcG9ydCBUeXBlRGVmcyBmcm9tICcuL2NvbW1vbi90eXBlZGVmcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcclxuaW1wb3J0IEJhcmNvZGVEZWNvZGVyIGZyb20gJy4vZGVjb2Rlci9iYXJjb2RlX2RlY29kZXInO1xyXG5pbXBvcnQgQmFyY29kZVJlYWRlciBmcm9tICcuL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XHJcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcclxuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xyXG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XHJcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XHJcbmltcG9ydCBDb25maWcgZnJvbSAnLi9jb25maWcvY29uZmlnJztcclxuXHJcbmltcG9ydCBRdWFnZ2EgZnJvbSAnLi9xdWFnZ2EvcXVhZ2dhJztcclxuXHJcbmNvbnN0IGluc3RhbmNlID0gbmV3IFF1YWdnYSgpO1xyXG5jb25zdCBfY29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XHJcblxyXG5jb25zdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSA9IHtcclxuICAgIGluaXQ6IGZ1bmN0aW9uIChjb25maWcsIGNiLCBpbWFnZVdyYXBwZXIsIHF1YWdnYUluc3RhbmNlID0gaW5zdGFuY2UpIHtcclxuICAgICAgICBsZXQgcHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNiKSB7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZyA9IG1lcmdlKHt9LCBDb25maWcsIGNvbmZpZyk7XHJcbiAgICAgICAgLy8gVE9ETyAjMTc5OiBwZW5kaW5nIHJlc3RydWN0dXJlIGluIElzc3VlICMxNzksIHdlIGFyZSB0ZW1wIGRpc2FibGluZyB3b3JrZXJzXHJcbiAgICAgICAgaWYgKHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcclxuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGltYWdlV3JhcHBlcikge1xyXG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0Lm9uVUlUaHJlYWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyKTtcclxuICAgICAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdElucHV0U3RyZWFtKGNiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9LFxyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RhcnQoKTtcclxuICAgIH0sXHJcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnN0b3AoKTtcclxuICAgIH0sXHJcbiAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xyXG4gICAgfSxcclxuICAgIG9uRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vbkRldGVjdGVkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG4gICAgb2ZmRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG4gICAgb25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vblByb2Nlc3NlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcclxuICAgIH0sXHJcbiAgICBvZmZQcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuICAgIHNldFJlYWRlcnM6IGZ1bmN0aW9uIChyZWFkZXJzKSB7XHJcbiAgICAgICAgaWYgKCFyZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnNldFJlYWRlcnMgY2FsbGVkIHdpdGggbm8gcmVhZGVycywgaWdub3JpbmcnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5zZXRSZWFkZXJzKHJlYWRlcnMpO1xyXG4gICAgfSxcclxuICAgIHJlZ2lzdGVyUmVhZGVyOiBmdW5jdGlvbiAobmFtZSwgcmVhZGVyKSB7XHJcbiAgICAgICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIG5hbWUsIGlnbm9yaW5nJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZWFkZXIpIHtcclxuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIgY2FsbGVkIHdpdGggbm8gcmVhZGVyLCBpZ25vcmluZycpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XHJcbiAgICB9LFxyXG4gICAgcmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3I6IGZ1bmN0aW9uIChyZXN1bHRDb2xsZWN0b3IpIHtcclxuICAgICAgICBpZiAocmVzdWx0Q29sbGVjdG9yICYmIHR5cGVvZiByZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3VsdENvbGxlY3RvciA9IHJlc3VsdENvbGxlY3RvcjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0IGNhbnZhcygpIHtcclxuICAgICAgICByZXR1cm4gX2NvbnRleHQuY2FudmFzQ29udGFpbmVyO1xyXG4gICAgfSxcclxuICAgIGRlY29kZVNpbmdsZTogZnVuY3Rpb24gKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBxdWFnZ2FJbnN0YW5jZSA9IG5ldyBRdWFnZ2EoKTtcclxuICAgICAgICBjb25maWcgPSBtZXJnZSh7XHJcbiAgICAgICAgICAgIGlucHV0U3RyZWFtOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnSW1hZ2VTdHJlYW0nLFxyXG4gICAgICAgICAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogODAwLFxyXG4gICAgICAgICAgICAgICAgc3JjOiBjb25maWcuc3JjLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6IChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxyXG4gICAgICAgICAgICBsb2NhdG9yOiB7XHJcbiAgICAgICAgICAgICAgICBoYWxmU2FtcGxlOiBmYWxzZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LCBjb25maWcpO1xyXG4gICAgICAgIC8vIFRPRE8gIzE3NTogcmVzdHJ1Y3R1cmUgd29ya2VyIHN1cHBvcnQgc28gdGhhdCBpdCB3aWxsIHdvcmsgd2l0aCB0eXBlc2NyaXB0IHVzaW5nIHdvcmtlci1sb2FkZXJcclxuICAgICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2xvYWRlcnMvd29ya2VyLWxvYWRlci9cclxuICAgICAgICBpZiAoY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcclxuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdvcmtlcnMgcmVxdWlyZSBXb3JrZXIgYW5kIEJsb2Igc3VwcG9ydCBwcmVzZW50bHksIHNvIGlmIG5vIEJsb2Igb3IgV29ya2VyIHRoZW4gc2V0XHJcbiAgICAgICAgLy8gd29ya2VycyB0byAwLlxyXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCAmJiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJyogbm8gV29ya2VyIGFuZC9vciBCbG9iIHN1cHBvcnQgLSBmb3JjaW5nIG51bU9mV29ya2VycyB0byAwJyk7XHJcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIEV2ZW50cy5vbmNlKCdwcm9jZXNzZWQnLCAocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjay5jYWxsKG51bGwsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBxdWFnZ2FJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cclxuICAgIC8vIHdyaXRlIHRvIG1vZHVsZS5leHBvcnRzIHNvIGRvIGl0IGhlcmUuXHJcbiAgICBnZXQgZGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XHJcbiAgICB9LFxyXG4gICAgQmFyY29kZVJlYWRlcixcclxuICAgIENhbWVyYUFjY2VzcyxcclxuICAgIEltYWdlRGVidWcsXHJcbiAgICBJbWFnZVdyYXBwZXIsXHJcbiAgICBSZXN1bHRDb2xsZWN0b3IsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcclxuLy8gZXhwb3J0IEJhcmNvZGVSZWFkZXIgYW5kIG90aGVyIHV0aWxpdGllcyBmb3IgZXh0ZXJuYWwgcGx1Z2luc1xyXG5leHBvcnQge1xyXG4gICAgQmFyY29kZURlY29kZXIsXHJcbiAgICBCYXJjb2RlUmVhZGVyLFxyXG4gICAgQ2FtZXJhQWNjZXNzLFxyXG4gICAgSW1hZ2VEZWJ1ZyxcclxuICAgIEltYWdlV3JhcHBlcixcclxuICAgIFJlc3VsdENvbGxlY3RvcixcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==